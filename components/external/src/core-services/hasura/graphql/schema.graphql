schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

scalar account_type

"""
Boolean expression to compare columns of type "account_type". All fields are combined with logical 'AND'.
"""
input account_type_comparison_exp {
  _eq: account_type
  _gt: account_type
  _gte: account_type
  _in: [account_type!]
  _is_null: Boolean
  _lt: account_type
  _lte: account_type
  _neq: account_type
  _nin: [account_type!]
}

"""
columns and relationships of "accounts.account"
"""
type accounts_account {
  account_name: String!

  """An array relationship"""
  balances(
    """distinct select on columns"""
    distinct_on: [accounts_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_balances_order_by!]

    """filter the rows returned"""
    where: accounts_balances_bool_exp
  ): [accounts_balances!]!

  """An aggregate relationship"""
  balances_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_balances_order_by!]

    """filter the rows returned"""
    where: accounts_balances_bool_exp
  ): accounts_balances_aggregate!

  """An array relationship"""
  bank_account_related_accounts(
    """distinct select on columns"""
    distinct_on: [accounts_bank_account_related_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_bank_account_related_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bank_account_related_accounts_bool_exp
  ): [accounts_bank_account_related_accounts!]!

  """An aggregate relationship"""
  bank_account_related_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_bank_account_related_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_bank_account_related_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bank_account_related_accounts_bool_exp
  ): accounts_bank_account_related_accounts_aggregate!

  """An object relationship"""
  connector: connectors_connector!
  connector_id: String!
  created_at: timestamptz!
  default_currency: String!
  id: String!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payments_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_payment_order_by!]

    """filter the rows returned"""
    where: payments_payment_bool_exp
  ): [payments_payment!]!

  """An array relationship"""
  paymentsBySourceAccountId(
    """distinct select on columns"""
    distinct_on: [payments_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_payment_order_by!]

    """filter the rows returned"""
    where: payments_payment_bool_exp
  ): [payments_payment!]!

  """An aggregate relationship"""
  paymentsBySourceAccountId_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_payment_order_by!]

    """filter the rows returned"""
    where: payments_payment_bool_exp
  ): payments_payment_aggregate!

  """An aggregate relationship"""
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_payment_order_by!]

    """filter the rows returned"""
    where: payments_payment_bool_exp
  ): payments_payment_aggregate!

  """An array relationship"""
  pool_accounts(
    """distinct select on columns"""
    distinct_on: [accounts_pool_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_pool_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_pool_accounts_bool_exp
  ): [accounts_pool_accounts!]!

  """An aggregate relationship"""
  pool_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_pool_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_pool_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_pool_accounts_bool_exp
  ): accounts_pool_accounts_aggregate!
  raw_data(
    """JSON select path"""
    path: String
  ): json
  reference: String!

  """An array relationship"""
  transferInitiationsBySourceAccountId(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_bool_exp
  ): [transfers_transfer_initiation!]!

  """An aggregate relationship"""
  transferInitiationsBySourceAccountId_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_bool_exp
  ): transfers_transfer_initiation_aggregate!

  """An array relationship"""
  transfer_initiations(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_bool_exp
  ): [transfers_transfer_initiation!]!

  """An aggregate relationship"""
  transfer_initiations_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_bool_exp
  ): transfers_transfer_initiation_aggregate!
  type: account_type
}

"""
aggregated selection of "accounts.account"
"""
type accounts_account_aggregate {
  aggregate: accounts_account_aggregate_fields
  nodes: [accounts_account!]!
}

input accounts_account_aggregate_bool_exp {
  count: accounts_account_aggregate_bool_exp_count
}

input accounts_account_aggregate_bool_exp_count {
  arguments: [accounts_account_select_column!]
  distinct: Boolean
  filter: accounts_account_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "accounts.account"
"""
type accounts_account_aggregate_fields {
  count(columns: [accounts_account_select_column!], distinct: Boolean): Int!
  max: accounts_account_max_fields
  min: accounts_account_min_fields
}

"""
order by aggregate values of table "accounts.account"
"""
input accounts_account_aggregate_order_by {
  count: order_by
  max: accounts_account_max_order_by
  min: accounts_account_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input accounts_account_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "accounts.account"
"""
input accounts_account_arr_rel_insert_input {
  data: [accounts_account_insert_input!]!

  """upsert condition"""
  on_conflict: accounts_account_on_conflict
}

"""
Boolean expression to filter rows from the table "accounts.account". All fields are combined with a logical 'AND'.
"""
input accounts_account_bool_exp {
  _and: [accounts_account_bool_exp!]
  _not: accounts_account_bool_exp
  _or: [accounts_account_bool_exp!]
  account_name: String_comparison_exp
  balances: accounts_balances_bool_exp
  balances_aggregate: accounts_balances_aggregate_bool_exp
  bank_account_related_accounts: accounts_bank_account_related_accounts_bool_exp
  bank_account_related_accounts_aggregate: accounts_bank_account_related_accounts_aggregate_bool_exp
  connector: connectors_connector_bool_exp
  connector_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  default_currency: String_comparison_exp
  id: String_comparison_exp
  metadata: jsonb_comparison_exp
  payments: payments_payment_bool_exp
  paymentsBySourceAccountId: payments_payment_bool_exp
  paymentsBySourceAccountId_aggregate: payments_payment_aggregate_bool_exp
  payments_aggregate: payments_payment_aggregate_bool_exp
  pool_accounts: accounts_pool_accounts_bool_exp
  pool_accounts_aggregate: accounts_pool_accounts_aggregate_bool_exp
  raw_data: json_comparison_exp
  reference: String_comparison_exp
  transferInitiationsBySourceAccountId: transfers_transfer_initiation_bool_exp
  transferInitiationsBySourceAccountId_aggregate: transfers_transfer_initiation_aggregate_bool_exp
  transfer_initiations: transfers_transfer_initiation_bool_exp
  transfer_initiations_aggregate: transfers_transfer_initiation_aggregate_bool_exp
  type: account_type_comparison_exp
}

"""
unique or primary key constraints on table "accounts.account"
"""
enum accounts_account_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  account_pk
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input accounts_account_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input accounts_account_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input accounts_account_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "accounts.account"
"""
input accounts_account_insert_input {
  account_name: String
  balances: accounts_balances_arr_rel_insert_input
  bank_account_related_accounts: accounts_bank_account_related_accounts_arr_rel_insert_input
  connector: connectors_connector_obj_rel_insert_input
  connector_id: String
  created_at: timestamptz
  default_currency: String
  id: String
  metadata: jsonb
  payments: payments_payment_arr_rel_insert_input
  paymentsBySourceAccountId: payments_payment_arr_rel_insert_input
  pool_accounts: accounts_pool_accounts_arr_rel_insert_input
  raw_data: json
  reference: String
  transferInitiationsBySourceAccountId: transfers_transfer_initiation_arr_rel_insert_input
  transfer_initiations: transfers_transfer_initiation_arr_rel_insert_input
  type: account_type
}

"""aggregate max on columns"""
type accounts_account_max_fields {
  account_name: String
  connector_id: String
  created_at: timestamptz
  default_currency: String
  id: String
  reference: String
  type: account_type
}

"""
order by max() on columns of table "accounts.account"
"""
input accounts_account_max_order_by {
  account_name: order_by
  connector_id: order_by
  created_at: order_by
  default_currency: order_by
  id: order_by
  reference: order_by
  type: order_by
}

"""aggregate min on columns"""
type accounts_account_min_fields {
  account_name: String
  connector_id: String
  created_at: timestamptz
  default_currency: String
  id: String
  reference: String
  type: account_type
}

"""
order by min() on columns of table "accounts.account"
"""
input accounts_account_min_order_by {
  account_name: order_by
  connector_id: order_by
  created_at: order_by
  default_currency: order_by
  id: order_by
  reference: order_by
  type: order_by
}

"""
response of any mutation on the table "accounts.account"
"""
type accounts_account_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [accounts_account!]!
}

"""
input type for inserting object relation for remote table "accounts.account"
"""
input accounts_account_obj_rel_insert_input {
  data: accounts_account_insert_input!

  """upsert condition"""
  on_conflict: accounts_account_on_conflict
}

"""
on_conflict condition type for table "accounts.account"
"""
input accounts_account_on_conflict {
  constraint: accounts_account_constraint!
  update_columns: [accounts_account_update_column!]! = []
  where: accounts_account_bool_exp
}

"""Ordering options when selecting data from "accounts.account"."""
input accounts_account_order_by {
  account_name: order_by
  balances_aggregate: accounts_balances_aggregate_order_by
  bank_account_related_accounts_aggregate: accounts_bank_account_related_accounts_aggregate_order_by
  connector: connectors_connector_order_by
  connector_id: order_by
  created_at: order_by
  default_currency: order_by
  id: order_by
  metadata: order_by
  paymentsBySourceAccountId_aggregate: payments_payment_aggregate_order_by
  payments_aggregate: payments_payment_aggregate_order_by
  pool_accounts_aggregate: accounts_pool_accounts_aggregate_order_by
  raw_data: order_by
  reference: order_by
  transferInitiationsBySourceAccountId_aggregate: transfers_transfer_initiation_aggregate_order_by
  transfer_initiations_aggregate: transfers_transfer_initiation_aggregate_order_by
  type: order_by
}

"""primary key columns input for table: accounts.account"""
input accounts_account_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input accounts_account_prepend_input {
  metadata: jsonb
}

"""
select columns of table "accounts.account"
"""
enum accounts_account_select_column {
  """column name"""
  account_name

  """column name"""
  connector_id

  """column name"""
  created_at

  """column name"""
  default_currency

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  raw_data

  """column name"""
  reference

  """column name"""
  type
}

"""
input type for updating data in table "accounts.account"
"""
input accounts_account_set_input {
  account_name: String
  connector_id: String
  created_at: timestamptz
  default_currency: String
  id: String
  metadata: jsonb
  raw_data: json
  reference: String
  type: account_type
}

"""
Streaming cursor of the table "accounts_account"
"""
input accounts_account_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: accounts_account_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input accounts_account_stream_cursor_value_input {
  account_name: String
  connector_id: String
  created_at: timestamptz
  default_currency: String
  id: String
  metadata: jsonb
  raw_data: json
  reference: String
  type: account_type
}

"""
update columns of table "accounts.account"
"""
enum accounts_account_update_column {
  """column name"""
  account_name

  """column name"""
  connector_id

  """column name"""
  created_at

  """column name"""
  default_currency

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  raw_data

  """column name"""
  reference

  """column name"""
  type
}

input accounts_account_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: accounts_account_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: accounts_account_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: accounts_account_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: accounts_account_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: accounts_account_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: accounts_account_set_input

  """filter the rows which have to be updated"""
  where: accounts_account_bool_exp!
}

"""
columns and relationships of "accounts.balances"
"""
type accounts_balances {
  """An object relationship"""
  account: accounts_account!
  account_id: String!
  balance: numeric!
  created_at: timestamptz!
  currency: String!
  last_updated_at: timestamptz!
}

"""
aggregated selection of "accounts.balances"
"""
type accounts_balances_aggregate {
  aggregate: accounts_balances_aggregate_fields
  nodes: [accounts_balances!]!
}

input accounts_balances_aggregate_bool_exp {
  count: accounts_balances_aggregate_bool_exp_count
}

input accounts_balances_aggregate_bool_exp_count {
  arguments: [accounts_balances_select_column!]
  distinct: Boolean
  filter: accounts_balances_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "accounts.balances"
"""
type accounts_balances_aggregate_fields {
  avg: accounts_balances_avg_fields
  count(columns: [accounts_balances_select_column!], distinct: Boolean): Int!
  max: accounts_balances_max_fields
  min: accounts_balances_min_fields
  stddev: accounts_balances_stddev_fields
  stddev_pop: accounts_balances_stddev_pop_fields
  stddev_samp: accounts_balances_stddev_samp_fields
  sum: accounts_balances_sum_fields
  var_pop: accounts_balances_var_pop_fields
  var_samp: accounts_balances_var_samp_fields
  variance: accounts_balances_variance_fields
}

"""
order by aggregate values of table "accounts.balances"
"""
input accounts_balances_aggregate_order_by {
  avg: accounts_balances_avg_order_by
  count: order_by
  max: accounts_balances_max_order_by
  min: accounts_balances_min_order_by
  stddev: accounts_balances_stddev_order_by
  stddev_pop: accounts_balances_stddev_pop_order_by
  stddev_samp: accounts_balances_stddev_samp_order_by
  sum: accounts_balances_sum_order_by
  var_pop: accounts_balances_var_pop_order_by
  var_samp: accounts_balances_var_samp_order_by
  variance: accounts_balances_variance_order_by
}

"""
input type for inserting array relation for remote table "accounts.balances"
"""
input accounts_balances_arr_rel_insert_input {
  data: [accounts_balances_insert_input!]!

  """upsert condition"""
  on_conflict: accounts_balances_on_conflict
}

"""aggregate avg on columns"""
type accounts_balances_avg_fields {
  balance: Float
}

"""
order by avg() on columns of table "accounts.balances"
"""
input accounts_balances_avg_order_by {
  balance: order_by
}

"""
Boolean expression to filter rows from the table "accounts.balances". All fields are combined with a logical 'AND'.
"""
input accounts_balances_bool_exp {
  _and: [accounts_balances_bool_exp!]
  _not: accounts_balances_bool_exp
  _or: [accounts_balances_bool_exp!]
  account: accounts_account_bool_exp
  account_id: String_comparison_exp
  balance: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  last_updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "accounts.balances"
"""
enum accounts_balances_constraint {
  """
  unique or primary key constraint on columns "currency", "account_id", "created_at"
  """
  balances_pkey
}

"""
input type for incrementing numeric columns in table "accounts.balances"
"""
input accounts_balances_inc_input {
  balance: numeric
}

"""
input type for inserting data into table "accounts.balances"
"""
input accounts_balances_insert_input {
  account: accounts_account_obj_rel_insert_input
  account_id: String
  balance: numeric
  created_at: timestamptz
  currency: String
  last_updated_at: timestamptz
}

"""aggregate max on columns"""
type accounts_balances_max_fields {
  account_id: String
  balance: numeric
  created_at: timestamptz
  currency: String
  last_updated_at: timestamptz
}

"""
order by max() on columns of table "accounts.balances"
"""
input accounts_balances_max_order_by {
  account_id: order_by
  balance: order_by
  created_at: order_by
  currency: order_by
  last_updated_at: order_by
}

"""aggregate min on columns"""
type accounts_balances_min_fields {
  account_id: String
  balance: numeric
  created_at: timestamptz
  currency: String
  last_updated_at: timestamptz
}

"""
order by min() on columns of table "accounts.balances"
"""
input accounts_balances_min_order_by {
  account_id: order_by
  balance: order_by
  created_at: order_by
  currency: order_by
  last_updated_at: order_by
}

"""
response of any mutation on the table "accounts.balances"
"""
type accounts_balances_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [accounts_balances!]!
}

"""
on_conflict condition type for table "accounts.balances"
"""
input accounts_balances_on_conflict {
  constraint: accounts_balances_constraint!
  update_columns: [accounts_balances_update_column!]! = []
  where: accounts_balances_bool_exp
}

"""Ordering options when selecting data from "accounts.balances"."""
input accounts_balances_order_by {
  account: accounts_account_order_by
  account_id: order_by
  balance: order_by
  created_at: order_by
  currency: order_by
  last_updated_at: order_by
}

"""primary key columns input for table: accounts.balances"""
input accounts_balances_pk_columns_input {
  account_id: String!
  created_at: timestamptz!
  currency: String!
}

"""
select columns of table "accounts.balances"
"""
enum accounts_balances_select_column {
  """column name"""
  account_id

  """column name"""
  balance

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  last_updated_at
}

"""
input type for updating data in table "accounts.balances"
"""
input accounts_balances_set_input {
  account_id: String
  balance: numeric
  created_at: timestamptz
  currency: String
  last_updated_at: timestamptz
}

"""aggregate stddev on columns"""
type accounts_balances_stddev_fields {
  balance: Float
}

"""
order by stddev() on columns of table "accounts.balances"
"""
input accounts_balances_stddev_order_by {
  balance: order_by
}

"""aggregate stddev_pop on columns"""
type accounts_balances_stddev_pop_fields {
  balance: Float
}

"""
order by stddev_pop() on columns of table "accounts.balances"
"""
input accounts_balances_stddev_pop_order_by {
  balance: order_by
}

"""aggregate stddev_samp on columns"""
type accounts_balances_stddev_samp_fields {
  balance: Float
}

"""
order by stddev_samp() on columns of table "accounts.balances"
"""
input accounts_balances_stddev_samp_order_by {
  balance: order_by
}

"""
Streaming cursor of the table "accounts_balances"
"""
input accounts_balances_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: accounts_balances_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input accounts_balances_stream_cursor_value_input {
  account_id: String
  balance: numeric
  created_at: timestamptz
  currency: String
  last_updated_at: timestamptz
}

"""aggregate sum on columns"""
type accounts_balances_sum_fields {
  balance: numeric
}

"""
order by sum() on columns of table "accounts.balances"
"""
input accounts_balances_sum_order_by {
  balance: order_by
}

"""
update columns of table "accounts.balances"
"""
enum accounts_balances_update_column {
  """column name"""
  account_id

  """column name"""
  balance

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  last_updated_at
}

input accounts_balances_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: accounts_balances_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: accounts_balances_set_input

  """filter the rows which have to be updated"""
  where: accounts_balances_bool_exp!
}

"""aggregate var_pop on columns"""
type accounts_balances_var_pop_fields {
  balance: Float
}

"""
order by var_pop() on columns of table "accounts.balances"
"""
input accounts_balances_var_pop_order_by {
  balance: order_by
}

"""aggregate var_samp on columns"""
type accounts_balances_var_samp_fields {
  balance: Float
}

"""
order by var_samp() on columns of table "accounts.balances"
"""
input accounts_balances_var_samp_order_by {
  balance: order_by
}

"""aggregate variance on columns"""
type accounts_balances_variance_fields {
  balance: Float
}

"""
order by variance() on columns of table "accounts.balances"
"""
input accounts_balances_variance_order_by {
  balance: order_by
}

"""
columns and relationships of "accounts.bank_account"
"""
type accounts_bank_account {
  account_number: bytea

  """An array relationship"""
  bank_account_related_accounts(
    """distinct select on columns"""
    distinct_on: [accounts_bank_account_related_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_bank_account_related_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bank_account_related_accounts_bool_exp
  ): [accounts_bank_account_related_accounts!]!

  """An aggregate relationship"""
  bank_account_related_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_bank_account_related_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_bank_account_related_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bank_account_related_accounts_bool_exp
  ): accounts_bank_account_related_accounts_aggregate!
  country: String
  created_at: timestamptz!
  iban: bytea
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  name: String!
  swift_bic_code: bytea
}

"""
aggregated selection of "accounts.bank_account"
"""
type accounts_bank_account_aggregate {
  aggregate: accounts_bank_account_aggregate_fields
  nodes: [accounts_bank_account!]!
}

"""
aggregate fields of "accounts.bank_account"
"""
type accounts_bank_account_aggregate_fields {
  count(columns: [accounts_bank_account_select_column!], distinct: Boolean): Int!
  max: accounts_bank_account_max_fields
  min: accounts_bank_account_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input accounts_bank_account_append_input {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "accounts.bank_account". All fields are combined with a logical 'AND'.
"""
input accounts_bank_account_bool_exp {
  _and: [accounts_bank_account_bool_exp!]
  _not: accounts_bank_account_bool_exp
  _or: [accounts_bank_account_bool_exp!]
  account_number: bytea_comparison_exp
  bank_account_related_accounts: accounts_bank_account_related_accounts_bool_exp
  bank_account_related_accounts_aggregate: accounts_bank_account_related_accounts_aggregate_bool_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  iban: bytea_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  name: String_comparison_exp
  swift_bic_code: bytea_comparison_exp
}

"""
unique or primary key constraints on table "accounts.bank_account"
"""
enum accounts_bank_account_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  bank_account_pk
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input accounts_bank_account_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input accounts_bank_account_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input accounts_bank_account_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "accounts.bank_account"
"""
input accounts_bank_account_insert_input {
  account_number: bytea
  bank_account_related_accounts: accounts_bank_account_related_accounts_arr_rel_insert_input
  country: String
  created_at: timestamptz
  iban: bytea
  id: uuid
  metadata: jsonb
  name: String
  swift_bic_code: bytea
}

"""aggregate max on columns"""
type accounts_bank_account_max_fields {
  country: String
  created_at: timestamptz
  id: uuid
  name: String
}

"""aggregate min on columns"""
type accounts_bank_account_min_fields {
  country: String
  created_at: timestamptz
  id: uuid
  name: String
}

"""
response of any mutation on the table "accounts.bank_account"
"""
type accounts_bank_account_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [accounts_bank_account!]!
}

"""
input type for inserting object relation for remote table "accounts.bank_account"
"""
input accounts_bank_account_obj_rel_insert_input {
  data: accounts_bank_account_insert_input!

  """upsert condition"""
  on_conflict: accounts_bank_account_on_conflict
}

"""
on_conflict condition type for table "accounts.bank_account"
"""
input accounts_bank_account_on_conflict {
  constraint: accounts_bank_account_constraint!
  update_columns: [accounts_bank_account_update_column!]! = []
  where: accounts_bank_account_bool_exp
}

"""Ordering options when selecting data from "accounts.bank_account"."""
input accounts_bank_account_order_by {
  account_number: order_by
  bank_account_related_accounts_aggregate: accounts_bank_account_related_accounts_aggregate_order_by
  country: order_by
  created_at: order_by
  iban: order_by
  id: order_by
  metadata: order_by
  name: order_by
  swift_bic_code: order_by
}

"""primary key columns input for table: accounts.bank_account"""
input accounts_bank_account_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input accounts_bank_account_prepend_input {
  metadata: jsonb
}

"""
columns and relationships of "accounts.bank_account_related_accounts"
"""
type accounts_bank_account_related_accounts {
  """An object relationship"""
  account: accounts_account!
  account_id: String!

  """An object relationship"""
  bank_account: accounts_bank_account!
  bank_account_id: uuid!

  """An object relationship"""
  connector: connectors_connector!
  connector_id: String!
  created_at: timestamptz!
  id: uuid!
}

"""
aggregated selection of "accounts.bank_account_related_accounts"
"""
type accounts_bank_account_related_accounts_aggregate {
  aggregate: accounts_bank_account_related_accounts_aggregate_fields
  nodes: [accounts_bank_account_related_accounts!]!
}

input accounts_bank_account_related_accounts_aggregate_bool_exp {
  count: accounts_bank_account_related_accounts_aggregate_bool_exp_count
}

input accounts_bank_account_related_accounts_aggregate_bool_exp_count {
  arguments: [accounts_bank_account_related_accounts_select_column!]
  distinct: Boolean
  filter: accounts_bank_account_related_accounts_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "accounts.bank_account_related_accounts"
"""
type accounts_bank_account_related_accounts_aggregate_fields {
  count(columns: [accounts_bank_account_related_accounts_select_column!], distinct: Boolean): Int!
  max: accounts_bank_account_related_accounts_max_fields
  min: accounts_bank_account_related_accounts_min_fields
}

"""
order by aggregate values of table "accounts.bank_account_related_accounts"
"""
input accounts_bank_account_related_accounts_aggregate_order_by {
  count: order_by
  max: accounts_bank_account_related_accounts_max_order_by
  min: accounts_bank_account_related_accounts_min_order_by
}

"""
input type for inserting array relation for remote table "accounts.bank_account_related_accounts"
"""
input accounts_bank_account_related_accounts_arr_rel_insert_input {
  data: [accounts_bank_account_related_accounts_insert_input!]!

  """upsert condition"""
  on_conflict: accounts_bank_account_related_accounts_on_conflict
}

"""
Boolean expression to filter rows from the table "accounts.bank_account_related_accounts". All fields are combined with a logical 'AND'.
"""
input accounts_bank_account_related_accounts_bool_exp {
  _and: [accounts_bank_account_related_accounts_bool_exp!]
  _not: accounts_bank_account_related_accounts_bool_exp
  _or: [accounts_bank_account_related_accounts_bool_exp!]
  account: accounts_account_bool_exp
  account_id: String_comparison_exp
  bank_account: accounts_bank_account_bool_exp
  bank_account_id: uuid_comparison_exp
  connector: connectors_connector_bool_exp
  connector_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "accounts.bank_account_related_accounts"
"""
enum accounts_bank_account_related_accounts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  transfer_initiation_adjustments_pk
}

"""
input type for inserting data into table "accounts.bank_account_related_accounts"
"""
input accounts_bank_account_related_accounts_insert_input {
  account: accounts_account_obj_rel_insert_input
  account_id: String
  bank_account: accounts_bank_account_obj_rel_insert_input
  bank_account_id: uuid
  connector: connectors_connector_obj_rel_insert_input
  connector_id: String
  created_at: timestamptz
  id: uuid
}

"""aggregate max on columns"""
type accounts_bank_account_related_accounts_max_fields {
  account_id: String
  bank_account_id: uuid
  connector_id: String
  created_at: timestamptz
  id: uuid
}

"""
order by max() on columns of table "accounts.bank_account_related_accounts"
"""
input accounts_bank_account_related_accounts_max_order_by {
  account_id: order_by
  bank_account_id: order_by
  connector_id: order_by
  created_at: order_by
  id: order_by
}

"""aggregate min on columns"""
type accounts_bank_account_related_accounts_min_fields {
  account_id: String
  bank_account_id: uuid
  connector_id: String
  created_at: timestamptz
  id: uuid
}

"""
order by min() on columns of table "accounts.bank_account_related_accounts"
"""
input accounts_bank_account_related_accounts_min_order_by {
  account_id: order_by
  bank_account_id: order_by
  connector_id: order_by
  created_at: order_by
  id: order_by
}

"""
response of any mutation on the table "accounts.bank_account_related_accounts"
"""
type accounts_bank_account_related_accounts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [accounts_bank_account_related_accounts!]!
}

"""
on_conflict condition type for table "accounts.bank_account_related_accounts"
"""
input accounts_bank_account_related_accounts_on_conflict {
  constraint: accounts_bank_account_related_accounts_constraint!
  update_columns: [accounts_bank_account_related_accounts_update_column!]! = []
  where: accounts_bank_account_related_accounts_bool_exp
}

"""
Ordering options when selecting data from "accounts.bank_account_related_accounts".
"""
input accounts_bank_account_related_accounts_order_by {
  account: accounts_account_order_by
  account_id: order_by
  bank_account: accounts_bank_account_order_by
  bank_account_id: order_by
  connector: connectors_connector_order_by
  connector_id: order_by
  created_at: order_by
  id: order_by
}

"""
primary key columns input for table: accounts.bank_account_related_accounts
"""
input accounts_bank_account_related_accounts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "accounts.bank_account_related_accounts"
"""
enum accounts_bank_account_related_accounts_select_column {
  """column name"""
  account_id

  """column name"""
  bank_account_id

  """column name"""
  connector_id

  """column name"""
  created_at

  """column name"""
  id
}

"""
input type for updating data in table "accounts.bank_account_related_accounts"
"""
input accounts_bank_account_related_accounts_set_input {
  account_id: String
  bank_account_id: uuid
  connector_id: String
  created_at: timestamptz
  id: uuid
}

"""
Streaming cursor of the table "accounts_bank_account_related_accounts"
"""
input accounts_bank_account_related_accounts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: accounts_bank_account_related_accounts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input accounts_bank_account_related_accounts_stream_cursor_value_input {
  account_id: String
  bank_account_id: uuid
  connector_id: String
  created_at: timestamptz
  id: uuid
}

"""
update columns of table "accounts.bank_account_related_accounts"
"""
enum accounts_bank_account_related_accounts_update_column {
  """column name"""
  account_id

  """column name"""
  bank_account_id

  """column name"""
  connector_id

  """column name"""
  created_at

  """column name"""
  id
}

input accounts_bank_account_related_accounts_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: accounts_bank_account_related_accounts_set_input

  """filter the rows which have to be updated"""
  where: accounts_bank_account_related_accounts_bool_exp!
}

"""
select columns of table "accounts.bank_account"
"""
enum accounts_bank_account_select_column {
  """column name"""
  account_number

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  iban

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  swift_bic_code
}

"""
input type for updating data in table "accounts.bank_account"
"""
input accounts_bank_account_set_input {
  account_number: bytea
  country: String
  created_at: timestamptz
  iban: bytea
  id: uuid
  metadata: jsonb
  name: String
  swift_bic_code: bytea
}

"""
Streaming cursor of the table "accounts_bank_account"
"""
input accounts_bank_account_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: accounts_bank_account_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input accounts_bank_account_stream_cursor_value_input {
  account_number: bytea
  country: String
  created_at: timestamptz
  iban: bytea
  id: uuid
  metadata: jsonb
  name: String
  swift_bic_code: bytea
}

"""
update columns of table "accounts.bank_account"
"""
enum accounts_bank_account_update_column {
  """column name"""
  account_number

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  iban

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  swift_bic_code
}

input accounts_bank_account_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: accounts_bank_account_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: accounts_bank_account_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: accounts_bank_account_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: accounts_bank_account_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: accounts_bank_account_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: accounts_bank_account_set_input

  """filter the rows which have to be updated"""
  where: accounts_bank_account_bool_exp!
}

"""
columns and relationships of "accounts.pool_accounts"
"""
type accounts_pool_accounts {
  """An object relationship"""
  account: accounts_account!
  account_id: String!

  """An object relationship"""
  pool: accounts_pools!
  pool_id: uuid!
}

"""
aggregated selection of "accounts.pool_accounts"
"""
type accounts_pool_accounts_aggregate {
  aggregate: accounts_pool_accounts_aggregate_fields
  nodes: [accounts_pool_accounts!]!
}

input accounts_pool_accounts_aggregate_bool_exp {
  count: accounts_pool_accounts_aggregate_bool_exp_count
}

input accounts_pool_accounts_aggregate_bool_exp_count {
  arguments: [accounts_pool_accounts_select_column!]
  distinct: Boolean
  filter: accounts_pool_accounts_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "accounts.pool_accounts"
"""
type accounts_pool_accounts_aggregate_fields {
  count(columns: [accounts_pool_accounts_select_column!], distinct: Boolean): Int!
  max: accounts_pool_accounts_max_fields
  min: accounts_pool_accounts_min_fields
}

"""
order by aggregate values of table "accounts.pool_accounts"
"""
input accounts_pool_accounts_aggregate_order_by {
  count: order_by
  max: accounts_pool_accounts_max_order_by
  min: accounts_pool_accounts_min_order_by
}

"""
input type for inserting array relation for remote table "accounts.pool_accounts"
"""
input accounts_pool_accounts_arr_rel_insert_input {
  data: [accounts_pool_accounts_insert_input!]!

  """upsert condition"""
  on_conflict: accounts_pool_accounts_on_conflict
}

"""
Boolean expression to filter rows from the table "accounts.pool_accounts". All fields are combined with a logical 'AND'.
"""
input accounts_pool_accounts_bool_exp {
  _and: [accounts_pool_accounts_bool_exp!]
  _not: accounts_pool_accounts_bool_exp
  _or: [accounts_pool_accounts_bool_exp!]
  account: accounts_account_bool_exp
  account_id: String_comparison_exp
  pool: accounts_pools_bool_exp
  pool_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "accounts.pool_accounts"
"""
enum accounts_pool_accounts_constraint {
  """
  unique or primary key constraint on columns "pool_id", "account_id"
  """
  pool_accounts_pk
}

"""
input type for inserting data into table "accounts.pool_accounts"
"""
input accounts_pool_accounts_insert_input {
  account: accounts_account_obj_rel_insert_input
  account_id: String
  pool: accounts_pools_obj_rel_insert_input
  pool_id: uuid
}

"""aggregate max on columns"""
type accounts_pool_accounts_max_fields {
  account_id: String
  pool_id: uuid
}

"""
order by max() on columns of table "accounts.pool_accounts"
"""
input accounts_pool_accounts_max_order_by {
  account_id: order_by
  pool_id: order_by
}

"""aggregate min on columns"""
type accounts_pool_accounts_min_fields {
  account_id: String
  pool_id: uuid
}

"""
order by min() on columns of table "accounts.pool_accounts"
"""
input accounts_pool_accounts_min_order_by {
  account_id: order_by
  pool_id: order_by
}

"""
response of any mutation on the table "accounts.pool_accounts"
"""
type accounts_pool_accounts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [accounts_pool_accounts!]!
}

"""
on_conflict condition type for table "accounts.pool_accounts"
"""
input accounts_pool_accounts_on_conflict {
  constraint: accounts_pool_accounts_constraint!
  update_columns: [accounts_pool_accounts_update_column!]! = []
  where: accounts_pool_accounts_bool_exp
}

"""Ordering options when selecting data from "accounts.pool_accounts"."""
input accounts_pool_accounts_order_by {
  account: accounts_account_order_by
  account_id: order_by
  pool: accounts_pools_order_by
  pool_id: order_by
}

"""primary key columns input for table: accounts.pool_accounts"""
input accounts_pool_accounts_pk_columns_input {
  account_id: String!
  pool_id: uuid!
}

"""
select columns of table "accounts.pool_accounts"
"""
enum accounts_pool_accounts_select_column {
  """column name"""
  account_id

  """column name"""
  pool_id
}

"""
input type for updating data in table "accounts.pool_accounts"
"""
input accounts_pool_accounts_set_input {
  account_id: String
  pool_id: uuid
}

"""
Streaming cursor of the table "accounts_pool_accounts"
"""
input accounts_pool_accounts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: accounts_pool_accounts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input accounts_pool_accounts_stream_cursor_value_input {
  account_id: String
  pool_id: uuid
}

"""
update columns of table "accounts.pool_accounts"
"""
enum accounts_pool_accounts_update_column {
  """column name"""
  account_id

  """column name"""
  pool_id
}

input accounts_pool_accounts_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: accounts_pool_accounts_set_input

  """filter the rows which have to be updated"""
  where: accounts_pool_accounts_bool_exp!
}

"""
columns and relationships of "accounts.pools"
"""
type accounts_pools {
  created_at: timestamptz!
  id: uuid!
  name: String!

  """An array relationship"""
  pool_accounts(
    """distinct select on columns"""
    distinct_on: [accounts_pool_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_pool_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_pool_accounts_bool_exp
  ): [accounts_pool_accounts!]!

  """An aggregate relationship"""
  pool_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_pool_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_pool_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_pool_accounts_bool_exp
  ): accounts_pool_accounts_aggregate!
}

"""
aggregated selection of "accounts.pools"
"""
type accounts_pools_aggregate {
  aggregate: accounts_pools_aggregate_fields
  nodes: [accounts_pools!]!
}

"""
aggregate fields of "accounts.pools"
"""
type accounts_pools_aggregate_fields {
  count(columns: [accounts_pools_select_column!], distinct: Boolean): Int!
  max: accounts_pools_max_fields
  min: accounts_pools_min_fields
}

"""
Boolean expression to filter rows from the table "accounts.pools". All fields are combined with a logical 'AND'.
"""
input accounts_pools_bool_exp {
  _and: [accounts_pools_bool_exp!]
  _not: accounts_pools_bool_exp
  _or: [accounts_pools_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  pool_accounts: accounts_pool_accounts_bool_exp
  pool_accounts_aggregate: accounts_pool_accounts_aggregate_bool_exp
}

"""
unique or primary key constraints on table "accounts.pools"
"""
enum accounts_pools_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  pools_name_key

  """
  unique or primary key constraint on columns "id"
  """
  pools_pk
}

"""
input type for inserting data into table "accounts.pools"
"""
input accounts_pools_insert_input {
  created_at: timestamptz
  id: uuid
  name: String
  pool_accounts: accounts_pool_accounts_arr_rel_insert_input
}

"""aggregate max on columns"""
type accounts_pools_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
}

"""aggregate min on columns"""
type accounts_pools_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
}

"""
response of any mutation on the table "accounts.pools"
"""
type accounts_pools_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [accounts_pools!]!
}

"""
input type for inserting object relation for remote table "accounts.pools"
"""
input accounts_pools_obj_rel_insert_input {
  data: accounts_pools_insert_input!

  """upsert condition"""
  on_conflict: accounts_pools_on_conflict
}

"""
on_conflict condition type for table "accounts.pools"
"""
input accounts_pools_on_conflict {
  constraint: accounts_pools_constraint!
  update_columns: [accounts_pools_update_column!]! = []
  where: accounts_pools_bool_exp
}

"""Ordering options when selecting data from "accounts.pools"."""
input accounts_pools_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  pool_accounts_aggregate: accounts_pool_accounts_aggregate_order_by
}

"""primary key columns input for table: accounts.pools"""
input accounts_pools_pk_columns_input {
  id: uuid!
}

"""
select columns of table "accounts.pools"
"""
enum accounts_pools_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "accounts.pools"
"""
input accounts_pools_set_input {
  created_at: timestamptz
  id: uuid
  name: String
}

"""
Streaming cursor of the table "accounts_pools"
"""
input accounts_pools_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: accounts_pools_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input accounts_pools_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  name: String
}

"""
update columns of table "accounts.pools"
"""
enum accounts_pools_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name
}

input accounts_pools_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: accounts_pools_set_input

  """filter the rows which have to be updated"""
  where: accounts_pools_bool_exp!
}

"""
columns and relationships of "areas"
"""
type areas {
  """An object relationship"""
  city: cities!
  city_id: Int!
  created_at: timestamp!

  """An object relationship"""
  governorate: governorates!
  governorate_id: Int!
  id: Int!
  mc_id: Int!
  name_ar: String!
  name_en: String!
  updated_at: timestamp!
}

"""
aggregated selection of "areas"
"""
type areas_aggregate {
  aggregate: areas_aggregate_fields
  nodes: [areas!]!
}

input areas_aggregate_bool_exp {
  count: areas_aggregate_bool_exp_count
}

input areas_aggregate_bool_exp_count {
  arguments: [areas_select_column!]
  distinct: Boolean
  filter: areas_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "areas"
"""
type areas_aggregate_fields {
  avg: areas_avg_fields
  count(columns: [areas_select_column!], distinct: Boolean): Int!
  max: areas_max_fields
  min: areas_min_fields
  stddev: areas_stddev_fields
  stddev_pop: areas_stddev_pop_fields
  stddev_samp: areas_stddev_samp_fields
  sum: areas_sum_fields
  var_pop: areas_var_pop_fields
  var_samp: areas_var_samp_fields
  variance: areas_variance_fields
}

"""
order by aggregate values of table "areas"
"""
input areas_aggregate_order_by {
  avg: areas_avg_order_by
  count: order_by
  max: areas_max_order_by
  min: areas_min_order_by
  stddev: areas_stddev_order_by
  stddev_pop: areas_stddev_pop_order_by
  stddev_samp: areas_stddev_samp_order_by
  sum: areas_sum_order_by
  var_pop: areas_var_pop_order_by
  var_samp: areas_var_samp_order_by
  variance: areas_variance_order_by
}

"""
input type for inserting array relation for remote table "areas"
"""
input areas_arr_rel_insert_input {
  data: [areas_insert_input!]!

  """upsert condition"""
  on_conflict: areas_on_conflict
}

"""aggregate avg on columns"""
type areas_avg_fields {
  city_id: Float
  governorate_id: Float
  id: Float
  mc_id: Float
}

"""
order by avg() on columns of table "areas"
"""
input areas_avg_order_by {
  city_id: order_by
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""
Boolean expression to filter rows from the table "areas". All fields are combined with a logical 'AND'.
"""
input areas_bool_exp {
  _and: [areas_bool_exp!]
  _not: areas_bool_exp
  _or: [areas_bool_exp!]
  city: cities_bool_exp
  city_id: Int_comparison_exp
  created_at: timestamp_comparison_exp
  governorate: governorates_bool_exp
  governorate_id: Int_comparison_exp
  id: Int_comparison_exp
  mc_id: Int_comparison_exp
  name_ar: String_comparison_exp
  name_en: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "areas"
"""
enum areas_constraint {
  """
  unique or primary key constraint on columns "mc_id"
  """
  areas_mc_id_key

  """
  unique or primary key constraint on columns "id"
  """
  areas_pkey
}

"""
input type for incrementing numeric columns in table "areas"
"""
input areas_inc_input {
  city_id: Int
  governorate_id: Int
  id: Int
  mc_id: Int
}

"""
input type for inserting data into table "areas"
"""
input areas_insert_input {
  city: cities_obj_rel_insert_input
  city_id: Int
  created_at: timestamp
  governorate: governorates_obj_rel_insert_input
  governorate_id: Int
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""aggregate max on columns"""
type areas_max_fields {
  city_id: Int
  created_at: timestamp
  governorate_id: Int
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""
order by max() on columns of table "areas"
"""
input areas_max_order_by {
  city_id: order_by
  created_at: order_by
  governorate_id: order_by
  id: order_by
  mc_id: order_by
  name_ar: order_by
  name_en: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type areas_min_fields {
  city_id: Int
  created_at: timestamp
  governorate_id: Int
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""
order by min() on columns of table "areas"
"""
input areas_min_order_by {
  city_id: order_by
  created_at: order_by
  governorate_id: order_by
  id: order_by
  mc_id: order_by
  name_ar: order_by
  name_en: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "areas"
"""
type areas_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [areas!]!
}

"""
input type for inserting object relation for remote table "areas"
"""
input areas_obj_rel_insert_input {
  data: areas_insert_input!

  """upsert condition"""
  on_conflict: areas_on_conflict
}

"""
on_conflict condition type for table "areas"
"""
input areas_on_conflict {
  constraint: areas_constraint!
  update_columns: [areas_update_column!]! = []
  where: areas_bool_exp
}

"""Ordering options when selecting data from "areas"."""
input areas_order_by {
  city: cities_order_by
  city_id: order_by
  created_at: order_by
  governorate: governorates_order_by
  governorate_id: order_by
  id: order_by
  mc_id: order_by
  name_ar: order_by
  name_en: order_by
  updated_at: order_by
}

"""primary key columns input for table: areas"""
input areas_pk_columns_input {
  id: Int!
}

"""
select columns of table "areas"
"""
enum areas_select_column {
  """column name"""
  city_id

  """column name"""
  created_at

  """column name"""
  governorate_id

  """column name"""
  id

  """column name"""
  mc_id

  """column name"""
  name_ar

  """column name"""
  name_en

  """column name"""
  updated_at
}

"""
input type for updating data in table "areas"
"""
input areas_set_input {
  city_id: Int
  created_at: timestamp
  governorate_id: Int
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""aggregate stddev on columns"""
type areas_stddev_fields {
  city_id: Float
  governorate_id: Float
  id: Float
  mc_id: Float
}

"""
order by stddev() on columns of table "areas"
"""
input areas_stddev_order_by {
  city_id: order_by
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""aggregate stddev_pop on columns"""
type areas_stddev_pop_fields {
  city_id: Float
  governorate_id: Float
  id: Float
  mc_id: Float
}

"""
order by stddev_pop() on columns of table "areas"
"""
input areas_stddev_pop_order_by {
  city_id: order_by
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""aggregate stddev_samp on columns"""
type areas_stddev_samp_fields {
  city_id: Float
  governorate_id: Float
  id: Float
  mc_id: Float
}

"""
order by stddev_samp() on columns of table "areas"
"""
input areas_stddev_samp_order_by {
  city_id: order_by
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""
Streaming cursor of the table "areas"
"""
input areas_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: areas_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input areas_stream_cursor_value_input {
  city_id: Int
  created_at: timestamp
  governorate_id: Int
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""aggregate sum on columns"""
type areas_sum_fields {
  city_id: Int
  governorate_id: Int
  id: Int
  mc_id: Int
}

"""
order by sum() on columns of table "areas"
"""
input areas_sum_order_by {
  city_id: order_by
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""
update columns of table "areas"
"""
enum areas_update_column {
  """column name"""
  city_id

  """column name"""
  created_at

  """column name"""
  governorate_id

  """column name"""
  id

  """column name"""
  mc_id

  """column name"""
  name_ar

  """column name"""
  name_en

  """column name"""
  updated_at
}

input areas_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: areas_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: areas_set_input

  """filter the rows which have to be updated"""
  where: areas_bool_exp!
}

"""aggregate var_pop on columns"""
type areas_var_pop_fields {
  city_id: Float
  governorate_id: Float
  id: Float
  mc_id: Float
}

"""
order by var_pop() on columns of table "areas"
"""
input areas_var_pop_order_by {
  city_id: order_by
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""aggregate var_samp on columns"""
type areas_var_samp_fields {
  city_id: Float
  governorate_id: Float
  id: Float
  mc_id: Float
}

"""
order by var_samp() on columns of table "areas"
"""
input areas_var_samp_order_by {
  city_id: order_by
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""aggregate variance on columns"""
type areas_variance_fields {
  city_id: Float
  governorate_id: Float
  id: Float
  mc_id: Float
}

"""
order by variance() on columns of table "areas"
"""
input areas_variance_order_by {
  city_id: order_by
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""
columns and relationships of "audit_logs"
"""
type audit_logs {
  action_time: timestamp
  actor_id: uuid
  actor_type: String
  after(
    """JSON select path"""
    path: String
  ): jsonb
  d: uuid!
  record_id: uuid
}

"""
aggregated selection of "audit_logs"
"""
type audit_logs_aggregate {
  aggregate: audit_logs_aggregate_fields
  nodes: [audit_logs!]!
}

"""
aggregate fields of "audit_logs"
"""
type audit_logs_aggregate_fields {
  count(columns: [audit_logs_select_column!], distinct: Boolean): Int!
  max: audit_logs_max_fields
  min: audit_logs_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input audit_logs_append_input {
  after: jsonb
}

"""
Boolean expression to filter rows from the table "audit_logs". All fields are combined with a logical 'AND'.
"""
input audit_logs_bool_exp {
  _and: [audit_logs_bool_exp!]
  _not: audit_logs_bool_exp
  _or: [audit_logs_bool_exp!]
  action_time: timestamp_comparison_exp
  actor_id: uuid_comparison_exp
  actor_type: String_comparison_exp
  after: jsonb_comparison_exp
  d: uuid_comparison_exp
  record_id: uuid_comparison_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input audit_logs_delete_at_path_input {
  after: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input audit_logs_delete_elem_input {
  after: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input audit_logs_delete_key_input {
  after: String
}

"""
input type for inserting data into table "audit_logs"
"""
input audit_logs_insert_input {
  action_time: timestamp
  actor_id: uuid
  actor_type: String
  after: jsonb
  d: uuid
  record_id: uuid
}

"""aggregate max on columns"""
type audit_logs_max_fields {
  action_time: timestamp
  actor_id: uuid
  actor_type: String
  d: uuid
  record_id: uuid
}

"""aggregate min on columns"""
type audit_logs_min_fields {
  action_time: timestamp
  actor_id: uuid
  actor_type: String
  d: uuid
  record_id: uuid
}

"""
response of any mutation on the table "audit_logs"
"""
type audit_logs_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [audit_logs!]!
}

"""Ordering options when selecting data from "audit_logs"."""
input audit_logs_order_by {
  action_time: order_by
  actor_id: order_by
  actor_type: order_by
  after: order_by
  d: order_by
  record_id: order_by
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input audit_logs_prepend_input {
  after: jsonb
}

"""
select columns of table "audit_logs"
"""
enum audit_logs_select_column {
  """column name"""
  action_time

  """column name"""
  actor_id

  """column name"""
  actor_type

  """column name"""
  after

  """column name"""
  d

  """column name"""
  record_id
}

"""
input type for updating data in table "audit_logs"
"""
input audit_logs_set_input {
  action_time: timestamp
  actor_id: uuid
  actor_type: String
  after: jsonb
  d: uuid
  record_id: uuid
}

"""
Streaming cursor of the table "audit_logs"
"""
input audit_logs_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: audit_logs_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input audit_logs_stream_cursor_value_input {
  action_time: timestamp
  actor_id: uuid
  actor_type: String
  after: jsonb
  d: uuid
  record_id: uuid
}

input audit_logs_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: audit_logs_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: audit_logs_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: audit_logs_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: audit_logs_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: audit_logs_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: audit_logs_set_input

  """filter the rows which have to be updated"""
  where: audit_logs_bool_exp!
}

scalar bankname

"""
Boolean expression to compare columns of type "bankname". All fields are combined with logical 'AND'.
"""
input bankname_comparison_exp {
  _eq: bankname
  _gt: bankname
  _gte: bankname
  _in: [bankname!]
  _is_null: Boolean
  _lt: bankname
  _lte: bankname
  _neq: bankname
  _nin: [bankname!]
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

scalar bytea

"""
Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'.
"""
input bytea_comparison_exp {
  _eq: bytea
  _gt: bytea
  _gte: bytea
  _in: [bytea!]
  _is_null: Boolean
  _lt: bytea
  _lte: bytea
  _neq: bytea
  _nin: [bytea!]
}

"""
columns and relationships of "checkout_baskets"
"""
type checkout_baskets {
  branch_id: uuid!

  """An object relationship"""
  cashier: partner_user_profile
  cashier_id: uuid!
  category: String
  commercial_offers(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  consumer: consumers
  consumer_device_metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  consumer_id: uuid!
  created_at: timestamp!
  gross_basket_value: Int!
  id: uuid!
  loan: loan
  loan_id: uuid

  """An object relationship"""
  partner: partner

  """An object relationship"""
  partner_branch: partner_branch
  partner_id: uuid!
  products(
    """JSON select path"""
    path: String
  ): jsonb!
  selected_commercial_offer_id: uuid

  """An object relationship"""
  session_basket: session_baskets
  session_basket_id: uuid!
  status: checkoutbasketstatus!
  updated_at: timestamp!
  workflow_id: uuid
}

"""
aggregated selection of "checkout_baskets"
"""
type checkout_baskets_aggregate {
  aggregate: checkout_baskets_aggregate_fields
  nodes: [checkout_baskets!]!
}

"""
aggregate fields of "checkout_baskets"
"""
type checkout_baskets_aggregate_fields {
  avg: checkout_baskets_avg_fields
  count(columns: [checkout_baskets_select_column!], distinct: Boolean): Int!
  max: checkout_baskets_max_fields
  min: checkout_baskets_min_fields
  stddev: checkout_baskets_stddev_fields
  stddev_pop: checkout_baskets_stddev_pop_fields
  stddev_samp: checkout_baskets_stddev_samp_fields
  sum: checkout_baskets_sum_fields
  var_pop: checkout_baskets_var_pop_fields
  var_samp: checkout_baskets_var_samp_fields
  variance: checkout_baskets_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input checkout_baskets_append_input {
  commercial_offers: jsonb
  consumer_device_metadata: jsonb
  products: jsonb
}

"""aggregate avg on columns"""
type checkout_baskets_avg_fields {
  gross_basket_value: Float
}

"""
Boolean expression to filter rows from the table "checkout_baskets". All fields are combined with a logical 'AND'.
"""
input checkout_baskets_bool_exp {
  _and: [checkout_baskets_bool_exp!]
  _not: checkout_baskets_bool_exp
  _or: [checkout_baskets_bool_exp!]
  branch_id: uuid_comparison_exp
  cashier: partner_user_profile_bool_exp
  cashier_id: uuid_comparison_exp
  category: String_comparison_exp
  commercial_offers: jsonb_comparison_exp
  consumer: consumers_bool_exp
  consumer_device_metadata: jsonb_comparison_exp
  consumer_id: uuid_comparison_exp
  created_at: timestamp_comparison_exp
  gross_basket_value: Int_comparison_exp
  id: uuid_comparison_exp
  loan_id: uuid_comparison_exp
  partner: partner_bool_exp
  partner_branch: partner_branch_bool_exp
  partner_id: uuid_comparison_exp
  products: jsonb_comparison_exp
  selected_commercial_offer_id: uuid_comparison_exp
  session_basket: session_baskets_bool_exp
  session_basket_id: uuid_comparison_exp
  status: checkoutbasketstatus_comparison_exp
  updated_at: timestamp_comparison_exp
  workflow_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "checkout_baskets"
"""
enum checkout_baskets_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  checkout_baskets_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input checkout_baskets_delete_at_path_input {
  commercial_offers: [String!]
  consumer_device_metadata: [String!]
  products: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input checkout_baskets_delete_elem_input {
  commercial_offers: Int
  consumer_device_metadata: Int
  products: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input checkout_baskets_delete_key_input {
  commercial_offers: String
  consumer_device_metadata: String
  products: String
}

"""
input type for incrementing numeric columns in table "checkout_baskets"
"""
input checkout_baskets_inc_input {
  gross_basket_value: Int
}

"""
input type for inserting data into table "checkout_baskets"
"""
input checkout_baskets_insert_input {
  branch_id: uuid
  cashier: partner_user_profile_obj_rel_insert_input
  cashier_id: uuid
  category: String
  commercial_offers: jsonb
  consumer: consumers_obj_rel_insert_input
  consumer_device_metadata: jsonb
  consumer_id: uuid
  created_at: timestamp
  gross_basket_value: Int
  id: uuid
  loan_id: uuid
  partner: partner_obj_rel_insert_input
  partner_branch: partner_branch_obj_rel_insert_input
  partner_id: uuid
  products: jsonb
  selected_commercial_offer_id: uuid
  session_basket: session_baskets_obj_rel_insert_input
  session_basket_id: uuid
  status: checkoutbasketstatus
  updated_at: timestamp
  workflow_id: uuid
}

"""aggregate max on columns"""
type checkout_baskets_max_fields {
  branch_id: uuid
  cashier_id: uuid
  category: String
  consumer_id: uuid
  created_at: timestamp
  gross_basket_value: Int
  id: uuid
  loan_id: uuid
  partner_id: uuid
  selected_commercial_offer_id: uuid
  session_basket_id: uuid
  status: checkoutbasketstatus
  updated_at: timestamp
  workflow_id: uuid
}

"""aggregate min on columns"""
type checkout_baskets_min_fields {
  branch_id: uuid
  cashier_id: uuid
  category: String
  consumer_id: uuid
  created_at: timestamp
  gross_basket_value: Int
  id: uuid
  loan_id: uuid
  partner_id: uuid
  selected_commercial_offer_id: uuid
  session_basket_id: uuid
  status: checkoutbasketstatus
  updated_at: timestamp
  workflow_id: uuid
}

"""
response of any mutation on the table "checkout_baskets"
"""
type checkout_baskets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [checkout_baskets!]!
}

"""
input type for inserting object relation for remote table "checkout_baskets"
"""
input checkout_baskets_obj_rel_insert_input {
  data: checkout_baskets_insert_input!

  """upsert condition"""
  on_conflict: checkout_baskets_on_conflict
}

"""
on_conflict condition type for table "checkout_baskets"
"""
input checkout_baskets_on_conflict {
  constraint: checkout_baskets_constraint!
  update_columns: [checkout_baskets_update_column!]! = []
  where: checkout_baskets_bool_exp
}

"""Ordering options when selecting data from "checkout_baskets"."""
input checkout_baskets_order_by {
  branch_id: order_by
  cashier: partner_user_profile_order_by
  cashier_id: order_by
  category: order_by
  commercial_offers: order_by
  consumer: consumers_order_by
  consumer_device_metadata: order_by
  consumer_id: order_by
  created_at: order_by
  gross_basket_value: order_by
  id: order_by
  loan_id: order_by
  partner: partner_order_by
  partner_branch: partner_branch_order_by
  partner_id: order_by
  products: order_by
  selected_commercial_offer_id: order_by
  session_basket: session_baskets_order_by
  session_basket_id: order_by
  status: order_by
  updated_at: order_by
  workflow_id: order_by
}

"""primary key columns input for table: checkout_baskets"""
input checkout_baskets_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input checkout_baskets_prepend_input {
  commercial_offers: jsonb
  consumer_device_metadata: jsonb
  products: jsonb
}

"""
select columns of table "checkout_baskets"
"""
enum checkout_baskets_select_column {
  """column name"""
  branch_id

  """column name"""
  cashier_id

  """column name"""
  category

  """column name"""
  commercial_offers

  """column name"""
  consumer_device_metadata

  """column name"""
  consumer_id

  """column name"""
  created_at

  """column name"""
  gross_basket_value

  """column name"""
  id

  """column name"""
  loan_id

  """column name"""
  partner_id

  """column name"""
  products

  """column name"""
  selected_commercial_offer_id

  """column name"""
  session_basket_id

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  workflow_id
}

"""
input type for updating data in table "checkout_baskets"
"""
input checkout_baskets_set_input {
  branch_id: uuid
  cashier_id: uuid
  category: String
  commercial_offers: jsonb
  consumer_device_metadata: jsonb
  consumer_id: uuid
  created_at: timestamp
  gross_basket_value: Int
  id: uuid
  loan_id: uuid
  partner_id: uuid
  products: jsonb
  selected_commercial_offer_id: uuid
  session_basket_id: uuid
  status: checkoutbasketstatus
  updated_at: timestamp
  workflow_id: uuid
}

"""aggregate stddev on columns"""
type checkout_baskets_stddev_fields {
  gross_basket_value: Float
}

"""aggregate stddev_pop on columns"""
type checkout_baskets_stddev_pop_fields {
  gross_basket_value: Float
}

"""aggregate stddev_samp on columns"""
type checkout_baskets_stddev_samp_fields {
  gross_basket_value: Float
}

"""
Streaming cursor of the table "checkout_baskets"
"""
input checkout_baskets_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: checkout_baskets_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input checkout_baskets_stream_cursor_value_input {
  branch_id: uuid
  cashier_id: uuid
  category: String
  commercial_offers: jsonb
  consumer_device_metadata: jsonb
  consumer_id: uuid
  created_at: timestamp
  gross_basket_value: Int
  id: uuid
  loan_id: uuid
  partner_id: uuid
  products: jsonb
  selected_commercial_offer_id: uuid
  session_basket_id: uuid
  status: checkoutbasketstatus
  updated_at: timestamp
  workflow_id: uuid
}

"""aggregate sum on columns"""
type checkout_baskets_sum_fields {
  gross_basket_value: Int
}

"""
update columns of table "checkout_baskets"
"""
enum checkout_baskets_update_column {
  """column name"""
  branch_id

  """column name"""
  cashier_id

  """column name"""
  category

  """column name"""
  commercial_offers

  """column name"""
  consumer_device_metadata

  """column name"""
  consumer_id

  """column name"""
  created_at

  """column name"""
  gross_basket_value

  """column name"""
  id

  """column name"""
  loan_id

  """column name"""
  partner_id

  """column name"""
  products

  """column name"""
  selected_commercial_offer_id

  """column name"""
  session_basket_id

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  workflow_id
}

input checkout_baskets_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: checkout_baskets_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: checkout_baskets_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: checkout_baskets_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: checkout_baskets_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: checkout_baskets_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: checkout_baskets_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: checkout_baskets_set_input

  """filter the rows which have to be updated"""
  where: checkout_baskets_bool_exp!
}

"""aggregate var_pop on columns"""
type checkout_baskets_var_pop_fields {
  gross_basket_value: Float
}

"""aggregate var_samp on columns"""
type checkout_baskets_var_samp_fields {
  gross_basket_value: Float
}

"""aggregate variance on columns"""
type checkout_baskets_variance_fields {
  gross_basket_value: Float
}

scalar checkoutbasketstatus

"""
Boolean expression to compare columns of type "checkoutbasketstatus". All fields are combined with logical 'AND'.
"""
input checkoutbasketstatus_comparison_exp {
  _eq: checkoutbasketstatus
  _gt: checkoutbasketstatus
  _gte: checkoutbasketstatus
  _in: [checkoutbasketstatus!]
  _is_null: Boolean
  _lt: checkoutbasketstatus
  _lte: checkoutbasketstatus
  _neq: checkoutbasketstatus
  _nin: [checkoutbasketstatus!]
}

"""
columns and relationships of "cities"
"""
type cities {
  """An array relationship"""
  areas(
    """distinct select on columns"""
    distinct_on: [areas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [areas_order_by!]

    """filter the rows returned"""
    where: areas_bool_exp
  ): [areas!]!

  """An aggregate relationship"""
  areas_aggregate(
    """distinct select on columns"""
    distinct_on: [areas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [areas_order_by!]

    """filter the rows returned"""
    where: areas_bool_exp
  ): areas_aggregate!
  created_at: timestamp!

  """An object relationship"""
  governorate: governorates!
  governorate_id: Int!
  id: Int!
  mc_id: Int!
  name_ar: String!
  name_en: String!
  updated_at: timestamp!
}

"""
aggregated selection of "cities"
"""
type cities_aggregate {
  aggregate: cities_aggregate_fields
  nodes: [cities!]!
}

input cities_aggregate_bool_exp {
  count: cities_aggregate_bool_exp_count
}

input cities_aggregate_bool_exp_count {
  arguments: [cities_select_column!]
  distinct: Boolean
  filter: cities_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "cities"
"""
type cities_aggregate_fields {
  avg: cities_avg_fields
  count(columns: [cities_select_column!], distinct: Boolean): Int!
  max: cities_max_fields
  min: cities_min_fields
  stddev: cities_stddev_fields
  stddev_pop: cities_stddev_pop_fields
  stddev_samp: cities_stddev_samp_fields
  sum: cities_sum_fields
  var_pop: cities_var_pop_fields
  var_samp: cities_var_samp_fields
  variance: cities_variance_fields
}

"""
order by aggregate values of table "cities"
"""
input cities_aggregate_order_by {
  avg: cities_avg_order_by
  count: order_by
  max: cities_max_order_by
  min: cities_min_order_by
  stddev: cities_stddev_order_by
  stddev_pop: cities_stddev_pop_order_by
  stddev_samp: cities_stddev_samp_order_by
  sum: cities_sum_order_by
  var_pop: cities_var_pop_order_by
  var_samp: cities_var_samp_order_by
  variance: cities_variance_order_by
}

"""
input type for inserting array relation for remote table "cities"
"""
input cities_arr_rel_insert_input {
  data: [cities_insert_input!]!

  """upsert condition"""
  on_conflict: cities_on_conflict
}

"""aggregate avg on columns"""
type cities_avg_fields {
  governorate_id: Float
  id: Float
  mc_id: Float
}

"""
order by avg() on columns of table "cities"
"""
input cities_avg_order_by {
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""
Boolean expression to filter rows from the table "cities". All fields are combined with a logical 'AND'.
"""
input cities_bool_exp {
  _and: [cities_bool_exp!]
  _not: cities_bool_exp
  _or: [cities_bool_exp!]
  areas: areas_bool_exp
  areas_aggregate: areas_aggregate_bool_exp
  created_at: timestamp_comparison_exp
  governorate: governorates_bool_exp
  governorate_id: Int_comparison_exp
  id: Int_comparison_exp
  mc_id: Int_comparison_exp
  name_ar: String_comparison_exp
  name_en: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "cities"
"""
enum cities_constraint {
  """
  unique or primary key constraint on columns "mc_id"
  """
  cities_mc_id_key

  """
  unique or primary key constraint on columns "id"
  """
  cities_pkey
}

"""
input type for incrementing numeric columns in table "cities"
"""
input cities_inc_input {
  governorate_id: Int
  id: Int
  mc_id: Int
}

"""
input type for inserting data into table "cities"
"""
input cities_insert_input {
  areas: areas_arr_rel_insert_input
  created_at: timestamp
  governorate: governorates_obj_rel_insert_input
  governorate_id: Int
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""aggregate max on columns"""
type cities_max_fields {
  created_at: timestamp
  governorate_id: Int
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""
order by max() on columns of table "cities"
"""
input cities_max_order_by {
  created_at: order_by
  governorate_id: order_by
  id: order_by
  mc_id: order_by
  name_ar: order_by
  name_en: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type cities_min_fields {
  created_at: timestamp
  governorate_id: Int
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""
order by min() on columns of table "cities"
"""
input cities_min_order_by {
  created_at: order_by
  governorate_id: order_by
  id: order_by
  mc_id: order_by
  name_ar: order_by
  name_en: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "cities"
"""
type cities_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [cities!]!
}

"""
input type for inserting object relation for remote table "cities"
"""
input cities_obj_rel_insert_input {
  data: cities_insert_input!

  """upsert condition"""
  on_conflict: cities_on_conflict
}

"""
on_conflict condition type for table "cities"
"""
input cities_on_conflict {
  constraint: cities_constraint!
  update_columns: [cities_update_column!]! = []
  where: cities_bool_exp
}

"""Ordering options when selecting data from "cities"."""
input cities_order_by {
  areas_aggregate: areas_aggregate_order_by
  created_at: order_by
  governorate: governorates_order_by
  governorate_id: order_by
  id: order_by
  mc_id: order_by
  name_ar: order_by
  name_en: order_by
  updated_at: order_by
}

"""primary key columns input for table: cities"""
input cities_pk_columns_input {
  id: Int!
}

"""
select columns of table "cities"
"""
enum cities_select_column {
  """column name"""
  created_at

  """column name"""
  governorate_id

  """column name"""
  id

  """column name"""
  mc_id

  """column name"""
  name_ar

  """column name"""
  name_en

  """column name"""
  updated_at
}

"""
input type for updating data in table "cities"
"""
input cities_set_input {
  created_at: timestamp
  governorate_id: Int
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""aggregate stddev on columns"""
type cities_stddev_fields {
  governorate_id: Float
  id: Float
  mc_id: Float
}

"""
order by stddev() on columns of table "cities"
"""
input cities_stddev_order_by {
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""aggregate stddev_pop on columns"""
type cities_stddev_pop_fields {
  governorate_id: Float
  id: Float
  mc_id: Float
}

"""
order by stddev_pop() on columns of table "cities"
"""
input cities_stddev_pop_order_by {
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""aggregate stddev_samp on columns"""
type cities_stddev_samp_fields {
  governorate_id: Float
  id: Float
  mc_id: Float
}

"""
order by stddev_samp() on columns of table "cities"
"""
input cities_stddev_samp_order_by {
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""
Streaming cursor of the table "cities"
"""
input cities_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: cities_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input cities_stream_cursor_value_input {
  created_at: timestamp
  governorate_id: Int
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""aggregate sum on columns"""
type cities_sum_fields {
  governorate_id: Int
  id: Int
  mc_id: Int
}

"""
order by sum() on columns of table "cities"
"""
input cities_sum_order_by {
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""
update columns of table "cities"
"""
enum cities_update_column {
  """column name"""
  created_at

  """column name"""
  governorate_id

  """column name"""
  id

  """column name"""
  mc_id

  """column name"""
  name_ar

  """column name"""
  name_en

  """column name"""
  updated_at
}

input cities_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: cities_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: cities_set_input

  """filter the rows which have to be updated"""
  where: cities_bool_exp!
}

"""aggregate var_pop on columns"""
type cities_var_pop_fields {
  governorate_id: Float
  id: Float
  mc_id: Float
}

"""
order by var_pop() on columns of table "cities"
"""
input cities_var_pop_order_by {
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""aggregate var_samp on columns"""
type cities_var_samp_fields {
  governorate_id: Float
  id: Float
  mc_id: Float
}

"""
order by var_samp() on columns of table "cities"
"""
input cities_var_samp_order_by {
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""aggregate variance on columns"""
type cities_variance_fields {
  governorate_id: Float
  id: Float
  mc_id: Float
}

"""
order by variance() on columns of table "cities"
"""
input cities_variance_order_by {
  governorate_id: order_by
  id: order_by
  mc_id: order_by
}

"""
columns and relationships of "command"
"""
type command {
  command_type: String!
  consumer_id: String!
  correlation_id: String!
  created_at: timestamptz!

  """An array relationship"""
  entries(
    """distinct select on columns"""
    distinct_on: [entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entry_order_by!]

    """filter the rows returned"""
    where: entry_bool_exp
  ): [entry!]!

  """An aggregate relationship"""
  entries_aggregate(
    """distinct select on columns"""
    distinct_on: [entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entry_order_by!]

    """filter the rows returned"""
    where: entry_bool_exp
  ): entry_aggregate!
  id: Int!
}

"""
aggregated selection of "command"
"""
type command_aggregate {
  aggregate: command_aggregate_fields
  nodes: [command!]!
}

"""
aggregate fields of "command"
"""
type command_aggregate_fields {
  avg: command_avg_fields
  count(columns: [command_select_column!], distinct: Boolean): Int!
  max: command_max_fields
  min: command_min_fields
  stddev: command_stddev_fields
  stddev_pop: command_stddev_pop_fields
  stddev_samp: command_stddev_samp_fields
  sum: command_sum_fields
  var_pop: command_var_pop_fields
  var_samp: command_var_samp_fields
  variance: command_variance_fields
}

"""aggregate avg on columns"""
type command_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "command". All fields are combined with a logical 'AND'.
"""
input command_bool_exp {
  _and: [command_bool_exp!]
  _not: command_bool_exp
  _or: [command_bool_exp!]
  command_type: String_comparison_exp
  consumer_id: String_comparison_exp
  correlation_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  entries: entry_bool_exp
  entries_aggregate: entry_aggregate_bool_exp
  id: Int_comparison_exp
}

"""
unique or primary key constraints on table "command"
"""
enum command_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  command_pkey
}

"""
input type for incrementing numeric columns in table "command"
"""
input command_inc_input {
  id: Int
}

"""
input type for inserting data into table "command"
"""
input command_insert_input {
  command_type: String
  consumer_id: String
  correlation_id: String
  created_at: timestamptz
  entries: entry_arr_rel_insert_input
  id: Int
}

"""aggregate max on columns"""
type command_max_fields {
  command_type: String
  consumer_id: String
  correlation_id: String
  created_at: timestamptz
  id: Int
}

"""aggregate min on columns"""
type command_min_fields {
  command_type: String
  consumer_id: String
  correlation_id: String
  created_at: timestamptz
  id: Int
}

"""
response of any mutation on the table "command"
"""
type command_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [command!]!
}

"""
input type for inserting object relation for remote table "command"
"""
input command_obj_rel_insert_input {
  data: command_insert_input!

  """upsert condition"""
  on_conflict: command_on_conflict
}

"""
on_conflict condition type for table "command"
"""
input command_on_conflict {
  constraint: command_constraint!
  update_columns: [command_update_column!]! = []
  where: command_bool_exp
}

"""Ordering options when selecting data from "command"."""
input command_order_by {
  command_type: order_by
  consumer_id: order_by
  correlation_id: order_by
  created_at: order_by
  entries_aggregate: entry_aggregate_order_by
  id: order_by
}

"""primary key columns input for table: command"""
input command_pk_columns_input {
  id: Int!
}

"""
select columns of table "command"
"""
enum command_select_column {
  """column name"""
  command_type

  """column name"""
  consumer_id

  """column name"""
  correlation_id

  """column name"""
  created_at

  """column name"""
  id
}

"""
input type for updating data in table "command"
"""
input command_set_input {
  command_type: String
  consumer_id: String
  correlation_id: String
  created_at: timestamptz
  id: Int
}

"""aggregate stddev on columns"""
type command_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type command_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type command_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "command"
"""
input command_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: command_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input command_stream_cursor_value_input {
  command_type: String
  consumer_id: String
  correlation_id: String
  created_at: timestamptz
  id: Int
}

"""aggregate sum on columns"""
type command_sum_fields {
  id: Int
}

"""
update columns of table "command"
"""
enum command_update_column {
  """column name"""
  command_type

  """column name"""
  consumer_id

  """column name"""
  correlation_id

  """column name"""
  created_at

  """column name"""
  id
}

input command_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: command_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: command_set_input

  """filter the rows which have to be updated"""
  where: command_bool_exp!
}

"""aggregate var_pop on columns"""
type command_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type command_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type command_variance_fields {
  id: Float
}

"""
columns and relationships of "commercial_offer"
"""
type commercial_offer {
  admin_fee: bigint!
  annual_interest_percentage: String!
  basket_id: String!
  consumer_accepted_at: timestamptz
  consumer_id: String!
  down_payment: bigint!
  financed_amount: bigint!
  financial_product_key: String!
  financial_product_version: String!
  id: String!
  interest_rate_per_tenure: String!
  merchant_acccepted_at: timestamptz
  monthly_instalment: bigint!
  tenure: String!
  total_amount: bigint!
}

"""
aggregated selection of "commercial_offer"
"""
type commercial_offer_aggregate {
  aggregate: commercial_offer_aggregate_fields
  nodes: [commercial_offer!]!
}

"""
aggregate fields of "commercial_offer"
"""
type commercial_offer_aggregate_fields {
  avg: commercial_offer_avg_fields
  count(columns: [commercial_offer_select_column!], distinct: Boolean): Int!
  max: commercial_offer_max_fields
  min: commercial_offer_min_fields
  stddev: commercial_offer_stddev_fields
  stddev_pop: commercial_offer_stddev_pop_fields
  stddev_samp: commercial_offer_stddev_samp_fields
  sum: commercial_offer_sum_fields
  var_pop: commercial_offer_var_pop_fields
  var_samp: commercial_offer_var_samp_fields
  variance: commercial_offer_variance_fields
}

"""aggregate avg on columns"""
type commercial_offer_avg_fields {
  admin_fee: Float
  down_payment: Float
  financed_amount: Float
  monthly_instalment: Float
  total_amount: Float
}

"""
Boolean expression to filter rows from the table "commercial_offer". All fields are combined with a logical 'AND'.
"""
input commercial_offer_bool_exp {
  _and: [commercial_offer_bool_exp!]
  _not: commercial_offer_bool_exp
  _or: [commercial_offer_bool_exp!]
  admin_fee: bigint_comparison_exp
  annual_interest_percentage: String_comparison_exp
  basket_id: String_comparison_exp
  consumer_accepted_at: timestamptz_comparison_exp
  consumer_id: String_comparison_exp
  down_payment: bigint_comparison_exp
  financed_amount: bigint_comparison_exp
  financial_product_key: String_comparison_exp
  financial_product_version: String_comparison_exp
  id: String_comparison_exp
  interest_rate_per_tenure: String_comparison_exp
  merchant_acccepted_at: timestamptz_comparison_exp
  monthly_instalment: bigint_comparison_exp
  tenure: String_comparison_exp
  total_amount: bigint_comparison_exp
}

"""
unique or primary key constraints on table "commercial_offer"
"""
enum commercial_offer_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  commercial_offer_pkey
}

"""
input type for incrementing numeric columns in table "commercial_offer"
"""
input commercial_offer_inc_input {
  admin_fee: bigint
  down_payment: bigint
  financed_amount: bigint
  monthly_instalment: bigint
  total_amount: bigint
}

"""
input type for inserting data into table "commercial_offer"
"""
input commercial_offer_insert_input {
  admin_fee: bigint
  annual_interest_percentage: String
  basket_id: String
  consumer_accepted_at: timestamptz
  consumer_id: String
  down_payment: bigint
  financed_amount: bigint
  financial_product_key: String
  financial_product_version: String
  id: String
  interest_rate_per_tenure: String
  merchant_acccepted_at: timestamptz
  monthly_instalment: bigint
  tenure: String
  total_amount: bigint
}

"""aggregate max on columns"""
type commercial_offer_max_fields {
  admin_fee: bigint
  annual_interest_percentage: String
  basket_id: String
  consumer_accepted_at: timestamptz
  consumer_id: String
  down_payment: bigint
  financed_amount: bigint
  financial_product_key: String
  financial_product_version: String
  id: String
  interest_rate_per_tenure: String
  merchant_acccepted_at: timestamptz
  monthly_instalment: bigint
  tenure: String
  total_amount: bigint
}

"""aggregate min on columns"""
type commercial_offer_min_fields {
  admin_fee: bigint
  annual_interest_percentage: String
  basket_id: String
  consumer_accepted_at: timestamptz
  consumer_id: String
  down_payment: bigint
  financed_amount: bigint
  financial_product_key: String
  financial_product_version: String
  id: String
  interest_rate_per_tenure: String
  merchant_acccepted_at: timestamptz
  monthly_instalment: bigint
  tenure: String
  total_amount: bigint
}

"""
response of any mutation on the table "commercial_offer"
"""
type commercial_offer_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [commercial_offer!]!
}

"""
on_conflict condition type for table "commercial_offer"
"""
input commercial_offer_on_conflict {
  constraint: commercial_offer_constraint!
  update_columns: [commercial_offer_update_column!]! = []
  where: commercial_offer_bool_exp
}

"""Ordering options when selecting data from "commercial_offer"."""
input commercial_offer_order_by {
  admin_fee: order_by
  annual_interest_percentage: order_by
  basket_id: order_by
  consumer_accepted_at: order_by
  consumer_id: order_by
  down_payment: order_by
  financed_amount: order_by
  financial_product_key: order_by
  financial_product_version: order_by
  id: order_by
  interest_rate_per_tenure: order_by
  merchant_acccepted_at: order_by
  monthly_instalment: order_by
  tenure: order_by
  total_amount: order_by
}

"""primary key columns input for table: commercial_offer"""
input commercial_offer_pk_columns_input {
  id: String!
}

"""
select columns of table "commercial_offer"
"""
enum commercial_offer_select_column {
  """column name"""
  admin_fee

  """column name"""
  annual_interest_percentage

  """column name"""
  basket_id

  """column name"""
  consumer_accepted_at

  """column name"""
  consumer_id

  """column name"""
  down_payment

  """column name"""
  financed_amount

  """column name"""
  financial_product_key

  """column name"""
  financial_product_version

  """column name"""
  id

  """column name"""
  interest_rate_per_tenure

  """column name"""
  merchant_acccepted_at

  """column name"""
  monthly_instalment

  """column name"""
  tenure

  """column name"""
  total_amount
}

"""
input type for updating data in table "commercial_offer"
"""
input commercial_offer_set_input {
  admin_fee: bigint
  annual_interest_percentage: String
  basket_id: String
  consumer_accepted_at: timestamptz
  consumer_id: String
  down_payment: bigint
  financed_amount: bigint
  financial_product_key: String
  financial_product_version: String
  id: String
  interest_rate_per_tenure: String
  merchant_acccepted_at: timestamptz
  monthly_instalment: bigint
  tenure: String
  total_amount: bigint
}

"""aggregate stddev on columns"""
type commercial_offer_stddev_fields {
  admin_fee: Float
  down_payment: Float
  financed_amount: Float
  monthly_instalment: Float
  total_amount: Float
}

"""aggregate stddev_pop on columns"""
type commercial_offer_stddev_pop_fields {
  admin_fee: Float
  down_payment: Float
  financed_amount: Float
  monthly_instalment: Float
  total_amount: Float
}

"""aggregate stddev_samp on columns"""
type commercial_offer_stddev_samp_fields {
  admin_fee: Float
  down_payment: Float
  financed_amount: Float
  monthly_instalment: Float
  total_amount: Float
}

"""
Streaming cursor of the table "commercial_offer"
"""
input commercial_offer_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: commercial_offer_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input commercial_offer_stream_cursor_value_input {
  admin_fee: bigint
  annual_interest_percentage: String
  basket_id: String
  consumer_accepted_at: timestamptz
  consumer_id: String
  down_payment: bigint
  financed_amount: bigint
  financial_product_key: String
  financial_product_version: String
  id: String
  interest_rate_per_tenure: String
  merchant_acccepted_at: timestamptz
  monthly_instalment: bigint
  tenure: String
  total_amount: bigint
}

"""aggregate sum on columns"""
type commercial_offer_sum_fields {
  admin_fee: bigint
  down_payment: bigint
  financed_amount: bigint
  monthly_instalment: bigint
  total_amount: bigint
}

"""
update columns of table "commercial_offer"
"""
enum commercial_offer_update_column {
  """column name"""
  admin_fee

  """column name"""
  annual_interest_percentage

  """column name"""
  basket_id

  """column name"""
  consumer_accepted_at

  """column name"""
  consumer_id

  """column name"""
  down_payment

  """column name"""
  financed_amount

  """column name"""
  financial_product_key

  """column name"""
  financial_product_version

  """column name"""
  id

  """column name"""
  interest_rate_per_tenure

  """column name"""
  merchant_acccepted_at

  """column name"""
  monthly_instalment

  """column name"""
  tenure

  """column name"""
  total_amount
}

input commercial_offer_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: commercial_offer_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: commercial_offer_set_input

  """filter the rows which have to be updated"""
  where: commercial_offer_bool_exp!
}

"""aggregate var_pop on columns"""
type commercial_offer_var_pop_fields {
  admin_fee: Float
  down_payment: Float
  financed_amount: Float
  monthly_instalment: Float
  total_amount: Float
}

"""aggregate var_samp on columns"""
type commercial_offer_var_samp_fields {
  admin_fee: Float
  down_payment: Float
  financed_amount: Float
  monthly_instalment: Float
  total_amount: Float
}

"""aggregate variance on columns"""
type commercial_offer_variance_fields {
  admin_fee: Float
  down_payment: Float
  financed_amount: Float
  monthly_instalment: Float
  total_amount: Float
}

scalar connector_provider

"""
Boolean expression to compare columns of type "connector_provider". All fields are combined with logical 'AND'.
"""
input connector_provider_comparison_exp {
  _eq: connector_provider
  _gt: connector_provider
  _gte: connector_provider
  _in: [connector_provider!]
  _is_null: Boolean
  _lt: connector_provider
  _lte: connector_provider
  _neq: connector_provider
  _nin: [connector_provider!]
}

"""
columns and relationships of "connectors.connector"
"""
type connectors_connector {
  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [accounts_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_account_order_by!]

    """filter the rows returned"""
    where: accounts_account_bool_exp
  ): [accounts_account!]!

  """An aggregate relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_account_order_by!]

    """filter the rows returned"""
    where: accounts_account_bool_exp
  ): accounts_account_aggregate!

  """An array relationship"""
  bank_account_related_accounts(
    """distinct select on columns"""
    distinct_on: [accounts_bank_account_related_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_bank_account_related_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bank_account_related_accounts_bool_exp
  ): [accounts_bank_account_related_accounts!]!

  """An aggregate relationship"""
  bank_account_related_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_bank_account_related_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_bank_account_related_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bank_account_related_accounts_bool_exp
  ): accounts_bank_account_related_accounts_aggregate!
  config: bytea
  created_at: timestamptz!
  id: String!
  name: String!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payments_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_payment_order_by!]

    """filter the rows returned"""
    where: payments_payment_bool_exp
  ): [payments_payment!]!

  """An aggregate relationship"""
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_payment_order_by!]

    """filter the rows returned"""
    where: payments_payment_bool_exp
  ): payments_payment_aggregate!
  provider: connector_provider!

  """An array relationship"""
  transfer_initiations(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_bool_exp
  ): [transfers_transfer_initiation!]!

  """An aggregate relationship"""
  transfer_initiations_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_bool_exp
  ): transfers_transfer_initiation_aggregate!

  """An array relationship"""
  transfer_reversals(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_reversal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_reversal_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_reversal_bool_exp
  ): [transfers_transfer_reversal!]!

  """An aggregate relationship"""
  transfer_reversals_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_reversal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_reversal_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_reversal_bool_exp
  ): transfers_transfer_reversal_aggregate!

  """An array relationship"""
  webhooks(
    """distinct select on columns"""
    distinct_on: [connectors_webhook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connectors_webhook_order_by!]

    """filter the rows returned"""
    where: connectors_webhook_bool_exp
  ): [connectors_webhook!]!

  """An aggregate relationship"""
  webhooks_aggregate(
    """distinct select on columns"""
    distinct_on: [connectors_webhook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connectors_webhook_order_by!]

    """filter the rows returned"""
    where: connectors_webhook_bool_exp
  ): connectors_webhook_aggregate!
}

"""
aggregated selection of "connectors.connector"
"""
type connectors_connector_aggregate {
  aggregate: connectors_connector_aggregate_fields
  nodes: [connectors_connector!]!
}

"""
aggregate fields of "connectors.connector"
"""
type connectors_connector_aggregate_fields {
  count(columns: [connectors_connector_select_column!], distinct: Boolean): Int!
  max: connectors_connector_max_fields
  min: connectors_connector_min_fields
}

"""
Boolean expression to filter rows from the table "connectors.connector". All fields are combined with a logical 'AND'.
"""
input connectors_connector_bool_exp {
  _and: [connectors_connector_bool_exp!]
  _not: connectors_connector_bool_exp
  _or: [connectors_connector_bool_exp!]
  accounts: accounts_account_bool_exp
  accounts_aggregate: accounts_account_aggregate_bool_exp
  bank_account_related_accounts: accounts_bank_account_related_accounts_bool_exp
  bank_account_related_accounts_aggregate: accounts_bank_account_related_accounts_aggregate_bool_exp
  config: bytea_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  payments: payments_payment_bool_exp
  payments_aggregate: payments_payment_aggregate_bool_exp
  provider: connector_provider_comparison_exp
  transfer_initiations: transfers_transfer_initiation_bool_exp
  transfer_initiations_aggregate: transfers_transfer_initiation_aggregate_bool_exp
  transfer_reversals: transfers_transfer_reversal_bool_exp
  transfer_reversals_aggregate: transfers_transfer_reversal_aggregate_bool_exp
  webhooks: connectors_webhook_bool_exp
  webhooks_aggregate: connectors_webhook_aggregate_bool_exp
}

"""
unique or primary key constraints on table "connectors.connector"
"""
enum connectors_connector_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  connector_v2_name_key

  """
  unique or primary key constraint on columns "id"
  """
  connector_v2_pk
}

"""
input type for inserting data into table "connectors.connector"
"""
input connectors_connector_insert_input {
  accounts: accounts_account_arr_rel_insert_input
  bank_account_related_accounts: accounts_bank_account_related_accounts_arr_rel_insert_input
  config: bytea
  created_at: timestamptz
  id: String
  name: String
  payments: payments_payment_arr_rel_insert_input
  provider: connector_provider
  transfer_initiations: transfers_transfer_initiation_arr_rel_insert_input
  transfer_reversals: transfers_transfer_reversal_arr_rel_insert_input
  webhooks: connectors_webhook_arr_rel_insert_input
}

"""aggregate max on columns"""
type connectors_connector_max_fields {
  created_at: timestamptz
  id: String
  name: String
  provider: connector_provider
}

"""aggregate min on columns"""
type connectors_connector_min_fields {
  created_at: timestamptz
  id: String
  name: String
  provider: connector_provider
}

"""
response of any mutation on the table "connectors.connector"
"""
type connectors_connector_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [connectors_connector!]!
}

"""
input type for inserting object relation for remote table "connectors.connector"
"""
input connectors_connector_obj_rel_insert_input {
  data: connectors_connector_insert_input!

  """upsert condition"""
  on_conflict: connectors_connector_on_conflict
}

"""
on_conflict condition type for table "connectors.connector"
"""
input connectors_connector_on_conflict {
  constraint: connectors_connector_constraint!
  update_columns: [connectors_connector_update_column!]! = []
  where: connectors_connector_bool_exp
}

"""Ordering options when selecting data from "connectors.connector"."""
input connectors_connector_order_by {
  accounts_aggregate: accounts_account_aggregate_order_by
  bank_account_related_accounts_aggregate: accounts_bank_account_related_accounts_aggregate_order_by
  config: order_by
  created_at: order_by
  id: order_by
  name: order_by
  payments_aggregate: payments_payment_aggregate_order_by
  provider: order_by
  transfer_initiations_aggregate: transfers_transfer_initiation_aggregate_order_by
  transfer_reversals_aggregate: transfers_transfer_reversal_aggregate_order_by
  webhooks_aggregate: connectors_webhook_aggregate_order_by
}

"""primary key columns input for table: connectors.connector"""
input connectors_connector_pk_columns_input {
  id: String!
}

"""
select columns of table "connectors.connector"
"""
enum connectors_connector_select_column {
  """column name"""
  config

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  provider
}

"""
input type for updating data in table "connectors.connector"
"""
input connectors_connector_set_input {
  config: bytea
  created_at: timestamptz
  id: String
  name: String
  provider: connector_provider
}

"""
Streaming cursor of the table "connectors_connector"
"""
input connectors_connector_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: connectors_connector_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input connectors_connector_stream_cursor_value_input {
  config: bytea
  created_at: timestamptz
  id: String
  name: String
  provider: connector_provider
}

"""
update columns of table "connectors.connector"
"""
enum connectors_connector_update_column {
  """column name"""
  config

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  provider
}

input connectors_connector_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: connectors_connector_set_input

  """filter the rows which have to be updated"""
  where: connectors_connector_bool_exp!
}

"""
columns and relationships of "connectors.webhook"
"""
type connectors_webhook {
  """An object relationship"""
  connector: connectors_connector!
  connector_id: String!
  id: uuid!
  request_body: bytea!
}

"""
aggregated selection of "connectors.webhook"
"""
type connectors_webhook_aggregate {
  aggregate: connectors_webhook_aggregate_fields
  nodes: [connectors_webhook!]!
}

input connectors_webhook_aggregate_bool_exp {
  count: connectors_webhook_aggregate_bool_exp_count
}

input connectors_webhook_aggregate_bool_exp_count {
  arguments: [connectors_webhook_select_column!]
  distinct: Boolean
  filter: connectors_webhook_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "connectors.webhook"
"""
type connectors_webhook_aggregate_fields {
  count(columns: [connectors_webhook_select_column!], distinct: Boolean): Int!
  max: connectors_webhook_max_fields
  min: connectors_webhook_min_fields
}

"""
order by aggregate values of table "connectors.webhook"
"""
input connectors_webhook_aggregate_order_by {
  count: order_by
  max: connectors_webhook_max_order_by
  min: connectors_webhook_min_order_by
}

"""
input type for inserting array relation for remote table "connectors.webhook"
"""
input connectors_webhook_arr_rel_insert_input {
  data: [connectors_webhook_insert_input!]!

  """upsert condition"""
  on_conflict: connectors_webhook_on_conflict
}

"""
Boolean expression to filter rows from the table "connectors.webhook". All fields are combined with a logical 'AND'.
"""
input connectors_webhook_bool_exp {
  _and: [connectors_webhook_bool_exp!]
  _not: connectors_webhook_bool_exp
  _or: [connectors_webhook_bool_exp!]
  connector: connectors_connector_bool_exp
  connector_id: String_comparison_exp
  id: uuid_comparison_exp
  request_body: bytea_comparison_exp
}

"""
unique or primary key constraints on table "connectors.webhook"
"""
enum connectors_webhook_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  webhook_pk
}

"""
input type for inserting data into table "connectors.webhook"
"""
input connectors_webhook_insert_input {
  connector: connectors_connector_obj_rel_insert_input
  connector_id: String
  id: uuid
  request_body: bytea
}

"""aggregate max on columns"""
type connectors_webhook_max_fields {
  connector_id: String
  id: uuid
}

"""
order by max() on columns of table "connectors.webhook"
"""
input connectors_webhook_max_order_by {
  connector_id: order_by
  id: order_by
}

"""aggregate min on columns"""
type connectors_webhook_min_fields {
  connector_id: String
  id: uuid
}

"""
order by min() on columns of table "connectors.webhook"
"""
input connectors_webhook_min_order_by {
  connector_id: order_by
  id: order_by
}

"""
response of any mutation on the table "connectors.webhook"
"""
type connectors_webhook_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [connectors_webhook!]!
}

"""
on_conflict condition type for table "connectors.webhook"
"""
input connectors_webhook_on_conflict {
  constraint: connectors_webhook_constraint!
  update_columns: [connectors_webhook_update_column!]! = []
  where: connectors_webhook_bool_exp
}

"""Ordering options when selecting data from "connectors.webhook"."""
input connectors_webhook_order_by {
  connector: connectors_connector_order_by
  connector_id: order_by
  id: order_by
  request_body: order_by
}

"""primary key columns input for table: connectors.webhook"""
input connectors_webhook_pk_columns_input {
  id: uuid!
}

"""
select columns of table "connectors.webhook"
"""
enum connectors_webhook_select_column {
  """column name"""
  connector_id

  """column name"""
  id

  """column name"""
  request_body
}

"""
input type for updating data in table "connectors.webhook"
"""
input connectors_webhook_set_input {
  connector_id: String
  id: uuid
  request_body: bytea
}

"""
Streaming cursor of the table "connectors_webhook"
"""
input connectors_webhook_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: connectors_webhook_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input connectors_webhook_stream_cursor_value_input {
  connector_id: String
  id: uuid
  request_body: bytea
}

"""
update columns of table "connectors.webhook"
"""
enum connectors_webhook_update_column {
  """column name"""
  connector_id

  """column name"""
  id

  """column name"""
  request_body
}

input connectors_webhook_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: connectors_webhook_set_input

  """filter the rows which have to be updated"""
  where: connectors_webhook_bool_exp!
}

"""
columns and relationships of "consumers"
"""
type consumers {
  activated_at: timestamp!
  activated_by_iam_id: String
  activation_branch: String
  additional_salary: numeric
  additional_salary_source: String
  address: String
  address_description: String
  car_year: Int
  city: String
  classification: String!
  club: String
  company: String
  company_address: String

  """An array relationship"""
  consumers_credit_limits(
    """distinct select on columns"""
    distinct_on: [consumers_credit_limits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [consumers_credit_limits_order_by!]

    """filter the rows returned"""
    where: consumers_credit_limits_bool_exp
  ): [consumers_credit_limits!]!

  """An aggregate relationship"""
  consumers_credit_limits_aggregate(
    """distinct select on columns"""
    distinct_on: [consumers_credit_limits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [consumers_credit_limits_order_by!]

    """filter the rows returned"""
    where: consumers_credit_limits_bool_exp
  ): consumers_credit_limits_aggregate!
  created_at: timestamp!
  district: String
  first_name: String
  formanceAccount: accounts_account
  full_name: String
  governorate: String
  guarantor_job: String
  guarantor_relationship: String
  home_phone_number: String
  house_type: String
  iam_id: String
  id: uuid!
  identity: identities
  job_name: String
  last_name: String
  loans(
    """distinct select on columns"""
    distinct_on: [loan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_order_by!]

    """filter the rows returned"""
    where: loan_bool_exp
  ): [loan!]!
  loans_aggregate(
    """distinct select on columns"""
    distinct_on: [loan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_order_by!]

    """filter the rows returned"""
    where: loan_bool_exp
  ): loan_aggregate!
  marital_status: String
  national_id: String
  national_id_address: String
  origination_channel: String!
  phone_number: String!
  salary: numeric
  single_payment_day: Int!
  status: consumerstatus!
  updated_at: timestamp!
  work_phone_number: String
  work_type: String
}

"""
aggregated selection of "consumers"
"""
type consumers_aggregate {
  aggregate: consumers_aggregate_fields
  nodes: [consumers!]!
}

"""
aggregate fields of "consumers"
"""
type consumers_aggregate_fields {
  avg: consumers_avg_fields
  count(columns: [consumers_select_column!], distinct: Boolean): Int!
  max: consumers_max_fields
  min: consumers_min_fields
  stddev: consumers_stddev_fields
  stddev_pop: consumers_stddev_pop_fields
  stddev_samp: consumers_stddev_samp_fields
  sum: consumers_sum_fields
  var_pop: consumers_var_pop_fields
  var_samp: consumers_var_samp_fields
  variance: consumers_variance_fields
}

"""aggregate avg on columns"""
type consumers_avg_fields {
  additional_salary: Float
  car_year: Float
  salary: Float
  single_payment_day: Float
}

"""
Boolean expression to filter rows from the table "consumers". All fields are combined with a logical 'AND'.
"""
input consumers_bool_exp {
  _and: [consumers_bool_exp!]
  _not: consumers_bool_exp
  _or: [consumers_bool_exp!]
  activated_at: timestamp_comparison_exp
  activated_by_iam_id: String_comparison_exp
  activation_branch: String_comparison_exp
  additional_salary: numeric_comparison_exp
  additional_salary_source: String_comparison_exp
  address: String_comparison_exp
  address_description: String_comparison_exp
  car_year: Int_comparison_exp
  city: String_comparison_exp
  classification: String_comparison_exp
  club: String_comparison_exp
  company: String_comparison_exp
  company_address: String_comparison_exp
  consumers_credit_limits: consumers_credit_limits_bool_exp
  consumers_credit_limits_aggregate: consumers_credit_limits_aggregate_bool_exp
  created_at: timestamp_comparison_exp
  district: String_comparison_exp
  first_name: String_comparison_exp
  full_name: String_comparison_exp
  governorate: String_comparison_exp
  guarantor_job: String_comparison_exp
  guarantor_relationship: String_comparison_exp
  home_phone_number: String_comparison_exp
  house_type: String_comparison_exp
  iam_id: String_comparison_exp
  id: uuid_comparison_exp
  job_name: String_comparison_exp
  last_name: String_comparison_exp
  marital_status: String_comparison_exp
  national_id: String_comparison_exp
  national_id_address: String_comparison_exp
  origination_channel: String_comparison_exp
  phone_number: String_comparison_exp
  salary: numeric_comparison_exp
  single_payment_day: Int_comparison_exp
  status: consumerstatus_comparison_exp
  updated_at: timestamp_comparison_exp
  work_phone_number: String_comparison_exp
  work_type: String_comparison_exp
}

"""
unique or primary key constraints on table "consumers"
"""
enum consumers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  consumers_pkey

  """
  unique or primary key constraint on columns "phone_number"
  """
  ix_consumers_phone_number
}

"""
columns and relationships of "consumers_credit_limits"
"""
type consumers_credit_limits {
  """An object relationship"""
  consumer: consumers!
  consumer_id: uuid!
  created_at: timestamp!
  id: uuid!
  updated_at: timestamp!
  value: Int!
}

"""
aggregated selection of "consumers_credit_limits"
"""
type consumers_credit_limits_aggregate {
  aggregate: consumers_credit_limits_aggregate_fields
  nodes: [consumers_credit_limits!]!
}

input consumers_credit_limits_aggregate_bool_exp {
  count: consumers_credit_limits_aggregate_bool_exp_count
}

input consumers_credit_limits_aggregate_bool_exp_count {
  arguments: [consumers_credit_limits_select_column!]
  distinct: Boolean
  filter: consumers_credit_limits_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "consumers_credit_limits"
"""
type consumers_credit_limits_aggregate_fields {
  avg: consumers_credit_limits_avg_fields
  count(columns: [consumers_credit_limits_select_column!], distinct: Boolean): Int!
  max: consumers_credit_limits_max_fields
  min: consumers_credit_limits_min_fields
  stddev: consumers_credit_limits_stddev_fields
  stddev_pop: consumers_credit_limits_stddev_pop_fields
  stddev_samp: consumers_credit_limits_stddev_samp_fields
  sum: consumers_credit_limits_sum_fields
  var_pop: consumers_credit_limits_var_pop_fields
  var_samp: consumers_credit_limits_var_samp_fields
  variance: consumers_credit_limits_variance_fields
}

"""
order by aggregate values of table "consumers_credit_limits"
"""
input consumers_credit_limits_aggregate_order_by {
  avg: consumers_credit_limits_avg_order_by
  count: order_by
  max: consumers_credit_limits_max_order_by
  min: consumers_credit_limits_min_order_by
  stddev: consumers_credit_limits_stddev_order_by
  stddev_pop: consumers_credit_limits_stddev_pop_order_by
  stddev_samp: consumers_credit_limits_stddev_samp_order_by
  sum: consumers_credit_limits_sum_order_by
  var_pop: consumers_credit_limits_var_pop_order_by
  var_samp: consumers_credit_limits_var_samp_order_by
  variance: consumers_credit_limits_variance_order_by
}

"""
input type for inserting array relation for remote table "consumers_credit_limits"
"""
input consumers_credit_limits_arr_rel_insert_input {
  data: [consumers_credit_limits_insert_input!]!

  """upsert condition"""
  on_conflict: consumers_credit_limits_on_conflict
}

"""aggregate avg on columns"""
type consumers_credit_limits_avg_fields {
  value: Float
}

"""
order by avg() on columns of table "consumers_credit_limits"
"""
input consumers_credit_limits_avg_order_by {
  value: order_by
}

"""
Boolean expression to filter rows from the table "consumers_credit_limits". All fields are combined with a logical 'AND'.
"""
input consumers_credit_limits_bool_exp {
  _and: [consumers_credit_limits_bool_exp!]
  _not: consumers_credit_limits_bool_exp
  _or: [consumers_credit_limits_bool_exp!]
  consumer: consumers_bool_exp
  consumer_id: uuid_comparison_exp
  created_at: timestamp_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamp_comparison_exp
  value: Int_comparison_exp
}

"""
unique or primary key constraints on table "consumers_credit_limits"
"""
enum consumers_credit_limits_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  consumers_credit_limits_pkey
}

"""
input type for incrementing numeric columns in table "consumers_credit_limits"
"""
input consumers_credit_limits_inc_input {
  value: Int
}

"""
input type for inserting data into table "consumers_credit_limits"
"""
input consumers_credit_limits_insert_input {
  consumer: consumers_obj_rel_insert_input
  consumer_id: uuid
  created_at: timestamp
  id: uuid
  updated_at: timestamp
  value: Int
}

"""aggregate max on columns"""
type consumers_credit_limits_max_fields {
  consumer_id: uuid
  created_at: timestamp
  id: uuid
  updated_at: timestamp
  value: Int
}

"""
order by max() on columns of table "consumers_credit_limits"
"""
input consumers_credit_limits_max_order_by {
  consumer_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  value: order_by
}

"""aggregate min on columns"""
type consumers_credit_limits_min_fields {
  consumer_id: uuid
  created_at: timestamp
  id: uuid
  updated_at: timestamp
  value: Int
}

"""
order by min() on columns of table "consumers_credit_limits"
"""
input consumers_credit_limits_min_order_by {
  consumer_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  value: order_by
}

"""
response of any mutation on the table "consumers_credit_limits"
"""
type consumers_credit_limits_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [consumers_credit_limits!]!
}

"""
on_conflict condition type for table "consumers_credit_limits"
"""
input consumers_credit_limits_on_conflict {
  constraint: consumers_credit_limits_constraint!
  update_columns: [consumers_credit_limits_update_column!]! = []
  where: consumers_credit_limits_bool_exp
}

"""Ordering options when selecting data from "consumers_credit_limits"."""
input consumers_credit_limits_order_by {
  consumer: consumers_order_by
  consumer_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  value: order_by
}

"""primary key columns input for table: consumers_credit_limits"""
input consumers_credit_limits_pk_columns_input {
  id: uuid!
}

"""
select columns of table "consumers_credit_limits"
"""
enum consumers_credit_limits_select_column {
  """column name"""
  consumer_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  value
}

"""
input type for updating data in table "consumers_credit_limits"
"""
input consumers_credit_limits_set_input {
  consumer_id: uuid
  created_at: timestamp
  id: uuid
  updated_at: timestamp
  value: Int
}

"""aggregate stddev on columns"""
type consumers_credit_limits_stddev_fields {
  value: Float
}

"""
order by stddev() on columns of table "consumers_credit_limits"
"""
input consumers_credit_limits_stddev_order_by {
  value: order_by
}

"""aggregate stddev_pop on columns"""
type consumers_credit_limits_stddev_pop_fields {
  value: Float
}

"""
order by stddev_pop() on columns of table "consumers_credit_limits"
"""
input consumers_credit_limits_stddev_pop_order_by {
  value: order_by
}

"""aggregate stddev_samp on columns"""
type consumers_credit_limits_stddev_samp_fields {
  value: Float
}

"""
order by stddev_samp() on columns of table "consumers_credit_limits"
"""
input consumers_credit_limits_stddev_samp_order_by {
  value: order_by
}

"""
Streaming cursor of the table "consumers_credit_limits"
"""
input consumers_credit_limits_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: consumers_credit_limits_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input consumers_credit_limits_stream_cursor_value_input {
  consumer_id: uuid
  created_at: timestamp
  id: uuid
  updated_at: timestamp
  value: Int
}

"""aggregate sum on columns"""
type consumers_credit_limits_sum_fields {
  value: Int
}

"""
order by sum() on columns of table "consumers_credit_limits"
"""
input consumers_credit_limits_sum_order_by {
  value: order_by
}

"""
update columns of table "consumers_credit_limits"
"""
enum consumers_credit_limits_update_column {
  """column name"""
  consumer_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  value
}

input consumers_credit_limits_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: consumers_credit_limits_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: consumers_credit_limits_set_input

  """filter the rows which have to be updated"""
  where: consumers_credit_limits_bool_exp!
}

"""aggregate var_pop on columns"""
type consumers_credit_limits_var_pop_fields {
  value: Float
}

"""
order by var_pop() on columns of table "consumers_credit_limits"
"""
input consumers_credit_limits_var_pop_order_by {
  value: order_by
}

"""aggregate var_samp on columns"""
type consumers_credit_limits_var_samp_fields {
  value: Float
}

"""
order by var_samp() on columns of table "consumers_credit_limits"
"""
input consumers_credit_limits_var_samp_order_by {
  value: order_by
}

"""aggregate variance on columns"""
type consumers_credit_limits_variance_fields {
  value: Float
}

"""
order by variance() on columns of table "consumers_credit_limits"
"""
input consumers_credit_limits_variance_order_by {
  value: order_by
}

"""
input type for incrementing numeric columns in table "consumers"
"""
input consumers_inc_input {
  additional_salary: numeric
  car_year: Int
  salary: numeric
  single_payment_day: Int
}

"""
input type for inserting data into table "consumers"
"""
input consumers_insert_input {
  activated_at: timestamp
  activated_by_iam_id: String
  activation_branch: String
  additional_salary: numeric
  additional_salary_source: String
  address: String
  address_description: String
  car_year: Int
  city: String
  classification: String
  club: String
  company: String
  company_address: String
  consumers_credit_limits: consumers_credit_limits_arr_rel_insert_input
  created_at: timestamp
  district: String
  first_name: String
  full_name: String
  governorate: String
  guarantor_job: String
  guarantor_relationship: String
  home_phone_number: String
  house_type: String
  iam_id: String
  id: uuid
  job_name: String
  last_name: String
  marital_status: String
  national_id: String
  national_id_address: String
  origination_channel: String
  phone_number: String
  salary: numeric
  single_payment_day: Int
  status: consumerstatus
  updated_at: timestamp
  work_phone_number: String
  work_type: String
}

"""aggregate max on columns"""
type consumers_max_fields {
  activated_at: timestamp
  activated_by_iam_id
  activation_branch: String
  additional_salary: numeric
  additional_salary_source: String
  address: String
  address_description: String
  car_year: Int
  city: String
  classification: String
  club: String
  company: String
  company_address: String
  created_at: timestamp
  district: String
  first_name: String
  full_name: String
  governorate: String
  guarantor_job: String
  guarantor_relationship: String
  home_phone_number: String
  house_type: String
  iam_id: String
  id: uuid
  job_name: String
  last_name: String
  marital_status: String
  national_id: String
  national_id_address: String
  origination_channel: String
  phone_number: String
  salary: numeric
  single_payment_day: Int
  status: consumerstatus
  updated_at: timestamp
  work_phone_number: String
  work_type: String
}

"""aggregate min on columns"""
type consumers_min_fields {
  activated_at: timestamp
  activated_by_iam_id
  activation_branch: String
  additional_salary: numeric
  additional_salary_source: String
  address: String
  address_description: String
  car_year: Int
  city: String
  classification: String
  club: String
  company: String
  company_address: String
  created_at: timestamp
  district: String
  first_name: String
  full_name: String
  governorate: String
  guarantor_job: String
  guarantor_relationship: String
  home_phone_number: String
  house_type: String
  iam_id: String
  id: uuid
  job_name: String
  last_name: String
  marital_status: String
  national_id: String
  national_id_address: String
  origination_channel: String
  phone_number: String
  salary: numeric
  single_payment_day: Int
  status: consumerstatus
  updated_at: timestamp
  work_phone_number: String
  work_type: String
}

"""
response of any mutation on the table "consumers"
"""
type consumers_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [consumers!]!
}

"""
input type for inserting object relation for remote table "consumers"
"""
input consumers_obj_rel_insert_input {
  data: consumers_insert_input!

  """upsert condition"""
  on_conflict: consumers_on_conflict
}

"""
on_conflict condition type for table "consumers"
"""
input consumers_on_conflict {
  constraint: consumers_constraint!
  update_columns: [consumers_update_column!]! = []
  where: consumers_bool_exp
}

"""Ordering options when selecting data from "consumers"."""
input consumers_order_by {
  activated_at: order_by
  activated_by_iam_id: order_by
  activation_branch: order_by
  additional_salary: order_by
  additional_salary_source: order_by
  address: order_by
  address_description: order_by
  car_year: order_by
  city: order_by
  classification: order_by
  club: order_by
  company: order_by
  company_address: order_by
  consumers_credit_limits_aggregate: consumers_credit_limits_aggregate_order_by
  created_at: order_by
  district: order_by
  first_name: order_by
  full_name: order_by
  governorate: order_by
  guarantor_job: order_by
  guarantor_relationship: order_by
  home_phone_number: order_by
  house_type: order_by
  iam_id: order_by
  id: order_by
  job_name: order_by
  last_name: order_by
  marital_status: order_by
  national_id: order_by
  national_id_address: order_by
  origination_channel: order_by
  phone_number: order_by
  salary: order_by
  single_payment_day: order_by
  status: order_by
  updated_at: order_by
  work_phone_number: order_by
  work_type: order_by
}

"""primary key columns input for table: consumers"""
input consumers_pk_columns_input {
  id: uuid!
}

"""
select columns of table "consumers"
"""
enum consumers_select_column {
  """column name"""
  activated_at

  """column name"""
  activated_by_iam_id

  """column name"""
  activation_branch

  """column name"""
  additional_salary

  """column name"""
  additional_salary_source

  """column name"""
  address

  """column name"""
  address_description

  """column name"""
  car_year

  """column name"""
  city

  """column name"""
  classification

  """column name"""
  club

  """column name"""
  company

  """column name"""
  company_address

  """column name"""
  created_at

  """column name"""
  district

  """column name"""
  first_name

  """column name"""
  full_name

  """column name"""
  governorate

  """column name"""
  guarantor_job

  """column name"""
  guarantor_relationship

  """column name"""
  home_phone_number

  """column name"""
  house_type

  """column name"""
  iam_id

  """column name"""
  id

  """column name"""
  job_name

  """column name"""
  last_name

  """column name"""
  marital_status

  """column name"""
  national_id

  """column name"""
  national_id_address

  """column name"""
  origination_channel

  """column name"""
  phone_number

  """column name"""
  salary

  """column name"""
  single_payment_day

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  work_phone_number

  """column name"""
  work_type
}

"""
input type for updating data in table "consumers"
"""
input consumers_set_input {
  activated_at: timestamp
  activated_by_iam_id: String
  activation_branch: String
  additional_salary: numeric
  additional_salary_source: String
  address: String
  address_description: String
  car_year: Int
  city: String
  classification: String
  club: String
  company: String
  company_address: String
  created_at: timestamp
  district: String
  first_name: String
  full_name: String
  governorate: String
  guarantor_job: String
  guarantor_relationship: String
  home_phone_number: String
  house_type: String
  iam_id: String
  id: uuid
  job_name: String
  last_name: String
  marital_status: String
  national_id: String
  national_id_address: String
  origination_channel: String
  phone_number: String
  salary: numeric
  single_payment_day: Int
  status: consumerstatus
  updated_at: timestamp
  work_phone_number: String
  work_type: String
}

"""aggregate stddev on columns"""
type consumers_stddev_fields {
  additional_salary: Float
  car_year: Float
  salary: Float
  single_payment_day: Float
}

"""aggregate stddev_pop on columns"""
type consumers_stddev_pop_fields {
  additional_salary: Float
  car_year: Float
  salary: Float
  single_payment_day: Float
}

"""aggregate stddev_samp on columns"""
type consumers_stddev_samp_fields {
  additional_salary: Float
  car_year: Float
  salary: Float
  single_payment_day: Float
}

"""
Streaming cursor of the table "consumers"
"""
input consumers_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: consumers_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input consumers_stream_cursor_value_input {
  activated_at: timestamp
  activated_by_iam_id: String
  activation_branch: String
  additional_salary: numeric
  additional_salary_source: String
  address: String
  address_description: String
  car_year: Int
  city: String
  classification: String
  club: String
  company: String
  company_address: String
  created_at: timestamp
  district: String
  first_name: String
  full_name: String
  governorate: String
  guarantor_job: String
  guarantor_relationship: String
  home_phone_number: String
  house_type: String
  iam_id: String
  id: uuid
  job_name: String
  last_name: String
  marital_status: String
  national_id: String
  national_id_address: String
  origination_channel: String
  phone_number: String
  salary: numeric
  single_payment_day: Int
  status: consumerstatus
  updated_at: timestamp
  work_phone_number: String
  work_type: String
}

"""aggregate sum on columns"""
type consumers_sum_fields {
  additional_salary: numeric
  car_year: Int
  salary: numeric
  single_payment_day: Int
}

"""
update columns of table "consumers"
"""
enum consumers_update_column {
  """column name"""
  activated_at

  """column name"""
  activated_by_iam_id

  """column name"""
  activation_branch

  """column name"""
  additional_salary

  """column name"""
  additional_salary_source

  """column name"""
  address

  """column name"""
  address_description

  """column name"""
  car_year

  """column name"""
  city

  """column name"""
  classification

  """column name"""
  club

  """column name"""
  company

  """column name"""
  company_address

  """column name"""
  created_at

  """column name"""
  district

  """column name"""
  first_name

  """column name"""
  full_name

  """column name"""
  governorate

  """column name"""
  guarantor_job

  """column name"""
  guarantor_relationship

  """column name"""
  home_phone_number

  """column name"""
  house_type

  """column name"""
  iam_id

  """column name"""
  id

  """column name"""
  job_name

  """column name"""
  last_name

  """column name"""
  marital_status

  """column name"""
  national_id

  """column name"""
  national_id_address

  """column name"""
  origination_channel

  """column name"""
  phone_number

  """column name"""
  salary

  """column name"""
  single_payment_day

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  work_phone_number

  """column name"""
  work_type
}

input consumers_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: consumers_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: consumers_set_input

  """filter the rows which have to be updated"""
  where: consumers_bool_exp!
}

"""aggregate var_pop on columns"""
type consumers_var_pop_fields {
  additional_salary: Float
  car_year: Float
  salary: Float
  single_payment_day: Float
}

"""aggregate var_samp on columns"""
type consumers_var_samp_fields {
  additional_salary: Float
  car_year: Float
  salary: Float
  single_payment_day: Float
}

"""aggregate variance on columns"""
type consumers_variance_fields {
  additional_salary: Float
  car_year: Float
  salary: Float
  single_payment_day: Float
}

scalar consumerstatus

"""
Boolean expression to compare columns of type "consumerstatus". All fields are combined with logical 'AND'.
"""
input consumerstatus_comparison_exp {
  _eq: consumerstatus
  _gt: consumerstatus
  _gte: consumerstatus
  _in: [consumerstatus!]
  _is_null: Boolean
  _lt: consumerstatus
  _lte: consumerstatus
  _neq: consumerstatus
  _nin: [consumerstatus!]
}

scalar currencycode

"""
Boolean expression to compare columns of type "currencycode". All fields are combined with logical 'AND'.
"""
input currencycode_comparison_exp {
  _eq: currencycode
  _gt: currencycode
  _gte: currencycode
  _in: [currencycode!]
  _is_null: Boolean
  _lt: currencycode
  _lte: currencycode
  _neq: currencycode
  _nin: [currencycode!]
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
columns and relationships of "entry"
"""
type entry {
  amount: bigint!

  """An object relationship"""
  command: command!
  command_id: Int!
  entry_type: String!
  id: bigint!
}

"""
aggregated selection of "entry"
"""
type entry_aggregate {
  aggregate: entry_aggregate_fields
  nodes: [entry!]!
}

input entry_aggregate_bool_exp {
  count: entry_aggregate_bool_exp_count
}

input entry_aggregate_bool_exp_count {
  arguments: [entry_select_column!]
  distinct: Boolean
  filter: entry_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "entry"
"""
type entry_aggregate_fields {
  avg: entry_avg_fields
  count(columns: [entry_select_column!], distinct: Boolean): Int!
  max: entry_max_fields
  min: entry_min_fields
  stddev: entry_stddev_fields
  stddev_pop: entry_stddev_pop_fields
  stddev_samp: entry_stddev_samp_fields
  sum: entry_sum_fields
  var_pop: entry_var_pop_fields
  var_samp: entry_var_samp_fields
  variance: entry_variance_fields
}

"""
order by aggregate values of table "entry"
"""
input entry_aggregate_order_by {
  avg: entry_avg_order_by
  count: order_by
  max: entry_max_order_by
  min: entry_min_order_by
  stddev: entry_stddev_order_by
  stddev_pop: entry_stddev_pop_order_by
  stddev_samp: entry_stddev_samp_order_by
  sum: entry_sum_order_by
  var_pop: entry_var_pop_order_by
  var_samp: entry_var_samp_order_by
  variance: entry_variance_order_by
}

"""
input type for inserting array relation for remote table "entry"
"""
input entry_arr_rel_insert_input {
  data: [entry_insert_input!]!

  """upsert condition"""
  on_conflict: entry_on_conflict
}

"""aggregate avg on columns"""
type entry_avg_fields {
  amount: Float
  command_id: Float
  id: Float
}

"""
order by avg() on columns of table "entry"
"""
input entry_avg_order_by {
  amount: order_by
  command_id: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "entry". All fields are combined with a logical 'AND'.
"""
input entry_bool_exp {
  _and: [entry_bool_exp!]
  _not: entry_bool_exp
  _or: [entry_bool_exp!]
  amount: bigint_comparison_exp
  command: command_bool_exp
  command_id: Int_comparison_exp
  entry_type: String_comparison_exp
  id: bigint_comparison_exp
}

"""
unique or primary key constraints on table "entry"
"""
enum entry_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  entry_pkey
}

"""
input type for incrementing numeric columns in table "entry"
"""
input entry_inc_input {
  amount: bigint
  command_id: Int
  id: bigint
}

"""
input type for inserting data into table "entry"
"""
input entry_insert_input {
  amount: bigint
  command: command_obj_rel_insert_input
  command_id: Int
  entry_type: String
  id: bigint
}

"""aggregate max on columns"""
type entry_max_fields {
  amount: bigint
  command_id: Int
  entry_type: String
  id: bigint
}

"""
order by max() on columns of table "entry"
"""
input entry_max_order_by {
  amount: order_by
  command_id: order_by
  entry_type: order_by
  id: order_by
}

"""aggregate min on columns"""
type entry_min_fields {
  amount: bigint
  command_id: Int
  entry_type: String
  id: bigint
}

"""
order by min() on columns of table "entry"
"""
input entry_min_order_by {
  amount: order_by
  command_id: order_by
  entry_type: order_by
  id: order_by
}

"""
response of any mutation on the table "entry"
"""
type entry_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [entry!]!
}

"""
on_conflict condition type for table "entry"
"""
input entry_on_conflict {
  constraint: entry_constraint!
  update_columns: [entry_update_column!]! = []
  where: entry_bool_exp
}

"""Ordering options when selecting data from "entry"."""
input entry_order_by {
  amount: order_by
  command: command_order_by
  command_id: order_by
  entry_type: order_by
  id: order_by
}

"""primary key columns input for table: entry"""
input entry_pk_columns_input {
  id: bigint!
}

"""
select columns of table "entry"
"""
enum entry_select_column {
  """column name"""
  amount

  """column name"""
  command_id

  """column name"""
  entry_type

  """column name"""
  id
}

"""
input type for updating data in table "entry"
"""
input entry_set_input {
  amount: bigint
  command_id: Int
  entry_type: String
  id: bigint
}

"""aggregate stddev on columns"""
type entry_stddev_fields {
  amount: Float
  command_id: Float
  id: Float
}

"""
order by stddev() on columns of table "entry"
"""
input entry_stddev_order_by {
  amount: order_by
  command_id: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type entry_stddev_pop_fields {
  amount: Float
  command_id: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "entry"
"""
input entry_stddev_pop_order_by {
  amount: order_by
  command_id: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type entry_stddev_samp_fields {
  amount: Float
  command_id: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "entry"
"""
input entry_stddev_samp_order_by {
  amount: order_by
  command_id: order_by
  id: order_by
}

"""
Streaming cursor of the table "entry"
"""
input entry_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: entry_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input entry_stream_cursor_value_input {
  amount: bigint
  command_id: Int
  entry_type: String
  id: bigint
}

"""aggregate sum on columns"""
type entry_sum_fields {
  amount: bigint
  command_id: Int
  id: bigint
}

"""
order by sum() on columns of table "entry"
"""
input entry_sum_order_by {
  amount: order_by
  command_id: order_by
  id: order_by
}

"""
update columns of table "entry"
"""
enum entry_update_column {
  """column name"""
  amount

  """column name"""
  command_id

  """column name"""
  entry_type

  """column name"""
  id
}

input entry_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: entry_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: entry_set_input

  """filter the rows which have to be updated"""
  where: entry_bool_exp!
}

"""aggregate var_pop on columns"""
type entry_var_pop_fields {
  amount: Float
  command_id: Float
  id: Float
}

"""
order by var_pop() on columns of table "entry"
"""
input entry_var_pop_order_by {
  amount: order_by
  command_id: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type entry_var_samp_fields {
  amount: Float
  command_id: Float
  id: Float
}

"""
order by var_samp() on columns of table "entry"
"""
input entry_var_samp_order_by {
  amount: order_by
  command_id: order_by
  id: order_by
}

"""aggregate variance on columns"""
type entry_variance_fields {
  amount: Float
  command_id: Float
  id: Float
}

"""
order by variance() on columns of table "entry"
"""
input entry_variance_order_by {
  amount: order_by
  command_id: order_by
  id: order_by
}

"""
columns and relationships of "governorates"
"""
type governorates {
  """An array relationship"""
  areas(
    """distinct select on columns"""
    distinct_on: [areas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [areas_order_by!]

    """filter the rows returned"""
    where: areas_bool_exp
  ): [areas!]!

  """An aggregate relationship"""
  areas_aggregate(
    """distinct select on columns"""
    distinct_on: [areas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [areas_order_by!]

    """filter the rows returned"""
    where: areas_bool_exp
  ): areas_aggregate!

  """An array relationship"""
  cities(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): [cities!]!

  """An aggregate relationship"""
  cities_aggregate(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): cities_aggregate!
  created_at: timestamp!
  id: Int!
  mc_id: Int!
  name_ar: String!
  name_en: String!
  updated_at: timestamp!
}

"""
aggregated selection of "governorates"
"""
type governorates_aggregate {
  aggregate: governorates_aggregate_fields
  nodes: [governorates!]!
}

"""
aggregate fields of "governorates"
"""
type governorates_aggregate_fields {
  avg: governorates_avg_fields
  count(columns: [governorates_select_column!], distinct: Boolean): Int!
  max: governorates_max_fields
  min: governorates_min_fields
  stddev: governorates_stddev_fields
  stddev_pop: governorates_stddev_pop_fields
  stddev_samp: governorates_stddev_samp_fields
  sum: governorates_sum_fields
  var_pop: governorates_var_pop_fields
  var_samp: governorates_var_samp_fields
  variance: governorates_variance_fields
}

"""aggregate avg on columns"""
type governorates_avg_fields {
  id: Float
  mc_id: Float
}

"""
Boolean expression to filter rows from the table "governorates". All fields are combined with a logical 'AND'.
"""
input governorates_bool_exp {
  _and: [governorates_bool_exp!]
  _not: governorates_bool_exp
  _or: [governorates_bool_exp!]
  areas: areas_bool_exp
  areas_aggregate: areas_aggregate_bool_exp
  cities: cities_bool_exp
  cities_aggregate: cities_aggregate_bool_exp
  created_at: timestamp_comparison_exp
  id: Int_comparison_exp
  mc_id: Int_comparison_exp
  name_ar: String_comparison_exp
  name_en: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "governorates"
"""
enum governorates_constraint {
  """
  unique or primary key constraint on columns "mc_id"
  """
  governorates_mc_id_key

  """
  unique or primary key constraint on columns "id"
  """
  governorates_pkey
}

"""
input type for incrementing numeric columns in table "governorates"
"""
input governorates_inc_input {
  id: Int
  mc_id: Int
}

"""
input type for inserting data into table "governorates"
"""
input governorates_insert_input {
  areas: areas_arr_rel_insert_input
  cities: cities_arr_rel_insert_input
  created_at: timestamp
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""aggregate max on columns"""
type governorates_max_fields {
  created_at: timestamp
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""aggregate min on columns"""
type governorates_min_fields {
  created_at: timestamp
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""
response of any mutation on the table "governorates"
"""
type governorates_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [governorates!]!
}

"""
input type for inserting object relation for remote table "governorates"
"""
input governorates_obj_rel_insert_input {
  data: governorates_insert_input!

  """upsert condition"""
  on_conflict: governorates_on_conflict
}

"""
on_conflict condition type for table "governorates"
"""
input governorates_on_conflict {
  constraint: governorates_constraint!
  update_columns: [governorates_update_column!]! = []
  where: governorates_bool_exp
}

"""Ordering options when selecting data from "governorates"."""
input governorates_order_by {
  areas_aggregate: areas_aggregate_order_by
  cities_aggregate: cities_aggregate_order_by
  created_at: order_by
  id: order_by
  mc_id: order_by
  name_ar: order_by
  name_en: order_by
  updated_at: order_by
}

"""primary key columns input for table: governorates"""
input governorates_pk_columns_input {
  id: Int!
}

"""
select columns of table "governorates"
"""
enum governorates_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  mc_id

  """column name"""
  name_ar

  """column name"""
  name_en

  """column name"""
  updated_at
}

"""
input type for updating data in table "governorates"
"""
input governorates_set_input {
  created_at: timestamp
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""aggregate stddev on columns"""
type governorates_stddev_fields {
  id: Float
  mc_id: Float
}

"""aggregate stddev_pop on columns"""
type governorates_stddev_pop_fields {
  id: Float
  mc_id: Float
}

"""aggregate stddev_samp on columns"""
type governorates_stddev_samp_fields {
  id: Float
  mc_id: Float
}

"""
Streaming cursor of the table "governorates"
"""
input governorates_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: governorates_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input governorates_stream_cursor_value_input {
  created_at: timestamp
  id: Int
  mc_id: Int
  name_ar: String
  name_en: String
  updated_at: timestamp
}

"""aggregate sum on columns"""
type governorates_sum_fields {
  id: Int
  mc_id: Int
}

"""
update columns of table "governorates"
"""
enum governorates_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  mc_id

  """column name"""
  name_ar

  """column name"""
  name_en

  """column name"""
  updated_at
}

input governorates_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: governorates_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: governorates_set_input

  """filter the rows which have to be updated"""
  where: governorates_bool_exp!
}

"""aggregate var_pop on columns"""
type governorates_var_pop_fields {
  id: Float
  mc_id: Float
}

"""aggregate var_samp on columns"""
type governorates_var_samp_fields {
  id: Float
  mc_id: Float
}

"""aggregate variance on columns"""
type governorates_variance_fields {
  id: Float
  mc_id: Float
}

"""
columns and relationships of "identities"
"""
type identities {
  available_aal: String
  created_at: timestamp!
  id: uuid!
  metadata_admin(
    """JSON select path"""
    path: String
  ): jsonb
  metadata_public(
    """JSON select path"""
    path: String
  ): jsonb
  nid: uuid
  organization_id: uuid
  schema_id: String!
  state: String!
  state_changed_at: timestamp
  traits(
    """JSON select path"""
    path: String
  ): jsonb!
  updated_at: timestamp!
}

"""
aggregated selection of "identities"
"""
type identities_aggregate {
  aggregate: identities_aggregate_fields
  nodes: [identities!]!
}

"""
aggregate fields of "identities"
"""
type identities_aggregate_fields {
  count(columns: [identities_select_column!], distinct: Boolean): Int!
  max: identities_max_fields
  min: identities_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input identities_append_input {
  metadata_admin: jsonb
  metadata_public: jsonb
  traits: jsonb
}

"""
Boolean expression to filter rows from the table "identities". All fields are combined with a logical 'AND'.
"""
input identities_bool_exp {
  _and: [identities_bool_exp!]
  _not: identities_bool_exp
  _or: [identities_bool_exp!]
  available_aal: String_comparison_exp
  created_at: timestamp_comparison_exp
  id: uuid_comparison_exp
  metadata_admin: jsonb_comparison_exp
  metadata_public: jsonb_comparison_exp
  nid: uuid_comparison_exp
  organization_id: uuid_comparison_exp
  schema_id: String_comparison_exp
  state: String_comparison_exp
  state_changed_at: timestamp_comparison_exp
  traits: jsonb_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "identities"
"""
enum identities_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  identities_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input identities_delete_at_path_input {
  metadata_admin: [String!]
  metadata_public: [String!]
  traits: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input identities_delete_elem_input {
  metadata_admin: Int
  metadata_public: Int
  traits: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input identities_delete_key_input {
  metadata_admin: String
  metadata_public: String
  traits: String
}

"""
input type for inserting data into table "identities"
"""
input identities_insert_input {
  available_aal: String
  created_at: timestamp
  id: uuid
  metadata_admin: jsonb
  metadata_public: jsonb
  nid: uuid
  organization_id: uuid
  schema_id: String
  state: String
  state_changed_at: timestamp
  traits: jsonb
  updated_at: timestamp
}

"""aggregate max on columns"""
type identities_max_fields {
  available_aal: String
  created_at: timestamp
  id: uuid
  nid: uuid
  organization_id: uuid
  schema_id: String
  state: String
  state_changed_at: timestamp
  updated_at: timestamp
}

"""aggregate min on columns"""
type identities_min_fields {
  available_aal: String
  created_at: timestamp
  id: uuid
  nid: uuid
  organization_id: uuid
  schema_id: String
  state: String
  state_changed_at: timestamp
  updated_at: timestamp
}

"""
response of any mutation on the table "identities"
"""
type identities_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [identities!]!
}

"""
on_conflict condition type for table "identities"
"""
input identities_on_conflict {
  constraint: identities_constraint!
  update_columns: [identities_update_column!]! = []
  where: identities_bool_exp
}

"""Ordering options when selecting data from "identities"."""
input identities_order_by {
  available_aal: order_by
  created_at: order_by
  id: order_by
  metadata_admin: order_by
  metadata_public: order_by
  nid: order_by
  organization_id: order_by
  schema_id: order_by
  state: order_by
  state_changed_at: order_by
  traits: order_by
  updated_at: order_by
}

"""primary key columns input for table: identities"""
input identities_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input identities_prepend_input {
  metadata_admin: jsonb
  metadata_public: jsonb
  traits: jsonb
}

"""
select columns of table "identities"
"""
enum identities_select_column {
  """column name"""
  available_aal

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  metadata_admin

  """column name"""
  metadata_public

  """column name"""
  nid

  """column name"""
  organization_id

  """column name"""
  schema_id

  """column name"""
  state

  """column name"""
  state_changed_at

  """column name"""
  traits

  """column name"""
  updated_at
}

"""
input type for updating data in table "identities"
"""
input identities_set_input {
  available_aal: String
  created_at: timestamp
  id: uuid
  metadata_admin: jsonb
  metadata_public: jsonb
  nid: uuid
  organization_id: uuid
  schema_id: String
  state: String
  state_changed_at: timestamp
  traits: jsonb
  updated_at: timestamp
}

"""
Streaming cursor of the table "identities"
"""
input identities_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: identities_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input identities_stream_cursor_value_input {
  available_aal: String
  created_at: timestamp
  id: uuid
  metadata_admin: jsonb
  metadata_public: jsonb
  nid: uuid
  organization_id: uuid
  schema_id: String
  state: String
  state_changed_at: timestamp
  traits: jsonb
  updated_at: timestamp
}

"""
update columns of table "identities"
"""
enum identities_update_column {
  """column name"""
  available_aal

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  metadata_admin

  """column name"""
  metadata_public

  """column name"""
  nid

  """column name"""
  organization_id

  """column name"""
  schema_id

  """column name"""
  state

  """column name"""
  state_changed_at

  """column name"""
  traits

  """column name"""
  updated_at
}

input identities_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: identities_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: identities_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: identities_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: identities_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: identities_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: identities_set_input

  """filter the rows which have to be updated"""
  where: identities_bool_exp!
}

"""
columns and relationships of "identity_verifiable_addresses"
"""
type identity_verifiable_addresses {
  created_at: timestamp!
  id: uuid!
  identity_id: uuid!
  nid: uuid
  status: String!
  updated_at: timestamp!
  value: String!
  verified: Boolean!
  verified_at: timestamp
  via: String!
}

"""
aggregated selection of "identity_verifiable_addresses"
"""
type identity_verifiable_addresses_aggregate {
  aggregate: identity_verifiable_addresses_aggregate_fields
  nodes: [identity_verifiable_addresses!]!
}

"""
aggregate fields of "identity_verifiable_addresses"
"""
type identity_verifiable_addresses_aggregate_fields {
  count(columns: [identity_verifiable_addresses_select_column!], distinct: Boolean): Int!
  max: identity_verifiable_addresses_max_fields
  min: identity_verifiable_addresses_min_fields
}

"""
Boolean expression to filter rows from the table "identity_verifiable_addresses". All fields are combined with a logical 'AND'.
"""
input identity_verifiable_addresses_bool_exp {
  _and: [identity_verifiable_addresses_bool_exp!]
  _not: identity_verifiable_addresses_bool_exp
  _or: [identity_verifiable_addresses_bool_exp!]
  created_at: timestamp_comparison_exp
  id: uuid_comparison_exp
  identity_id: uuid_comparison_exp
  nid: uuid_comparison_exp
  status: String_comparison_exp
  updated_at: timestamp_comparison_exp
  value: String_comparison_exp
  verified: Boolean_comparison_exp
  verified_at: timestamp_comparison_exp
  via: String_comparison_exp
}

"""
unique or primary key constraints on table "identity_verifiable_addresses"
"""
enum identity_verifiable_addresses_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  identity_verifiable_addresses_pkey

  """
  unique or primary key constraint on columns "nid", "value", "via"
  """
  identity_verifiable_addresses_status_via_uq_idx
}

"""
input type for inserting data into table "identity_verifiable_addresses"
"""
input identity_verifiable_addresses_insert_input {
  created_at: timestamp
  id: uuid
  identity_id: uuid
  nid: uuid
  status: String
  updated_at: timestamp
  value: String
  verified: Boolean
  verified_at: timestamp
  via: String
}

"""aggregate max on columns"""
type identity_verifiable_addresses_max_fields {
  created_at: timestamp
  id: uuid
  identity_id: uuid
  nid: uuid
  status: String
  updated_at: timestamp
  value: String
  verified_at: timestamp
  via: String
}

"""aggregate min on columns"""
type identity_verifiable_addresses_min_fields {
  created_at: timestamp
  id: uuid
  identity_id: uuid
  nid: uuid
  status: String
  updated_at: timestamp
  value: String
  verified_at: timestamp
  via: String
}

"""
response of any mutation on the table "identity_verifiable_addresses"
"""
type identity_verifiable_addresses_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [identity_verifiable_addresses!]!
}

"""
on_conflict condition type for table "identity_verifiable_addresses"
"""
input identity_verifiable_addresses_on_conflict {
  constraint: identity_verifiable_addresses_constraint!
  update_columns: [identity_verifiable_addresses_update_column!]! = []
  where: identity_verifiable_addresses_bool_exp
}

"""
Ordering options when selecting data from "identity_verifiable_addresses".
"""
input identity_verifiable_addresses_order_by {
  created_at: order_by
  id: order_by
  identity_id: order_by
  nid: order_by
  status: order_by
  updated_at: order_by
  value: order_by
  verified: order_by
  verified_at: order_by
  via: order_by
}

"""primary key columns input for table: identity_verifiable_addresses"""
input identity_verifiable_addresses_pk_columns_input {
  id: uuid!
}

"""
select columns of table "identity_verifiable_addresses"
"""
enum identity_verifiable_addresses_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  identity_id

  """column name"""
  nid

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  value

  """column name"""
  verified

  """column name"""
  verified_at

  """column name"""
  via
}

"""
input type for updating data in table "identity_verifiable_addresses"
"""
input identity_verifiable_addresses_set_input {
  created_at: timestamp
  id: uuid
  identity_id: uuid
  nid: uuid
  status: String
  updated_at: timestamp
  value: String
  verified: Boolean
  verified_at: timestamp
  via: String
}

"""
Streaming cursor of the table "identity_verifiable_addresses"
"""
input identity_verifiable_addresses_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: identity_verifiable_addresses_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input identity_verifiable_addresses_stream_cursor_value_input {
  created_at: timestamp
  id: uuid
  identity_id: uuid
  nid: uuid
  status: String
  updated_at: timestamp
  value: String
  verified: Boolean
  verified_at: timestamp
  via: String
}

"""
update columns of table "identity_verifiable_addresses"
"""
enum identity_verifiable_addresses_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  identity_id

  """column name"""
  nid

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  value

  """column name"""
  verified

  """column name"""
  verified_at

  """column name"""
  via
}

input identity_verifiable_addresses_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: identity_verifiable_addresses_set_input

  """filter the rows which have to be updated"""
  where: identity_verifiable_addresses_bool_exp!
}

"""
columns and relationships of "journal"
"""
type journal {
  account: String!
  amount: bigint!
  booked_at: timestamptz!
  correlation_id: String!
  created_at: timestamptz!
  created_by: String!
  direction: journal_direction!
  id: Int!

  """An object relationship"""
  loan: loan!
  loan_id: String!
  transaction_id: Int!
  type: String!
}

"""
aggregated selection of "journal"
"""
type journal_aggregate {
  aggregate: journal_aggregate_fields
  nodes: [journal!]!
}

input journal_aggregate_bool_exp {
  count: journal_aggregate_bool_exp_count
}

input journal_aggregate_bool_exp_count {
  arguments: [journal_select_column!]
  distinct: Boolean
  filter: journal_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "journal"
"""
type journal_aggregate_fields {
  avg: journal_avg_fields
  count(columns: [journal_select_column!], distinct: Boolean): Int!
  max: journal_max_fields
  min: journal_min_fields
  stddev: journal_stddev_fields
  stddev_pop: journal_stddev_pop_fields
  stddev_samp: journal_stddev_samp_fields
  sum: journal_sum_fields
  var_pop: journal_var_pop_fields
  var_samp: journal_var_samp_fields
  variance: journal_variance_fields
}

"""
order by aggregate values of table "journal"
"""
input journal_aggregate_order_by {
  avg: journal_avg_order_by
  count: order_by
  max: journal_max_order_by
  min: journal_min_order_by
  stddev: journal_stddev_order_by
  stddev_pop: journal_stddev_pop_order_by
  stddev_samp: journal_stddev_samp_order_by
  sum: journal_sum_order_by
  var_pop: journal_var_pop_order_by
  var_samp: journal_var_samp_order_by
  variance: journal_variance_order_by
}

"""
input type for inserting array relation for remote table "journal"
"""
input journal_arr_rel_insert_input {
  data: [journal_insert_input!]!

  """upsert condition"""
  on_conflict: journal_on_conflict
}

"""aggregate avg on columns"""
type journal_avg_fields {
  amount: Float
  id: Float
  transaction_id: Float
}

"""
order by avg() on columns of table "journal"
"""
input journal_avg_order_by {
  amount: order_by
  id: order_by
  transaction_id: order_by
}

"""
Boolean expression to filter rows from the table "journal". All fields are combined with a logical 'AND'.
"""
input journal_bool_exp {
  _and: [journal_bool_exp!]
  _not: journal_bool_exp
  _or: [journal_bool_exp!]
  account: String_comparison_exp
  amount: bigint_comparison_exp
  booked_at: timestamptz_comparison_exp
  correlation_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by: String_comparison_exp
  direction: journal_direction_comparison_exp
  id: Int_comparison_exp
  loan: loan_bool_exp
  loan_id: String_comparison_exp
  transaction_id: Int_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "journal"
"""
enum journal_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  journal_pkey
}

scalar journal_direction

"""
Boolean expression to compare columns of type "journal_direction". All fields are combined with logical 'AND'.
"""
input journal_direction_comparison_exp {
  _eq: journal_direction
  _gt: journal_direction
  _gte: journal_direction
  _in: [journal_direction!]
  _is_null: Boolean
  _lt: journal_direction
  _lte: journal_direction
  _neq: journal_direction
  _nin: [journal_direction!]
}

"""
input type for incrementing numeric columns in table "journal"
"""
input journal_inc_input {
  amount: bigint
  id: Int
  transaction_id: Int
}

"""
input type for inserting data into table "journal"
"""
input journal_insert_input {
  account: String
  amount: bigint
  booked_at: timestamptz
  correlation_id: String
  created_at: timestamptz
  created_by: String
  direction: journal_direction
  id: Int
  loan: loan_obj_rel_insert_input
  loan_id: String
  transaction_id: Int
  type: String
}

"""aggregate max on columns"""
type journal_max_fields {
  account: String
  amount: bigint
  booked_at: timestamptz
  correlation_id: String
  created_at: timestamptz
  created_by: String
  direction: journal_direction
  id: Int
  loan_id: String
  transaction_id: Int
  type: String
}

"""
order by max() on columns of table "journal"
"""
input journal_max_order_by {
  account: order_by
  amount: order_by
  booked_at: order_by
  correlation_id: order_by
  created_at: order_by
  created_by: order_by
  direction: order_by
  id: order_by
  loan_id: order_by
  transaction_id: order_by
  type: order_by
}

"""aggregate min on columns"""
type journal_min_fields {
  account: String
  amount: bigint
  booked_at: timestamptz
  correlation_id: String
  created_at: timestamptz
  created_by: String
  direction: journal_direction
  id: Int
  loan_id: String
  transaction_id: Int
  type: String
}

"""
order by min() on columns of table "journal"
"""
input journal_min_order_by {
  account: order_by
  amount: order_by
  booked_at: order_by
  correlation_id: order_by
  created_at: order_by
  created_by: order_by
  direction: order_by
  id: order_by
  loan_id: order_by
  transaction_id: order_by
  type: order_by
}

"""
response of any mutation on the table "journal"
"""
type journal_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [journal!]!
}

"""
on_conflict condition type for table "journal"
"""
input journal_on_conflict {
  constraint: journal_constraint!
  update_columns: [journal_update_column!]! = []
  where: journal_bool_exp
}

"""Ordering options when selecting data from "journal"."""
input journal_order_by {
  account: order_by
  amount: order_by
  booked_at: order_by
  correlation_id: order_by
  created_at: order_by
  created_by: order_by
  direction: order_by
  id: order_by
  loan: loan_order_by
  loan_id: order_by
  transaction_id: order_by
  type: order_by
}

"""primary key columns input for table: journal"""
input journal_pk_columns_input {
  id: Int!
}

"""
select columns of table "journal"
"""
enum journal_select_column {
  """column name"""
  account

  """column name"""
  amount

  """column name"""
  booked_at

  """column name"""
  correlation_id

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  direction

  """column name"""
  id

  """column name"""
  loan_id

  """column name"""
  transaction_id

  """column name"""
  type
}

"""
input type for updating data in table "journal"
"""
input journal_set_input {
  account: String
  amount: bigint
  booked_at: timestamptz
  correlation_id: String
  created_at: timestamptz
  created_by: String
  direction: journal_direction
  id: Int
  loan_id: String
  transaction_id: Int
  type: String
}

"""aggregate stddev on columns"""
type journal_stddev_fields {
  amount: Float
  id: Float
  transaction_id: Float
}

"""
order by stddev() on columns of table "journal"
"""
input journal_stddev_order_by {
  amount: order_by
  id: order_by
  transaction_id: order_by
}

"""aggregate stddev_pop on columns"""
type journal_stddev_pop_fields {
  amount: Float
  id: Float
  transaction_id: Float
}

"""
order by stddev_pop() on columns of table "journal"
"""
input journal_stddev_pop_order_by {
  amount: order_by
  id: order_by
  transaction_id: order_by
}

"""aggregate stddev_samp on columns"""
type journal_stddev_samp_fields {
  amount: Float
  id: Float
  transaction_id: Float
}

"""
order by stddev_samp() on columns of table "journal"
"""
input journal_stddev_samp_order_by {
  amount: order_by
  id: order_by
  transaction_id: order_by
}

"""
Streaming cursor of the table "journal"
"""
input journal_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: journal_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input journal_stream_cursor_value_input {
  account: String
  amount: bigint
  booked_at: timestamptz
  correlation_id: String
  created_at: timestamptz
  created_by: String
  direction: journal_direction
  id: Int
  loan_id: String
  transaction_id: Int
  type: String
}

"""aggregate sum on columns"""
type journal_sum_fields {
  amount: bigint
  id: Int
  transaction_id: Int
}

"""
order by sum() on columns of table "journal"
"""
input journal_sum_order_by {
  amount: order_by
  id: order_by
  transaction_id: order_by
}

"""
update columns of table "journal"
"""
enum journal_update_column {
  """column name"""
  account

  """column name"""
  amount

  """column name"""
  booked_at

  """column name"""
  correlation_id

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  direction

  """column name"""
  id

  """column name"""
  loan_id

  """column name"""
  transaction_id

  """column name"""
  type
}

input journal_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: journal_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: journal_set_input

  """filter the rows which have to be updated"""
  where: journal_bool_exp!
}

"""aggregate var_pop on columns"""
type journal_var_pop_fields {
  amount: Float
  id: Float
  transaction_id: Float
}

"""
order by var_pop() on columns of table "journal"
"""
input journal_var_pop_order_by {
  amount: order_by
  id: order_by
  transaction_id: order_by
}

"""aggregate var_samp on columns"""
type journal_var_samp_fields {
  amount: Float
  id: Float
  transaction_id: Float
}

"""
order by var_samp() on columns of table "journal"
"""
input journal_var_samp_order_by {
  amount: order_by
  id: order_by
  transaction_id: order_by
}

"""aggregate variance on columns"""
type journal_variance_fields {
  amount: Float
  id: Float
  transaction_id: Float
}

"""
order by variance() on columns of table "journal"
"""
input journal_variance_order_by {
  amount: order_by
  id: order_by
  transaction_id: order_by
}

"""
columns and relationships of "journal_voucher_entries"
"""
type journal_voucher_entries {
  correlation_id: String
  created_at: timestamptz!
  created_by: String!
  journal_entry_id: Int
  journal_voucher_id: String
  updated_at: timestamptz
  updated_by: String
}

"""
aggregated selection of "journal_voucher_entries"
"""
type journal_voucher_entries_aggregate {
  aggregate: journal_voucher_entries_aggregate_fields
  nodes: [journal_voucher_entries!]!
}

"""
aggregate fields of "journal_voucher_entries"
"""
type journal_voucher_entries_aggregate_fields {
  avg: journal_voucher_entries_avg_fields
  count(columns: [journal_voucher_entries_select_column!], distinct: Boolean): Int!
  max: journal_voucher_entries_max_fields
  min: journal_voucher_entries_min_fields
  stddev: journal_voucher_entries_stddev_fields
  stddev_pop: journal_voucher_entries_stddev_pop_fields
  stddev_samp: journal_voucher_entries_stddev_samp_fields
  sum: journal_voucher_entries_sum_fields
  var_pop: journal_voucher_entries_var_pop_fields
  var_samp: journal_voucher_entries_var_samp_fields
  variance: journal_voucher_entries_variance_fields
}

"""aggregate avg on columns"""
type journal_voucher_entries_avg_fields {
  journal_entry_id: Float
}

"""
Boolean expression to filter rows from the table "journal_voucher_entries". All fields are combined with a logical 'AND'.
"""
input journal_voucher_entries_bool_exp {
  _and: [journal_voucher_entries_bool_exp!]
  _not: journal_voucher_entries_bool_exp
  _or: [journal_voucher_entries_bool_exp!]
  correlation_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by: String_comparison_exp
  journal_entry_id: Int_comparison_exp
  journal_voucher_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  updated_by: String_comparison_exp
}

"""
unique or primary key constraints on table "journal_voucher_entries"
"""
enum journal_voucher_entries_constraint {
  """
  unique or primary key constraint on columns "journal_entry_id"
  """
  journal_voucher_entries_journal_entry_id_key
}

"""
input type for incrementing numeric columns in table "journal_voucher_entries"
"""
input journal_voucher_entries_inc_input {
  journal_entry_id: Int
}

"""
input type for inserting data into table "journal_voucher_entries"
"""
input journal_voucher_entries_insert_input {
  correlation_id: String
  created_at: timestamptz
  created_by: String
  journal_entry_id: Int
  journal_voucher_id: String
  updated_at: timestamptz
  updated_by: String
}

"""aggregate max on columns"""
type journal_voucher_entries_max_fields {
  correlation_id: String
  created_at: timestamptz
  created_by: String
  journal_entry_id: Int
  journal_voucher_id: String
  updated_at: timestamptz
  updated_by: String
}

"""aggregate min on columns"""
type journal_voucher_entries_min_fields {
  correlation_id: String
  created_at: timestamptz
  created_by: String
  journal_entry_id: Int
  journal_voucher_id: String
  updated_at: timestamptz
  updated_by: String
}

"""
response of any mutation on the table "journal_voucher_entries"
"""
type journal_voucher_entries_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [journal_voucher_entries!]!
}

"""
on_conflict condition type for table "journal_voucher_entries"
"""
input journal_voucher_entries_on_conflict {
  constraint: journal_voucher_entries_constraint!
  update_columns: [journal_voucher_entries_update_column!]! = []
  where: journal_voucher_entries_bool_exp
}

"""Ordering options when selecting data from "journal_voucher_entries"."""
input journal_voucher_entries_order_by {
  correlation_id: order_by
  created_at: order_by
  created_by: order_by
  journal_entry_id: order_by
  journal_voucher_id: order_by
  updated_at: order_by
  updated_by: order_by
}

"""
select columns of table "journal_voucher_entries"
"""
enum journal_voucher_entries_select_column {
  """column name"""
  correlation_id

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  journal_entry_id

  """column name"""
  journal_voucher_id

  """column name"""
  updated_at

  """column name"""
  updated_by
}

"""
input type for updating data in table "journal_voucher_entries"
"""
input journal_voucher_entries_set_input {
  correlation_id: String
  created_at: timestamptz
  created_by: String
  journal_entry_id: Int
  journal_voucher_id: String
  updated_at: timestamptz
  updated_by: String
}

"""aggregate stddev on columns"""
type journal_voucher_entries_stddev_fields {
  journal_entry_id: Float
}

"""aggregate stddev_pop on columns"""
type journal_voucher_entries_stddev_pop_fields {
  journal_entry_id: Float
}

"""aggregate stddev_samp on columns"""
type journal_voucher_entries_stddev_samp_fields {
  journal_entry_id: Float
}

"""
Streaming cursor of the table "journal_voucher_entries"
"""
input journal_voucher_entries_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: journal_voucher_entries_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input journal_voucher_entries_stream_cursor_value_input {
  correlation_id: String
  created_at: timestamptz
  created_by: String
  journal_entry_id: Int
  journal_voucher_id: String
  updated_at: timestamptz
  updated_by: String
}

"""aggregate sum on columns"""
type journal_voucher_entries_sum_fields {
  journal_entry_id: Int
}

"""
update columns of table "journal_voucher_entries"
"""
enum journal_voucher_entries_update_column {
  """column name"""
  correlation_id

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  journal_entry_id

  """column name"""
  journal_voucher_id

  """column name"""
  updated_at

  """column name"""
  updated_by
}

input journal_voucher_entries_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: journal_voucher_entries_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: journal_voucher_entries_set_input

  """filter the rows which have to be updated"""
  where: journal_voucher_entries_bool_exp!
}

"""aggregate var_pop on columns"""
type journal_voucher_entries_var_pop_fields {
  journal_entry_id: Float
}

"""aggregate var_samp on columns"""
type journal_voucher_entries_var_samp_fields {
  journal_entry_id: Float
}

"""aggregate variance on columns"""
type journal_voucher_entries_variance_fields {
  journal_entry_id: Float
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "keto_relation_tuples"
"""
type keto_relation_tuples {
  commit_time: timestamp!
  namespace: String!
  nid: uuid!
  object: uuid!
  relation: String!
  shard_id: uuid!
  subject_id: uuid
  subject_set_namespace: String
  subject_set_object: uuid
  subject_set_relation: String
}

"""
aggregated selection of "keto_relation_tuples"
"""
type keto_relation_tuples_aggregate {
  aggregate: keto_relation_tuples_aggregate_fields
  nodes: [keto_relation_tuples!]!
}

"""
aggregate fields of "keto_relation_tuples"
"""
type keto_relation_tuples_aggregate_fields {
  count(columns: [keto_relation_tuples_select_column!], distinct: Boolean): Int!
  max: keto_relation_tuples_max_fields
  min: keto_relation_tuples_min_fields
}

"""
Boolean expression to filter rows from the table "keto_relation_tuples". All fields are combined with a logical 'AND'.
"""
input keto_relation_tuples_bool_exp {
  _and: [keto_relation_tuples_bool_exp!]
  _not: keto_relation_tuples_bool_exp
  _or: [keto_relation_tuples_bool_exp!]
  commit_time: timestamp_comparison_exp
  namespace: String_comparison_exp
  nid: uuid_comparison_exp
  object: uuid_comparison_exp
  relation: String_comparison_exp
  shard_id: uuid_comparison_exp
  subject_id: uuid_comparison_exp
  subject_set_namespace: String_comparison_exp
  subject_set_object: uuid_comparison_exp
  subject_set_relation: String_comparison_exp
}

"""
unique or primary key constraints on table "keto_relation_tuples"
"""
enum keto_relation_tuples_constraint {
  """
  unique or primary key constraint on columns "nid", "shard_id"
  """
  keto_relation_tuples_uuid_pkey
}

"""
input type for inserting data into table "keto_relation_tuples"
"""
input keto_relation_tuples_insert_input {
  commit_time: timestamp
  namespace: String
  nid: uuid
  object: uuid
  relation: String
  shard_id: uuid
  subject_id: uuid
  subject_set_namespace: String
  subject_set_object: uuid
  subject_set_relation: String
}

"""aggregate max on columns"""
type keto_relation_tuples_max_fields {
  commit_time: timestamp
  namespace: String
  nid: uuid
  object: uuid
  relation: String
  shard_id: uuid
  subject_id: uuid
  subject_set_namespace: String
  subject_set_object: uuid
  subject_set_relation: String
}

"""aggregate min on columns"""
type keto_relation_tuples_min_fields {
  commit_time: timestamp
  namespace: String
  nid: uuid
  object: uuid
  relation: String
  shard_id: uuid
  subject_id: uuid
  subject_set_namespace: String
  subject_set_object: uuid
  subject_set_relation: String
}

"""
response of any mutation on the table "keto_relation_tuples"
"""
type keto_relation_tuples_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [keto_relation_tuples!]!
}

"""
on_conflict condition type for table "keto_relation_tuples"
"""
input keto_relation_tuples_on_conflict {
  constraint: keto_relation_tuples_constraint!
  update_columns: [keto_relation_tuples_update_column!]! = []
  where: keto_relation_tuples_bool_exp
}

"""Ordering options when selecting data from "keto_relation_tuples"."""
input keto_relation_tuples_order_by {
  commit_time: order_by
  namespace: order_by
  nid: order_by
  object: order_by
  relation: order_by
  shard_id: order_by
  subject_id: order_by
  subject_set_namespace: order_by
  subject_set_object: order_by
  subject_set_relation: order_by
}

"""primary key columns input for table: keto_relation_tuples"""
input keto_relation_tuples_pk_columns_input {
  nid: uuid!
  shard_id: uuid!
}

"""
select columns of table "keto_relation_tuples"
"""
enum keto_relation_tuples_select_column {
  """column name"""
  commit_time

  """column name"""
  namespace

  """column name"""
  nid

  """column name"""
  object

  """column name"""
  relation

  """column name"""
  shard_id

  """column name"""
  subject_id

  """column name"""
  subject_set_namespace

  """column name"""
  subject_set_object

  """column name"""
  subject_set_relation
}

"""
input type for updating data in table "keto_relation_tuples"
"""
input keto_relation_tuples_set_input {
  commit_time: timestamp
  namespace: String
  nid: uuid
  object: uuid
  relation: String
  shard_id: uuid
  subject_id: uuid
  subject_set_namespace: String
  subject_set_object: uuid
  subject_set_relation: String
}

"""
Streaming cursor of the table "keto_relation_tuples"
"""
input keto_relation_tuples_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: keto_relation_tuples_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input keto_relation_tuples_stream_cursor_value_input {
  commit_time: timestamp
  namespace: String
  nid: uuid
  object: uuid
  relation: String
  shard_id: uuid
  subject_id: uuid
  subject_set_namespace: String
  subject_set_object: uuid
  subject_set_relation: String
}

"""
update columns of table "keto_relation_tuples"
"""
enum keto_relation_tuples_update_column {
  """column name"""
  commit_time

  """column name"""
  namespace

  """column name"""
  nid

  """column name"""
  object

  """column name"""
  relation

  """column name"""
  shard_id

  """column name"""
  subject_id

  """column name"""
  subject_set_namespace

  """column name"""
  subject_set_object

  """column name"""
  subject_set_relation
}

input keto_relation_tuples_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: keto_relation_tuples_set_input

  """filter the rows which have to be updated"""
  where: keto_relation_tuples_bool_exp!
}

"""
columns and relationships of "keto_uuid_mappings"
"""
type keto_uuid_mappings {
  id: uuid!
  string_representation: String!
}

"""
aggregated selection of "keto_uuid_mappings"
"""
type keto_uuid_mappings_aggregate {
  aggregate: keto_uuid_mappings_aggregate_fields
  nodes: [keto_uuid_mappings!]!
}

"""
aggregate fields of "keto_uuid_mappings"
"""
type keto_uuid_mappings_aggregate_fields {
  count(columns: [keto_uuid_mappings_select_column!], distinct: Boolean): Int!
  max: keto_uuid_mappings_max_fields
  min: keto_uuid_mappings_min_fields
}

"""
Boolean expression to filter rows from the table "keto_uuid_mappings". All fields are combined with a logical 'AND'.
"""
input keto_uuid_mappings_bool_exp {
  _and: [keto_uuid_mappings_bool_exp!]
  _not: keto_uuid_mappings_bool_exp
  _or: [keto_uuid_mappings_bool_exp!]
  id: uuid_comparison_exp
  string_representation: String_comparison_exp
}

"""
unique or primary key constraints on table "keto_uuid_mappings"
"""
enum keto_uuid_mappings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  keto_uuid_mappings_pkey
}

"""
input type for inserting data into table "keto_uuid_mappings"
"""
input keto_uuid_mappings_insert_input {
  id: uuid
  string_representation: String
}

"""aggregate max on columns"""
type keto_uuid_mappings_max_fields {
  id: uuid
  string_representation: String
}

"""aggregate min on columns"""
type keto_uuid_mappings_min_fields {
  id: uuid
  string_representation: String
}

"""
response of any mutation on the table "keto_uuid_mappings"
"""
type keto_uuid_mappings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [keto_uuid_mappings!]!
}

"""
on_conflict condition type for table "keto_uuid_mappings"
"""
input keto_uuid_mappings_on_conflict {
  constraint: keto_uuid_mappings_constraint!
  update_columns: [keto_uuid_mappings_update_column!]! = []
  where: keto_uuid_mappings_bool_exp
}

"""Ordering options when selecting data from "keto_uuid_mappings"."""
input keto_uuid_mappings_order_by {
  id: order_by
  string_representation: order_by
}

"""primary key columns input for table: keto_uuid_mappings"""
input keto_uuid_mappings_pk_columns_input {
  id: uuid!
}

"""
select columns of table "keto_uuid_mappings"
"""
enum keto_uuid_mappings_select_column {
  """column name"""
  id

  """column name"""
  string_representation
}

"""
input type for updating data in table "keto_uuid_mappings"
"""
input keto_uuid_mappings_set_input {
  id: uuid
  string_representation: String
}

"""
Streaming cursor of the table "keto_uuid_mappings"
"""
input keto_uuid_mappings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: keto_uuid_mappings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input keto_uuid_mappings_stream_cursor_value_input {
  id: uuid
  string_representation: String
}

"""
update columns of table "keto_uuid_mappings"
"""
enum keto_uuid_mappings_update_column {
  """column name"""
  id

  """column name"""
  string_representation
}

input keto_uuid_mappings_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: keto_uuid_mappings_set_input

  """filter the rows which have to be updated"""
  where: keto_uuid_mappings_bool_exp!
}

"""
columns and relationships of "loan"
"""
type loan {
  booked_at: timestamptz!
  commercial_offer_id: String
  consumer: consumers
  consumer_id: String!
  correlation_id: String!
  created_at: timestamptz!
  created_by: String!
  financial_product_key: String!
  financial_product_version: String!
  id: String!

  """An array relationship"""
  journals(
    """distinct select on columns"""
    distinct_on: [journal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [journal_order_by!]

    """filter the rows returned"""
    where: journal_bool_exp
  ): [journal!]!

  """An aggregate relationship"""
  journals_aggregate(
    """distinct select on columns"""
    distinct_on: [journal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [journal_order_by!]

    """filter the rows returned"""
    where: journal_bool_exp
  ): journal_aggregate!

  """An array relationship"""
  loan_schedules(
    """distinct select on columns"""
    distinct_on: [loan_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_schedule_order_by!]

    """filter the rows returned"""
    where: loan_schedule_bool_exp
  ): [loan_schedule!]!

  """An aggregate relationship"""
  loan_schedules_aggregate(
    """distinct select on columns"""
    distinct_on: [loan_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_schedule_order_by!]

    """filter the rows returned"""
    where: loan_schedule_bool_exp
  ): loan_schedule_aggregate!

  """An array relationship"""
  loan_statuses(
    """distinct select on columns"""
    distinct_on: [loan_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_status_order_by!]

    """filter the rows returned"""
    where: loan_status_bool_exp
  ): [loan_status!]!

  """An aggregate relationship"""
  loan_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [loan_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_status_order_by!]

    """filter the rows returned"""
    where: loan_status_bool_exp
  ): loan_status_aggregate!
  merchant_global_id: String!

  """An object relationship"""
  merchant_transaction_slip: merchant_transaction_slip
  new_loan_id: String
}

"""
aggregated selection of "loan"
"""
type loan_aggregate {
  aggregate: loan_aggregate_fields
  nodes: [loan!]!
}

"""
aggregate fields of "loan"
"""
type loan_aggregate_fields {
  count(columns: [loan_select_column!], distinct: Boolean): Int!
  max: loan_max_fields
  min: loan_min_fields
}

"""
Boolean expression to filter rows from the table "loan". All fields are combined with a logical 'AND'.
"""
input loan_bool_exp {
  _and: [loan_bool_exp!]
  _not: loan_bool_exp
  _or: [loan_bool_exp!]
  booked_at: timestamptz_comparison_exp
  commercial_offer_id: String_comparison_exp
  consumer_id: String_comparison_exp
  correlation_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by: String_comparison_exp
  financial_product_key: String_comparison_exp
  financial_product_version: String_comparison_exp
  id: String_comparison_exp
  journals: journal_bool_exp
  journals_aggregate: journal_aggregate_bool_exp
  loan_schedules: loan_schedule_bool_exp
  loan_schedules_aggregate: loan_schedule_aggregate_bool_exp
  loan_statuses: loan_status_bool_exp
  loan_statuses_aggregate: loan_status_aggregate_bool_exp
  merchant_global_id: String_comparison_exp
  merchant_transaction_slip: merchant_transaction_slip_bool_exp
  new_loan_id: String_comparison_exp
}

"""
unique or primary key constraints on table "loan"
"""
enum loan_constraint {
  """
  unique or primary key constraint on columns "new_loan_id"
  """
  loan_new_loan_id_key

  """
  unique or primary key constraint on columns "id"
  """
  loan_pkey
}

"""
input type for inserting data into table "loan"
"""
input loan_insert_input {
  booked_at: timestamptz
  commercial_offer_id: String
  consumer_id: String
  correlation_id: String
  created_at: timestamptz
  created_by: String
  financial_product_key: String
  financial_product_version: String
  id: String
  journals: journal_arr_rel_insert_input
  loan_schedules: loan_schedule_arr_rel_insert_input
  loan_statuses: loan_status_arr_rel_insert_input
  merchant_global_id: String
  merchant_transaction_slip: merchant_transaction_slip_obj_rel_insert_input
  new_loan_id: String
}

"""aggregate max on columns"""
type loan_max_fields {
  booked_at: timestamptz
  commercial_offer_id: String
  consumer_id: String
  correlation_id: String
  created_at: timestamptz
  created_by: String
  financial_product_key: String
  financial_product_version: String
  id: String
  merchant_global_id: String
  new_loan_id: String
}

"""aggregate min on columns"""
type loan_min_fields {
  booked_at: timestamptz
  commercial_offer_id: String
  consumer_id: String
  correlation_id: String
  created_at: timestamptz
  created_by: String
  financial_product_key: String
  financial_product_version: String
  id: String
  merchant_global_id: String
  new_loan_id: String
}

"""
response of any mutation on the table "loan"
"""
type loan_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [loan!]!
}

"""
input type for inserting object relation for remote table "loan"
"""
input loan_obj_rel_insert_input {
  data: loan_insert_input!

  """upsert condition"""
  on_conflict: loan_on_conflict
}

"""
on_conflict condition type for table "loan"
"""
input loan_on_conflict {
  constraint: loan_constraint!
  update_columns: [loan_update_column!]! = []
  where: loan_bool_exp
}

"""Ordering options when selecting data from "loan"."""
input loan_order_by {
  booked_at: order_by
  commercial_offer_id: order_by
  consumer_id: order_by
  correlation_id: order_by
  created_at: order_by
  created_by: order_by
  financial_product_key: order_by
  financial_product_version: order_by
  id: order_by
  journals_aggregate: journal_aggregate_order_by
  loan_schedules_aggregate: loan_schedule_aggregate_order_by
  loan_statuses_aggregate: loan_status_aggregate_order_by
  merchant_global_id: order_by
  merchant_transaction_slip: merchant_transaction_slip_order_by
  new_loan_id: order_by
}

"""primary key columns input for table: loan"""
input loan_pk_columns_input {
  id: String!
}

"""
columns and relationships of "loan_schedule"
"""
type loan_schedule {
  created_at: timestamptz!
  created_by: String!
  due_date: timestamptz!
  due_interest: bigint!
  due_late_fee: bigint
  due_principal: bigint!
  grace_period_end_date: timestamptz!
  id: Int!
  is_cancelled: Boolean!

  """An object relationship"""
  loan: loan!
  loan_balance: bigint!
  loan_id: String!
  paid_date: timestamptz
  paid_interest: bigint
  paid_late_fee: bigint
  paid_principal: bigint
  ref_id: String
  updated_at: timestamptz
  updated_by: String
}

"""
aggregated selection of "loan_schedule"
"""
type loan_schedule_aggregate {
  aggregate: loan_schedule_aggregate_fields
  nodes: [loan_schedule!]!
}

input loan_schedule_aggregate_bool_exp {
  bool_and: loan_schedule_aggregate_bool_exp_bool_and
  bool_or: loan_schedule_aggregate_bool_exp_bool_or
  count: loan_schedule_aggregate_bool_exp_count
}

input loan_schedule_aggregate_bool_exp_bool_and {
  arguments: loan_schedule_select_column_loan_schedule_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: loan_schedule_bool_exp
  predicate: Boolean_comparison_exp!
}

input loan_schedule_aggregate_bool_exp_bool_or {
  arguments: loan_schedule_select_column_loan_schedule_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: loan_schedule_bool_exp
  predicate: Boolean_comparison_exp!
}

input loan_schedule_aggregate_bool_exp_count {
  arguments: [loan_schedule_select_column!]
  distinct: Boolean
  filter: loan_schedule_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "loan_schedule"
"""
type loan_schedule_aggregate_fields {
  avg: loan_schedule_avg_fields
  count(columns: [loan_schedule_select_column!], distinct: Boolean): Int!
  max: loan_schedule_max_fields
  min: loan_schedule_min_fields
  stddev: loan_schedule_stddev_fields
  stddev_pop: loan_schedule_stddev_pop_fields
  stddev_samp: loan_schedule_stddev_samp_fields
  sum: loan_schedule_sum_fields
  var_pop: loan_schedule_var_pop_fields
  var_samp: loan_schedule_var_samp_fields
  variance: loan_schedule_variance_fields
}

"""
order by aggregate values of table "loan_schedule"
"""
input loan_schedule_aggregate_order_by {
  avg: loan_schedule_avg_order_by
  count: order_by
  max: loan_schedule_max_order_by
  min: loan_schedule_min_order_by
  stddev: loan_schedule_stddev_order_by
  stddev_pop: loan_schedule_stddev_pop_order_by
  stddev_samp: loan_schedule_stddev_samp_order_by
  sum: loan_schedule_sum_order_by
  var_pop: loan_schedule_var_pop_order_by
  var_samp: loan_schedule_var_samp_order_by
  variance: loan_schedule_variance_order_by
}

"""
input type for inserting array relation for remote table "loan_schedule"
"""
input loan_schedule_arr_rel_insert_input {
  data: [loan_schedule_insert_input!]!

  """upsert condition"""
  on_conflict: loan_schedule_on_conflict
}

"""aggregate avg on columns"""
type loan_schedule_avg_fields {
  due_interest: Float
  due_late_fee: Float
  due_principal: Float
  id: Float
  loan_balance: Float
  paid_interest: Float
  paid_late_fee: Float
  paid_principal: Float
}

"""
order by avg() on columns of table "loan_schedule"
"""
input loan_schedule_avg_order_by {
  due_interest: order_by
  due_late_fee: order_by
  due_principal: order_by
  id: order_by
  loan_balance: order_by
  paid_interest: order_by
  paid_late_fee: order_by
  paid_principal: order_by
}

"""
Boolean expression to filter rows from the table "loan_schedule". All fields are combined with a logical 'AND'.
"""
input loan_schedule_bool_exp {
  _and: [loan_schedule_bool_exp!]
  _not: loan_schedule_bool_exp
  _or: [loan_schedule_bool_exp!]
  created_at: timestamptz_comparison_exp
  created_by: String_comparison_exp
  due_date: timestamptz_comparison_exp
  due_interest: bigint_comparison_exp
  due_late_fee: bigint_comparison_exp
  due_principal: bigint_comparison_exp
  grace_period_end_date: timestamptz_comparison_exp
  id: Int_comparison_exp
  is_cancelled: Boolean_comparison_exp
  loan: loan_bool_exp
  loan_balance: bigint_comparison_exp
  loan_id: String_comparison_exp
  paid_date: timestamptz_comparison_exp
  paid_interest: bigint_comparison_exp
  paid_late_fee: bigint_comparison_exp
  paid_principal: bigint_comparison_exp
  ref_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  updated_by: String_comparison_exp
}

"""
unique or primary key constraints on table "loan_schedule"
"""
enum loan_schedule_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  loan_schedule_pkey
}

"""
input type for incrementing numeric columns in table "loan_schedule"
"""
input loan_schedule_inc_input {
  due_interest: bigint
  due_late_fee: bigint
  due_principal: bigint
  id: Int
  loan_balance: bigint
  paid_interest: bigint
  paid_late_fee: bigint
  paid_principal: bigint
}

"""
input type for inserting data into table "loan_schedule"
"""
input loan_schedule_insert_input {
  created_at: timestamptz
  created_by: String
  due_date: timestamptz
  due_interest: bigint
  due_late_fee: bigint
  due_principal: bigint
  grace_period_end_date: timestamptz
  id: Int
  is_cancelled: Boolean
  loan: loan_obj_rel_insert_input
  loan_balance: bigint
  loan_id: String
  paid_date: timestamptz
  paid_interest: bigint
  paid_late_fee: bigint
  paid_principal: bigint
  ref_id: String
  updated_at: timestamptz
  updated_by: String
}

"""aggregate max on columns"""
type loan_schedule_max_fields {
  created_at: timestamptz
  created_by: String
  due_date: timestamptz
  due_interest: bigint
  due_late_fee: bigint
  due_principal: bigint
  grace_period_end_date: timestamptz
  id: Int
  loan_balance: bigint
  loan_id: String
  paid_date: timestamptz
  paid_interest: bigint
  paid_late_fee: bigint
  paid_principal: bigint
  ref_id: String
  updated_at: timestamptz
  updated_by: String
}

"""
order by max() on columns of table "loan_schedule"
"""
input loan_schedule_max_order_by {
  created_at: order_by
  created_by: order_by
  due_date: order_by
  due_interest: order_by
  due_late_fee: order_by
  due_principal: order_by
  grace_period_end_date: order_by
  id: order_by
  loan_balance: order_by
  loan_id: order_by
  paid_date: order_by
  paid_interest: order_by
  paid_late_fee: order_by
  paid_principal: order_by
  ref_id: order_by
  updated_at: order_by
  updated_by: order_by
}

"""aggregate min on columns"""
type loan_schedule_min_fields {
  created_at: timestamptz
  created_by: String
  due_date: timestamptz
  due_interest: bigint
  due_late_fee: bigint
  due_principal: bigint
  grace_period_end_date: timestamptz
  id: Int
  loan_balance: bigint
  loan_id: String
  paid_date: timestamptz
  paid_interest: bigint
  paid_late_fee: bigint
  paid_principal: bigint
  ref_id: String
  updated_at: timestamptz
  updated_by: String
}

"""
order by min() on columns of table "loan_schedule"
"""
input loan_schedule_min_order_by {
  created_at: order_by
  created_by: order_by
  due_date: order_by
  due_interest: order_by
  due_late_fee: order_by
  due_principal: order_by
  grace_period_end_date: order_by
  id: order_by
  loan_balance: order_by
  loan_id: order_by
  paid_date: order_by
  paid_interest: order_by
  paid_late_fee: order_by
  paid_principal: order_by
  ref_id: order_by
  updated_at: order_by
  updated_by: order_by
}

"""
response of any mutation on the table "loan_schedule"
"""
type loan_schedule_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [loan_schedule!]!
}

"""
on_conflict condition type for table "loan_schedule"
"""
input loan_schedule_on_conflict {
  constraint: loan_schedule_constraint!
  update_columns: [loan_schedule_update_column!]! = []
  where: loan_schedule_bool_exp
}

"""Ordering options when selecting data from "loan_schedule"."""
input loan_schedule_order_by {
  created_at: order_by
  created_by: order_by
  due_date: order_by
  due_interest: order_by
  due_late_fee: order_by
  due_principal: order_by
  grace_period_end_date: order_by
  id: order_by
  is_cancelled: order_by
  loan: loan_order_by
  loan_balance: order_by
  loan_id: order_by
  paid_date: order_by
  paid_interest: order_by
  paid_late_fee: order_by
  paid_principal: order_by
  ref_id: order_by
  updated_at: order_by
  updated_by: order_by
}

"""primary key columns input for table: loan_schedule"""
input loan_schedule_pk_columns_input {
  id: Int!
}

"""
select columns of table "loan_schedule"
"""
enum loan_schedule_select_column {
  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  due_date

  """column name"""
  due_interest

  """column name"""
  due_late_fee

  """column name"""
  due_principal

  """column name"""
  grace_period_end_date

  """column name"""
  id

  """column name"""
  is_cancelled

  """column name"""
  loan_balance

  """column name"""
  loan_id

  """column name"""
  paid_date

  """column name"""
  paid_interest

  """column name"""
  paid_late_fee

  """column name"""
  paid_principal

  """column name"""
  ref_id

  """column name"""
  updated_at

  """column name"""
  updated_by
}

"""
select "loan_schedule_aggregate_bool_exp_bool_and_arguments_columns" columns of table "loan_schedule"
"""
enum loan_schedule_select_column_loan_schedule_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_cancelled
}

"""
select "loan_schedule_aggregate_bool_exp_bool_or_arguments_columns" columns of table "loan_schedule"
"""
enum loan_schedule_select_column_loan_schedule_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_cancelled
}

"""
input type for updating data in table "loan_schedule"
"""
input loan_schedule_set_input {
  created_at: timestamptz
  created_by: String
  due_date: timestamptz
  due_interest: bigint
  due_late_fee: bigint
  due_principal: bigint
  grace_period_end_date: timestamptz
  id: Int
  is_cancelled: Boolean
  loan_balance: bigint
  loan_id: String
  paid_date: timestamptz
  paid_interest: bigint
  paid_late_fee: bigint
  paid_principal: bigint
  ref_id: String
  updated_at: timestamptz
  updated_by: String
}

"""aggregate stddev on columns"""
type loan_schedule_stddev_fields {
  due_interest: Float
  due_late_fee: Float
  due_principal: Float
  id: Float
  loan_balance: Float
  paid_interest: Float
  paid_late_fee: Float
  paid_principal: Float
}

"""
order by stddev() on columns of table "loan_schedule"
"""
input loan_schedule_stddev_order_by {
  due_interest: order_by
  due_late_fee: order_by
  due_principal: order_by
  id: order_by
  loan_balance: order_by
  paid_interest: order_by
  paid_late_fee: order_by
  paid_principal: order_by
}

"""aggregate stddev_pop on columns"""
type loan_schedule_stddev_pop_fields {
  due_interest: Float
  due_late_fee: Float
  due_principal: Float
  id: Float
  loan_balance: Float
  paid_interest: Float
  paid_late_fee: Float
  paid_principal: Float
}

"""
order by stddev_pop() on columns of table "loan_schedule"
"""
input loan_schedule_stddev_pop_order_by {
  due_interest: order_by
  due_late_fee: order_by
  due_principal: order_by
  id: order_by
  loan_balance: order_by
  paid_interest: order_by
  paid_late_fee: order_by
  paid_principal: order_by
}

"""aggregate stddev_samp on columns"""
type loan_schedule_stddev_samp_fields {
  due_interest: Float
  due_late_fee: Float
  due_principal: Float
  id: Float
  loan_balance: Float
  paid_interest: Float
  paid_late_fee: Float
  paid_principal: Float
}

"""
order by stddev_samp() on columns of table "loan_schedule"
"""
input loan_schedule_stddev_samp_order_by {
  due_interest: order_by
  due_late_fee: order_by
  due_principal: order_by
  id: order_by
  loan_balance: order_by
  paid_interest: order_by
  paid_late_fee: order_by
  paid_principal: order_by
}

"""
Streaming cursor of the table "loan_schedule"
"""
input loan_schedule_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: loan_schedule_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input loan_schedule_stream_cursor_value_input {
  created_at: timestamptz
  created_by: String
  due_date: timestamptz
  due_interest: bigint
  due_late_fee: bigint
  due_principal: bigint
  grace_period_end_date: timestamptz
  id: Int
  is_cancelled: Boolean
  loan_balance: bigint
  loan_id: String
  paid_date: timestamptz
  paid_interest: bigint
  paid_late_fee: bigint
  paid_principal: bigint
  ref_id: String
  updated_at: timestamptz
  updated_by: String
}

"""aggregate sum on columns"""
type loan_schedule_sum_fields {
  due_interest: bigint
  due_late_fee: bigint
  due_principal: bigint
  id: Int
  loan_balance: bigint
  paid_interest: bigint
  paid_late_fee: bigint
  paid_principal: bigint
}

"""
order by sum() on columns of table "loan_schedule"
"""
input loan_schedule_sum_order_by {
  due_interest: order_by
  due_late_fee: order_by
  due_principal: order_by
  id: order_by
  loan_balance: order_by
  paid_interest: order_by
  paid_late_fee: order_by
  paid_principal: order_by
}

"""
update columns of table "loan_schedule"
"""
enum loan_schedule_update_column {
  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  due_date

  """column name"""
  due_interest

  """column name"""
  due_late_fee

  """column name"""
  due_principal

  """column name"""
  grace_period_end_date

  """column name"""
  id

  """column name"""
  is_cancelled

  """column name"""
  loan_balance

  """column name"""
  loan_id

  """column name"""
  paid_date

  """column name"""
  paid_interest

  """column name"""
  paid_late_fee

  """column name"""
  paid_principal

  """column name"""
  ref_id

  """column name"""
  updated_at

  """column name"""
  updated_by
}

input loan_schedule_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: loan_schedule_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: loan_schedule_set_input

  """filter the rows which have to be updated"""
  where: loan_schedule_bool_exp!
}

"""aggregate var_pop on columns"""
type loan_schedule_var_pop_fields {
  due_interest: Float
  due_late_fee: Float
  due_principal: Float
  id: Float
  loan_balance: Float
  paid_interest: Float
  paid_late_fee: Float
  paid_principal: Float
}

"""
order by var_pop() on columns of table "loan_schedule"
"""
input loan_schedule_var_pop_order_by {
  due_interest: order_by
  due_late_fee: order_by
  due_principal: order_by
  id: order_by
  loan_balance: order_by
  paid_interest: order_by
  paid_late_fee: order_by
  paid_principal: order_by
}

"""aggregate var_samp on columns"""
type loan_schedule_var_samp_fields {
  due_interest: Float
  due_late_fee: Float
  due_principal: Float
  id: Float
  loan_balance: Float
  paid_interest: Float
  paid_late_fee: Float
  paid_principal: Float
}

"""
order by var_samp() on columns of table "loan_schedule"
"""
input loan_schedule_var_samp_order_by {
  due_interest: order_by
  due_late_fee: order_by
  due_principal: order_by
  id: order_by
  loan_balance: order_by
  paid_interest: order_by
  paid_late_fee: order_by
  paid_principal: order_by
}

"""aggregate variance on columns"""
type loan_schedule_variance_fields {
  due_interest: Float
  due_late_fee: Float
  due_principal: Float
  id: Float
  loan_balance: Float
  paid_interest: Float
  paid_late_fee: Float
  paid_principal: Float
}

"""
order by variance() on columns of table "loan_schedule"
"""
input loan_schedule_variance_order_by {
  due_interest: order_by
  due_late_fee: order_by
  due_principal: order_by
  id: order_by
  loan_balance: order_by
  paid_interest: order_by
  paid_late_fee: order_by
  paid_principal: order_by
}

"""
select columns of table "loan"
"""
enum loan_select_column {
  """column name"""
  booked_at

  """column name"""
  commercial_offer_id

  """column name"""
  consumer_id

  """column name"""
  correlation_id

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  financial_product_key

  """column name"""
  financial_product_version

  """column name"""
  id

  """column name"""
  merchant_global_id

  """column name"""
  new_loan_id
}

"""
input type for updating data in table "loan"
"""
input loan_set_input {
  booked_at: timestamptz
  commercial_offer_id: String
  consumer_id: String
  correlation_id: String
  created_at: timestamptz
  created_by: String
  financial_product_key: String
  financial_product_version: String
  id: String
  merchant_global_id: String
  new_loan_id: String
}

"""
columns and relationships of "loan_status"
"""
type loan_status {
  created_at: timestamptz!

  """An object relationship"""
  loan: loan!
  loan_id: String!
  status: String!
}

"""
aggregated selection of "loan_status"
"""
type loan_status_aggregate {
  aggregate: loan_status_aggregate_fields
  nodes: [loan_status!]!
}

input loan_status_aggregate_bool_exp {
  count: loan_status_aggregate_bool_exp_count
}

input loan_status_aggregate_bool_exp_count {
  arguments: [loan_status_select_column!]
  distinct: Boolean
  filter: loan_status_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "loan_status"
"""
type loan_status_aggregate_fields {
  count(columns: [loan_status_select_column!], distinct: Boolean): Int!
  max: loan_status_max_fields
  min: loan_status_min_fields
}

"""
order by aggregate values of table "loan_status"
"""
input loan_status_aggregate_order_by {
  count: order_by
  max: loan_status_max_order_by
  min: loan_status_min_order_by
}

"""
input type for inserting array relation for remote table "loan_status"
"""
input loan_status_arr_rel_insert_input {
  data: [loan_status_insert_input!]!

  """upsert condition"""
  on_conflict: loan_status_on_conflict
}

"""
Boolean expression to filter rows from the table "loan_status". All fields are combined with a logical 'AND'.
"""
input loan_status_bool_exp {
  _and: [loan_status_bool_exp!]
  _not: loan_status_bool_exp
  _or: [loan_status_bool_exp!]
  created_at: timestamptz_comparison_exp
  loan: loan_bool_exp
  loan_id: String_comparison_exp
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "loan_status"
"""
enum loan_status_constraint {
  """
  unique or primary key constraint on columns "loan_id", "status"
  """
  pk_loan_status
}

"""
input type for inserting data into table "loan_status"
"""
input loan_status_insert_input {
  created_at: timestamptz
  loan: loan_obj_rel_insert_input
  loan_id: String
  status: String
}

"""aggregate max on columns"""
type loan_status_max_fields {
  created_at: timestamptz
  loan_id: String
  status: String
}

"""
order by max() on columns of table "loan_status"
"""
input loan_status_max_order_by {
  created_at: order_by
  loan_id: order_by
  status: order_by
}

"""aggregate min on columns"""
type loan_status_min_fields {
  created_at: timestamptz
  loan_id: String
  status: String
}

"""
order by min() on columns of table "loan_status"
"""
input loan_status_min_order_by {
  created_at: order_by
  loan_id: order_by
  status: order_by
}

"""
response of any mutation on the table "loan_status"
"""
type loan_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [loan_status!]!
}

"""
on_conflict condition type for table "loan_status"
"""
input loan_status_on_conflict {
  constraint: loan_status_constraint!
  update_columns: [loan_status_update_column!]! = []
  where: loan_status_bool_exp
}

"""Ordering options when selecting data from "loan_status"."""
input loan_status_order_by {
  created_at: order_by
  loan: loan_order_by
  loan_id: order_by
  status: order_by
}

"""primary key columns input for table: loan_status"""
input loan_status_pk_columns_input {
  loan_id: String!
  status: String!
}

"""
select columns of table "loan_status"
"""
enum loan_status_select_column {
  """column name"""
  created_at

  """column name"""
  loan_id

  """column name"""
  status
}

"""
input type for updating data in table "loan_status"
"""
input loan_status_set_input {
  created_at: timestamptz
  loan_id: String
  status: String
}

"""
Streaming cursor of the table "loan_status"
"""
input loan_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: loan_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input loan_status_stream_cursor_value_input {
  created_at: timestamptz
  loan_id: String
  status: String
}

"""
update columns of table "loan_status"
"""
enum loan_status_update_column {
  """column name"""
  created_at

  """column name"""
  loan_id

  """column name"""
  status
}

input loan_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: loan_status_set_input

  """filter the rows which have to be updated"""
  where: loan_status_bool_exp!
}

"""
Streaming cursor of the table "loan"
"""
input loan_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: loan_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input loan_stream_cursor_value_input {
  booked_at: timestamptz
  commercial_offer_id: String
  consumer_id: String
  correlation_id: String
  created_at: timestamptz
  created_by: String
  financial_product_key: String
  financial_product_version: String
  id: String
  merchant_global_id: String
  new_loan_id: String
}

"""
update columns of table "loan"
"""
enum loan_update_column {
  """column name"""
  booked_at

  """column name"""
  commercial_offer_id

  """column name"""
  consumer_id

  """column name"""
  correlation_id

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  financial_product_key

  """column name"""
  financial_product_version

  """column name"""
  id

  """column name"""
  merchant_global_id

  """column name"""
  new_loan_id
}

input loan_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: loan_set_input

  """filter the rows which have to be updated"""
  where: loan_bool_exp!
}

"""
columns and relationships of "merchant_payment"
"""
type merchant_payment {
  created_at: timestamptz!
  ga_posting_response(
    """JSON select path"""
    path: String
  ): json
  id: String!
  merchant: partner
  merchant_account_id: String!

  """An array relationship"""
  merchant_transaction_slips(
    """distinct select on columns"""
    distinct_on: [merchant_transaction_slip_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [merchant_transaction_slip_order_by!]

    """filter the rows returned"""
    where: merchant_transaction_slip_bool_exp
  ): [merchant_transaction_slip!]!

  """An aggregate relationship"""
  merchant_transaction_slips_aggregate(
    """distinct select on columns"""
    distinct_on: [merchant_transaction_slip_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [merchant_transaction_slip_order_by!]

    """filter the rows returned"""
    where: merchant_transaction_slip_bool_exp
  ): merchant_transaction_slip_aggregate!
  payable_currency: String!
  payable_units: bigint!
  serial_id: Int!
  status: String
  status_timestamp: date
  success_ga_posting: Boolean!
  transaction_date: timestamptz!
}

"""
aggregated selection of "merchant_payment"
"""
type merchant_payment_aggregate {
  aggregate: merchant_payment_aggregate_fields
  nodes: [merchant_payment!]!
}

"""
aggregate fields of "merchant_payment"
"""
type merchant_payment_aggregate_fields {
  avg: merchant_payment_avg_fields
  count(columns: [merchant_payment_select_column!], distinct: Boolean): Int!
  max: merchant_payment_max_fields
  min: merchant_payment_min_fields
  stddev: merchant_payment_stddev_fields
  stddev_pop: merchant_payment_stddev_pop_fields
  stddev_samp: merchant_payment_stddev_samp_fields
  sum: merchant_payment_sum_fields
  var_pop: merchant_payment_var_pop_fields
  var_samp: merchant_payment_var_samp_fields
  variance: merchant_payment_variance_fields
}

"""aggregate avg on columns"""
type merchant_payment_avg_fields {
  payable_units: Float
  serial_id: Float
}

"""
Boolean expression to filter rows from the table "merchant_payment". All fields are combined with a logical 'AND'.
"""
input merchant_payment_bool_exp {
  _and: [merchant_payment_bool_exp!]
  _not: merchant_payment_bool_exp
  _or: [merchant_payment_bool_exp!]
  created_at: timestamptz_comparison_exp
  ga_posting_response: json_comparison_exp
  id: String_comparison_exp
  merchant_account_id: String_comparison_exp
  merchant_transaction_slips: merchant_transaction_slip_bool_exp
  merchant_transaction_slips_aggregate: merchant_transaction_slip_aggregate_bool_exp
  payable_currency: String_comparison_exp
  payable_units: bigint_comparison_exp
  serial_id: Int_comparison_exp
  status: String_comparison_exp
  status_timestamp: date_comparison_exp
  success_ga_posting: Boolean_comparison_exp
  transaction_date: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "merchant_payment"
"""
enum merchant_payment_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  merchant_payment_pkey
}

"""
input type for incrementing numeric columns in table "merchant_payment"
"""
input merchant_payment_inc_input {
  payable_units: bigint
  serial_id: Int
}

"""
input type for inserting data into table "merchant_payment"
"""
input merchant_payment_insert_input {
  created_at: timestamptz
  ga_posting_response: json
  id: String
  merchant_account_id: String
  merchant_transaction_slips: merchant_transaction_slip_arr_rel_insert_input
  payable_currency: String
  payable_units: bigint
  serial_id: Int
  status: String
  status_timestamp: date
  success_ga_posting: Boolean
  transaction_date: timestamptz
}

"""aggregate max on columns"""
type merchant_payment_max_fields {
  created_at: timestamptz
  id: String
  merchant_account_id: String
  payable_currency: String
  payable_units: bigint
  serial_id: Int
  status: String
  status_timestamp: date
  transaction_date: timestamptz
}

"""aggregate min on columns"""
type merchant_payment_min_fields {
  created_at: timestamptz
  id: String
  merchant_account_id: String
  payable_currency: String
  payable_units: bigint
  serial_id: Int
  status: String
  status_timestamp: date
  transaction_date: timestamptz
}

"""
response of any mutation on the table "merchant_payment"
"""
type merchant_payment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [merchant_payment!]!
}

"""
input type for inserting object relation for remote table "merchant_payment"
"""
input merchant_payment_obj_rel_insert_input {
  data: merchant_payment_insert_input!

  """upsert condition"""
  on_conflict: merchant_payment_on_conflict
}

"""
on_conflict condition type for table "merchant_payment"
"""
input merchant_payment_on_conflict {
  constraint: merchant_payment_constraint!
  update_columns: [merchant_payment_update_column!]! = []
  where: merchant_payment_bool_exp
}

"""Ordering options when selecting data from "merchant_payment"."""
input merchant_payment_order_by {
  created_at: order_by
  ga_posting_response: order_by
  id: order_by
  merchant_account_id: order_by
  merchant_transaction_slips_aggregate: merchant_transaction_slip_aggregate_order_by
  payable_currency: order_by
  payable_units: order_by
  serial_id: order_by
  status: order_by
  status_timestamp: order_by
  success_ga_posting: order_by
  transaction_date: order_by
}

"""primary key columns input for table: merchant_payment"""
input merchant_payment_pk_columns_input {
  id: String!
}

"""
select columns of table "merchant_payment"
"""
enum merchant_payment_select_column {
  """column name"""
  created_at

  """column name"""
  ga_posting_response

  """column name"""
  id

  """column name"""
  merchant_account_id

  """column name"""
  payable_currency

  """column name"""
  payable_units

  """column name"""
  serial_id

  """column name"""
  status

  """column name"""
  status_timestamp

  """column name"""
  success_ga_posting

  """column name"""
  transaction_date
}

"""
input type for updating data in table "merchant_payment"
"""
input merchant_payment_set_input {
  created_at: timestamptz
  ga_posting_response: json
  id: String
  merchant_account_id: String
  payable_currency: String
  payable_units: bigint
  serial_id: Int
  status: String
  status_timestamp: date
  success_ga_posting: Boolean
  transaction_date: timestamptz
}

"""aggregate stddev on columns"""
type merchant_payment_stddev_fields {
  payable_units: Float
  serial_id: Float
}

"""aggregate stddev_pop on columns"""
type merchant_payment_stddev_pop_fields {
  payable_units: Float
  serial_id: Float
}

"""aggregate stddev_samp on columns"""
type merchant_payment_stddev_samp_fields {
  payable_units: Float
  serial_id: Float
}

"""
Streaming cursor of the table "merchant_payment"
"""
input merchant_payment_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: merchant_payment_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input merchant_payment_stream_cursor_value_input {
  created_at: timestamptz
  ga_posting_response: json
  id: String
  merchant_account_id: String
  payable_currency: String
  payable_units: bigint
  serial_id: Int
  status: String
  status_timestamp: date
  success_ga_posting: Boolean
  transaction_date: timestamptz
}

"""aggregate sum on columns"""
type merchant_payment_sum_fields {
  payable_units: bigint
  serial_id: Int
}

"""
update columns of table "merchant_payment"
"""
enum merchant_payment_update_column {
  """column name"""
  created_at

  """column name"""
  ga_posting_response

  """column name"""
  id

  """column name"""
  merchant_account_id

  """column name"""
  payable_currency

  """column name"""
  payable_units

  """column name"""
  serial_id

  """column name"""
  status

  """column name"""
  status_timestamp

  """column name"""
  success_ga_posting

  """column name"""
  transaction_date
}

input merchant_payment_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: merchant_payment_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: merchant_payment_set_input

  """filter the rows which have to be updated"""
  where: merchant_payment_bool_exp!
}

"""aggregate var_pop on columns"""
type merchant_payment_var_pop_fields {
  payable_units: Float
  serial_id: Float
}

"""aggregate var_samp on columns"""
type merchant_payment_var_samp_fields {
  payable_units: Float
  serial_id: Float
}

"""aggregate variance on columns"""
type merchant_payment_variance_fields {
  payable_units: Float
  serial_id: Float
}

"""
columns and relationships of "merchant_transaction_slip"
"""
type merchant_transaction_slip {
  booking_time: timestamptz!
  cancelled_for_disbursement: Boolean
  created_at: timestamptz!
  id: String!

  """An object relationship"""
  loan: loan!
  loan_id: String!
  merchant_account_id: String!

  """An object relationship"""
  merchant_payment: merchant_payment
  merchant_payment_id: String
  narration_comment: String
  order_number: String!
  payable_currency: String!
  payable_units: bigint!
  updated_at: timestamptz!
}

"""
aggregated selection of "merchant_transaction_slip"
"""
type merchant_transaction_slip_aggregate {
  aggregate: merchant_transaction_slip_aggregate_fields
  nodes: [merchant_transaction_slip!]!
}

input merchant_transaction_slip_aggregate_bool_exp {
  bool_and: merchant_transaction_slip_aggregate_bool_exp_bool_and
  bool_or: merchant_transaction_slip_aggregate_bool_exp_bool_or
  count: merchant_transaction_slip_aggregate_bool_exp_count
}

input merchant_transaction_slip_aggregate_bool_exp_bool_and {
  arguments: merchant_transaction_slip_select_column_merchant_transaction_slip_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: merchant_transaction_slip_bool_exp
  predicate: Boolean_comparison_exp!
}

input merchant_transaction_slip_aggregate_bool_exp_bool_or {
  arguments: merchant_transaction_slip_select_column_merchant_transaction_slip_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: merchant_transaction_slip_bool_exp
  predicate: Boolean_comparison_exp!
}

input merchant_transaction_slip_aggregate_bool_exp_count {
  arguments: [merchant_transaction_slip_select_column!]
  distinct: Boolean
  filter: merchant_transaction_slip_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "merchant_transaction_slip"
"""
type merchant_transaction_slip_aggregate_fields {
  avg: merchant_transaction_slip_avg_fields
  count(columns: [merchant_transaction_slip_select_column!], distinct: Boolean): Int!
  max: merchant_transaction_slip_max_fields
  min: merchant_transaction_slip_min_fields
  stddev: merchant_transaction_slip_stddev_fields
  stddev_pop: merchant_transaction_slip_stddev_pop_fields
  stddev_samp: merchant_transaction_slip_stddev_samp_fields
  sum: merchant_transaction_slip_sum_fields
  var_pop: merchant_transaction_slip_var_pop_fields
  var_samp: merchant_transaction_slip_var_samp_fields
  variance: merchant_transaction_slip_variance_fields
}

"""
order by aggregate values of table "merchant_transaction_slip"
"""
input merchant_transaction_slip_aggregate_order_by {
  avg: merchant_transaction_slip_avg_order_by
  count: order_by
  max: merchant_transaction_slip_max_order_by
  min: merchant_transaction_slip_min_order_by
  stddev: merchant_transaction_slip_stddev_order_by
  stddev_pop: merchant_transaction_slip_stddev_pop_order_by
  stddev_samp: merchant_transaction_slip_stddev_samp_order_by
  sum: merchant_transaction_slip_sum_order_by
  var_pop: merchant_transaction_slip_var_pop_order_by
  var_samp: merchant_transaction_slip_var_samp_order_by
  variance: merchant_transaction_slip_variance_order_by
}

"""
input type for inserting array relation for remote table "merchant_transaction_slip"
"""
input merchant_transaction_slip_arr_rel_insert_input {
  data: [merchant_transaction_slip_insert_input!]!

  """upsert condition"""
  on_conflict: merchant_transaction_slip_on_conflict
}

"""aggregate avg on columns"""
type merchant_transaction_slip_avg_fields {
  payable_units: Float
}

"""
order by avg() on columns of table "merchant_transaction_slip"
"""
input merchant_transaction_slip_avg_order_by {
  payable_units: order_by
}

"""
Boolean expression to filter rows from the table "merchant_transaction_slip". All fields are combined with a logical 'AND'.
"""
input merchant_transaction_slip_bool_exp {
  _and: [merchant_transaction_slip_bool_exp!]
  _not: merchant_transaction_slip_bool_exp
  _or: [merchant_transaction_slip_bool_exp!]
  booking_time: timestamptz_comparison_exp
  cancelled_for_disbursement: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  loan: loan_bool_exp
  loan_id: String_comparison_exp
  merchant_account_id: String_comparison_exp
  merchant_payment: merchant_payment_bool_exp
  merchant_payment_id: String_comparison_exp
  narration_comment: String_comparison_exp
  order_number: String_comparison_exp
  payable_currency: String_comparison_exp
  payable_units: bigint_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "merchant_transaction_slip"
"""
enum merchant_transaction_slip_constraint {
  """
  unique or primary key constraint on columns "loan_id"
  """
  merchant_transaction_slip_loan_id_key

  """
  unique or primary key constraint on columns "id"
  """
  merchant_transaction_slip_pkey
}

"""
input type for incrementing numeric columns in table "merchant_transaction_slip"
"""
input merchant_transaction_slip_inc_input {
  payable_units: bigint
}

"""
input type for inserting data into table "merchant_transaction_slip"
"""
input merchant_transaction_slip_insert_input {
  booking_time: timestamptz
  cancelled_for_disbursement: Boolean
  created_at: timestamptz
  id: String
  loan: loan_obj_rel_insert_input
  loan_id: String
  merchant_account_id: String
  merchant_payment: merchant_payment_obj_rel_insert_input
  merchant_payment_id: String
  narration_comment: String
  order_number: String
  payable_currency: String
  payable_units: bigint
  updated_at: timestamptz
}

"""aggregate max on columns"""
type merchant_transaction_slip_max_fields {
  booking_time: timestamptz
  created_at: timestamptz
  id: String
  loan_id: String
  merchant_account_id: String
  merchant_payment_id: String
  narration_comment: String
  order_number: String
  payable_currency: String
  payable_units: bigint
  updated_at: timestamptz
}

"""
order by max() on columns of table "merchant_transaction_slip"
"""
input merchant_transaction_slip_max_order_by {
  booking_time: order_by
  created_at: order_by
  id: order_by
  loan_id: order_by
  merchant_account_id: order_by
  merchant_payment_id: order_by
  narration_comment: order_by
  order_number: order_by
  payable_currency: order_by
  payable_units: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type merchant_transaction_slip_min_fields {
  booking_time: timestamptz
  created_at: timestamptz
  id: String
  loan_id: String
  merchant_account_id: String
  merchant_payment_id: String
  narration_comment: String
  order_number: String
  payable_currency: String
  payable_units: bigint
  updated_at: timestamptz
}

"""
order by min() on columns of table "merchant_transaction_slip"
"""
input merchant_transaction_slip_min_order_by {
  booking_time: order_by
  created_at: order_by
  id: order_by
  loan_id: order_by
  merchant_account_id: order_by
  merchant_payment_id: order_by
  narration_comment: order_by
  order_number: order_by
  payable_currency: order_by
  payable_units: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "merchant_transaction_slip"
"""
type merchant_transaction_slip_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [merchant_transaction_slip!]!
}

"""
input type for inserting object relation for remote table "merchant_transaction_slip"
"""
input merchant_transaction_slip_obj_rel_insert_input {
  data: merchant_transaction_slip_insert_input!

  """upsert condition"""
  on_conflict: merchant_transaction_slip_on_conflict
}

"""
on_conflict condition type for table "merchant_transaction_slip"
"""
input merchant_transaction_slip_on_conflict {
  constraint: merchant_transaction_slip_constraint!
  update_columns: [merchant_transaction_slip_update_column!]! = []
  where: merchant_transaction_slip_bool_exp
}

"""Ordering options when selecting data from "merchant_transaction_slip"."""
input merchant_transaction_slip_order_by {
  booking_time: order_by
  cancelled_for_disbursement: order_by
  created_at: order_by
  id: order_by
  loan: loan_order_by
  loan_id: order_by
  merchant_account_id: order_by
  merchant_payment: merchant_payment_order_by
  merchant_payment_id: order_by
  narration_comment: order_by
  order_number: order_by
  payable_currency: order_by
  payable_units: order_by
  updated_at: order_by
}

"""primary key columns input for table: merchant_transaction_slip"""
input merchant_transaction_slip_pk_columns_input {
  id: String!
}

"""
select columns of table "merchant_transaction_slip"
"""
enum merchant_transaction_slip_select_column {
  """column name"""
  booking_time

  """column name"""
  cancelled_for_disbursement

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  loan_id

  """column name"""
  merchant_account_id

  """column name"""
  merchant_payment_id

  """column name"""
  narration_comment

  """column name"""
  order_number

  """column name"""
  payable_currency

  """column name"""
  payable_units

  """column name"""
  updated_at
}

"""
select "merchant_transaction_slip_aggregate_bool_exp_bool_and_arguments_columns" columns of table "merchant_transaction_slip"
"""
enum merchant_transaction_slip_select_column_merchant_transaction_slip_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  cancelled_for_disbursement
}

"""
select "merchant_transaction_slip_aggregate_bool_exp_bool_or_arguments_columns" columns of table "merchant_transaction_slip"
"""
enum merchant_transaction_slip_select_column_merchant_transaction_slip_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  cancelled_for_disbursement
}

"""
input type for updating data in table "merchant_transaction_slip"
"""
input merchant_transaction_slip_set_input {
  booking_time: timestamptz
  cancelled_for_disbursement: Boolean
  created_at: timestamptz
  id: String
  loan_id: String
  merchant_account_id: String
  merchant_payment_id: String
  narration_comment: String
  order_number: String
  payable_currency: String
  payable_units: bigint
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type merchant_transaction_slip_stddev_fields {
  payable_units: Float
}

"""
order by stddev() on columns of table "merchant_transaction_slip"
"""
input merchant_transaction_slip_stddev_order_by {
  payable_units: order_by
}

"""aggregate stddev_pop on columns"""
type merchant_transaction_slip_stddev_pop_fields {
  payable_units: Float
}

"""
order by stddev_pop() on columns of table "merchant_transaction_slip"
"""
input merchant_transaction_slip_stddev_pop_order_by {
  payable_units: order_by
}

"""aggregate stddev_samp on columns"""
type merchant_transaction_slip_stddev_samp_fields {
  payable_units: Float
}

"""
order by stddev_samp() on columns of table "merchant_transaction_slip"
"""
input merchant_transaction_slip_stddev_samp_order_by {
  payable_units: order_by
}

"""
Streaming cursor of the table "merchant_transaction_slip"
"""
input merchant_transaction_slip_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: merchant_transaction_slip_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input merchant_transaction_slip_stream_cursor_value_input {
  booking_time: timestamptz
  cancelled_for_disbursement: Boolean
  created_at: timestamptz
  id: String
  loan_id: String
  merchant_account_id: String
  merchant_payment_id: String
  narration_comment: String
  order_number: String
  payable_currency: String
  payable_units: bigint
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type merchant_transaction_slip_sum_fields {
  payable_units: bigint
}

"""
order by sum() on columns of table "merchant_transaction_slip"
"""
input merchant_transaction_slip_sum_order_by {
  payable_units: order_by
}

"""
update columns of table "merchant_transaction_slip"
"""
enum merchant_transaction_slip_update_column {
  """column name"""
  booking_time

  """column name"""
  cancelled_for_disbursement

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  loan_id

  """column name"""
  merchant_account_id

  """column name"""
  merchant_payment_id

  """column name"""
  narration_comment

  """column name"""
  order_number

  """column name"""
  payable_currency

  """column name"""
  payable_units

  """column name"""
  updated_at
}

input merchant_transaction_slip_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: merchant_transaction_slip_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: merchant_transaction_slip_set_input

  """filter the rows which have to be updated"""
  where: merchant_transaction_slip_bool_exp!
}

"""aggregate var_pop on columns"""
type merchant_transaction_slip_var_pop_fields {
  payable_units: Float
}

"""
order by var_pop() on columns of table "merchant_transaction_slip"
"""
input merchant_transaction_slip_var_pop_order_by {
  payable_units: order_by
}

"""aggregate var_samp on columns"""
type merchant_transaction_slip_var_samp_fields {
  payable_units: Float
}

"""
order by var_samp() on columns of table "merchant_transaction_slip"
"""
input merchant_transaction_slip_var_samp_order_by {
  payable_units: order_by
}

"""aggregate variance on columns"""
type merchant_transaction_slip_variance_fields {
  payable_units: Float
}

"""
order by variance() on columns of table "merchant_transaction_slip"
"""
input merchant_transaction_slip_variance_order_by {
  payable_units: order_by
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "accounts.account"
  """
  delete_accounts_account(
    """filter the rows which have to be deleted"""
    where: accounts_account_bool_exp!
  ): accounts_account_mutation_response

  """
  delete single row from the table: "accounts.account"
  """
  delete_accounts_account_by_pk(id: String!): accounts_account

  """
  delete data from the table: "accounts.balances"
  """
  delete_accounts_balances(
    """filter the rows which have to be deleted"""
    where: accounts_balances_bool_exp!
  ): accounts_balances_mutation_response

  """
  delete single row from the table: "accounts.balances"
  """
  delete_accounts_balances_by_pk(account_id: String!, created_at: timestamptz!, currency: String!): accounts_balances

  """
  delete data from the table: "accounts.bank_account"
  """
  delete_accounts_bank_account(
    """filter the rows which have to be deleted"""
    where: accounts_bank_account_bool_exp!
  ): accounts_bank_account_mutation_response

  """
  delete single row from the table: "accounts.bank_account"
  """
  delete_accounts_bank_account_by_pk(id: uuid!): accounts_bank_account

  """
  delete data from the table: "accounts.bank_account_related_accounts"
  """
  delete_accounts_bank_account_related_accounts(
    """filter the rows which have to be deleted"""
    where: accounts_bank_account_related_accounts_bool_exp!
  ): accounts_bank_account_related_accounts_mutation_response

  """
  delete single row from the table: "accounts.bank_account_related_accounts"
  """
  delete_accounts_bank_account_related_accounts_by_pk(id: uuid!): accounts_bank_account_related_accounts

  """
  delete data from the table: "accounts.pool_accounts"
  """
  delete_accounts_pool_accounts(
    """filter the rows which have to be deleted"""
    where: accounts_pool_accounts_bool_exp!
  ): accounts_pool_accounts_mutation_response

  """
  delete single row from the table: "accounts.pool_accounts"
  """
  delete_accounts_pool_accounts_by_pk(account_id: String!, pool_id: uuid!): accounts_pool_accounts

  """
  delete data from the table: "accounts.pools"
  """
  delete_accounts_pools(
    """filter the rows which have to be deleted"""
    where: accounts_pools_bool_exp!
  ): accounts_pools_mutation_response

  """
  delete single row from the table: "accounts.pools"
  """
  delete_accounts_pools_by_pk(id: uuid!): accounts_pools

  """
  delete data from the table: "areas"
  """
  delete_areas(
    """filter the rows which have to be deleted"""
    where: areas_bool_exp!
  ): areas_mutation_response

  """
  delete single row from the table: "areas"
  """
  delete_areas_by_pk(id: Int!): areas

  """
  delete data from the table: "audit_logs"
  """
  delete_audit_logs(
    """filter the rows which have to be deleted"""
    where: audit_logs_bool_exp!
  ): audit_logs_mutation_response

  """
  delete data from the table: "checkout_baskets"
  """
  delete_checkout_baskets(
    """filter the rows which have to be deleted"""
    where: checkout_baskets_bool_exp!
  ): checkout_baskets_mutation_response

  """
  delete single row from the table: "checkout_baskets"
  """
  delete_checkout_baskets_by_pk(id: uuid!): checkout_baskets

  """
  delete data from the table: "cities"
  """
  delete_cities(
    """filter the rows which have to be deleted"""
    where: cities_bool_exp!
  ): cities_mutation_response

  """
  delete single row from the table: "cities"
  """
  delete_cities_by_pk(id: Int!): cities

  """
  delete data from the table: "command"
  """
  delete_command(
    """filter the rows which have to be deleted"""
    where: command_bool_exp!
  ): command_mutation_response

  """
  delete single row from the table: "command"
  """
  delete_command_by_pk(id: Int!): command

  """
  delete data from the table: "commercial_offer"
  """
  delete_commercial_offer(
    """filter the rows which have to be deleted"""
    where: commercial_offer_bool_exp!
  ): commercial_offer_mutation_response

  """
  delete single row from the table: "commercial_offer"
  """
  delete_commercial_offer_by_pk(id: String!): commercial_offer

  """
  delete data from the table: "connectors.connector"
  """
  delete_connectors_connector(
    """filter the rows which have to be deleted"""
    where: connectors_connector_bool_exp!
  ): connectors_connector_mutation_response

  """
  delete single row from the table: "connectors.connector"
  """
  delete_connectors_connector_by_pk(id: String!): connectors_connector

  """
  delete data from the table: "connectors.webhook"
  """
  delete_connectors_webhook(
    """filter the rows which have to be deleted"""
    where: connectors_webhook_bool_exp!
  ): connectors_webhook_mutation_response

  """
  delete single row from the table: "connectors.webhook"
  """
  delete_connectors_webhook_by_pk(id: uuid!): connectors_webhook

  """
  delete data from the table: "consumers"
  """
  delete_consumers(
    """filter the rows which have to be deleted"""
    where: consumers_bool_exp!
  ): consumers_mutation_response

  """
  delete single row from the table: "consumers"
  """
  delete_consumers_by_pk(id: uuid!): consumers

  """
  delete data from the table: "consumers_credit_limits"
  """
  delete_consumers_credit_limits(
    """filter the rows which have to be deleted"""
    where: consumers_credit_limits_bool_exp!
  ): consumers_credit_limits_mutation_response

  """
  delete single row from the table: "consumers_credit_limits"
  """
  delete_consumers_credit_limits_by_pk(id: uuid!): consumers_credit_limits

  """
  delete data from the table: "entry"
  """
  delete_entry(
    """filter the rows which have to be deleted"""
    where: entry_bool_exp!
  ): entry_mutation_response

  """
  delete single row from the table: "entry"
  """
  delete_entry_by_pk(id: bigint!): entry

  """
  delete data from the table: "governorates"
  """
  delete_governorates(
    """filter the rows which have to be deleted"""
    where: governorates_bool_exp!
  ): governorates_mutation_response

  """
  delete single row from the table: "governorates"
  """
  delete_governorates_by_pk(id: Int!): governorates

  """
  delete data from the table: "identities"
  """
  delete_identities(
    """filter the rows which have to be deleted"""
    where: identities_bool_exp!
  ): identities_mutation_response

  """
  delete single row from the table: "identities"
  """
  delete_identities_by_pk(id: uuid!): identities

  """
  delete data from the table: "identity_verifiable_addresses"
  """
  delete_identity_verifiable_addresses(
    """filter the rows which have to be deleted"""
    where: identity_verifiable_addresses_bool_exp!
  ): identity_verifiable_addresses_mutation_response

  """
  delete single row from the table: "identity_verifiable_addresses"
  """
  delete_identity_verifiable_addresses_by_pk(id: uuid!): identity_verifiable_addresses

  """
  delete data from the table: "journal"
  """
  delete_journal(
    """filter the rows which have to be deleted"""
    where: journal_bool_exp!
  ): journal_mutation_response

  """
  delete single row from the table: "journal"
  """
  delete_journal_by_pk(id: Int!): journal

  """
  delete data from the table: "journal_voucher_entries"
  """
  delete_journal_voucher_entries(
    """filter the rows which have to be deleted"""
    where: journal_voucher_entries_bool_exp!
  ): journal_voucher_entries_mutation_response

  """
  delete data from the table: "keto_relation_tuples"
  """
  delete_keto_relation_tuples(
    """filter the rows which have to be deleted"""
    where: keto_relation_tuples_bool_exp!
  ): keto_relation_tuples_mutation_response

  """
  delete single row from the table: "keto_relation_tuples"
  """
  delete_keto_relation_tuples_by_pk(nid: uuid!, shard_id: uuid!): keto_relation_tuples

  """
  delete data from the table: "keto_uuid_mappings"
  """
  delete_keto_uuid_mappings(
    """filter the rows which have to be deleted"""
    where: keto_uuid_mappings_bool_exp!
  ): keto_uuid_mappings_mutation_response

  """
  delete single row from the table: "keto_uuid_mappings"
  """
  delete_keto_uuid_mappings_by_pk(id: uuid!): keto_uuid_mappings

  """
  delete data from the table: "loan"
  """
  delete_loan(
    """filter the rows which have to be deleted"""
    where: loan_bool_exp!
  ): loan_mutation_response

  """
  delete single row from the table: "loan"
  """
  delete_loan_by_pk(id: String!): loan

  """
  delete data from the table: "loan_schedule"
  """
  delete_loan_schedule(
    """filter the rows which have to be deleted"""
    where: loan_schedule_bool_exp!
  ): loan_schedule_mutation_response

  """
  delete single row from the table: "loan_schedule"
  """
  delete_loan_schedule_by_pk(id: Int!): loan_schedule

  """
  delete data from the table: "loan_status"
  """
  delete_loan_status(
    """filter the rows which have to be deleted"""
    where: loan_status_bool_exp!
  ): loan_status_mutation_response

  """
  delete single row from the table: "loan_status"
  """
  delete_loan_status_by_pk(loan_id: String!, status: String!): loan_status

  """
  delete data from the table: "merchant_payment"
  """
  delete_merchant_payment(
    """filter the rows which have to be deleted"""
    where: merchant_payment_bool_exp!
  ): merchant_payment_mutation_response

  """
  delete single row from the table: "merchant_payment"
  """
  delete_merchant_payment_by_pk(id: String!): merchant_payment

  """
  delete data from the table: "merchant_transaction_slip"
  """
  delete_merchant_transaction_slip(
    """filter the rows which have to be deleted"""
    where: merchant_transaction_slip_bool_exp!
  ): merchant_transaction_slip_mutation_response

  """
  delete single row from the table: "merchant_transaction_slip"
  """
  delete_merchant_transaction_slip_by_pk(id: String!): merchant_transaction_slip

  """
  delete data from the table: "partner"
  """
  delete_partner(
    """filter the rows which have to be deleted"""
    where: partner_bool_exp!
  ): partner_mutation_response

  """
  delete data from the table: "partner_bank_account"
  """
  delete_partner_bank_account(
    """filter the rows which have to be deleted"""
    where: partner_bank_account_bool_exp!
  ): partner_bank_account_mutation_response

  """
  delete single row from the table: "partner_bank_account"
  """
  delete_partner_bank_account_by_pk(id: uuid!): partner_bank_account

  """
  delete data from the table: "partner_branch"
  """
  delete_partner_branch(
    """filter the rows which have to be deleted"""
    where: partner_branch_bool_exp!
  ): partner_branch_mutation_response

  """
  delete single row from the table: "partner_branch"
  """
  delete_partner_branch_by_pk(id: uuid!): partner_branch

  """
  delete single row from the table: "partner"
  """
  delete_partner_by_pk(id: uuid!): partner

  """
  delete data from the table: "partner_top"
  """
  delete_partner_top(
    """filter the rows which have to be deleted"""
    where: partner_top_bool_exp!
  ): partner_top_mutation_response

  """
  delete single row from the table: "partner_top"
  """
  delete_partner_top_by_pk(id: uuid!): partner_top

  """
  delete data from the table: "partner_user_profile"
  """
  delete_partner_user_profile(
    """filter the rows which have to be deleted"""
    where: partner_user_profile_bool_exp!
  ): partner_user_profile_mutation_response

  """
  delete single row from the table: "partner_user_profile"
  """
  delete_partner_user_profile_by_pk(id: uuid!): partner_user_profile

  """
  delete data from the table: "party_account"
  """
  delete_party_account(
    """filter the rows which have to be deleted"""
    where: party_account_bool_exp!
  ): party_account_mutation_response

  """
  delete single row from the table: "party_account"
  """
  delete_party_account_by_pk(id: Int!): party_account

  """
  delete data from the table: "payments.adjustment"
  """
  delete_payments_adjustment(
    """filter the rows which have to be deleted"""
    where: payments_adjustment_bool_exp!
  ): payments_adjustment_mutation_response

  """
  delete single row from the table: "payments.adjustment"
  """
  delete_payments_adjustment_by_pk(id: uuid!): payments_adjustment

  """
  delete data from the table: "payments.metadata"
  """
  delete_payments_metadata(
    """filter the rows which have to be deleted"""
    where: payments_metadata_bool_exp!
  ): payments_metadata_mutation_response

  """
  delete single row from the table: "payments.metadata"
  """
  delete_payments_metadata_by_pk(key: String!, payment_id: String!): payments_metadata

  """
  delete data from the table: "payments.payment"
  """
  delete_payments_payment(
    """filter the rows which have to be deleted"""
    where: payments_payment_bool_exp!
  ): payments_payment_mutation_response

  """
  delete single row from the table: "payments.payment"
  """
  delete_payments_payment_by_pk(id: String!): payments_payment

  """
  delete data from the table: "payments.transfers"
  """
  delete_payments_transfers(
    """filter the rows which have to be deleted"""
    where: payments_transfers_bool_exp!
  ): payments_transfers_mutation_response

  """
  delete single row from the table: "payments.transfers"
  """
  delete_payments_transfers_by_pk(id: uuid!): payments_transfers

  """
  delete data from the table: "registry_payment"
  """
  delete_registry_payment(
    """filter the rows which have to be deleted"""
    where: registry_payment_bool_exp!
  ): registry_payment_mutation_response

  """
  delete single row from the table: "registry_payment"
  """
  delete_registry_payment_by_pk(id: String!): registry_payment

  """
  delete data from the table: "session_baskets"
  """
  delete_session_baskets(
    """filter the rows which have to be deleted"""
    where: session_baskets_bool_exp!
  ): session_baskets_mutation_response

  """
  delete single row from the table: "session_baskets"
  """
  delete_session_baskets_by_pk(id: uuid!): session_baskets

  """
  delete data from the table: "transfers.transfer_initiation"
  """
  delete_transfers_transfer_initiation(
    """filter the rows which have to be deleted"""
    where: transfers_transfer_initiation_bool_exp!
  ): transfers_transfer_initiation_mutation_response

  """
  delete data from the table: "transfers.transfer_initiation_adjustments"
  """
  delete_transfers_transfer_initiation_adjustments(
    """filter the rows which have to be deleted"""
    where: transfers_transfer_initiation_adjustments_bool_exp!
  ): transfers_transfer_initiation_adjustments_mutation_response

  """
  delete single row from the table: "transfers.transfer_initiation_adjustments"
  """
  delete_transfers_transfer_initiation_adjustments_by_pk(id: uuid!): transfers_transfer_initiation_adjustments

  """
  delete single row from the table: "transfers.transfer_initiation"
  """
  delete_transfers_transfer_initiation_by_pk(id: String!): transfers_transfer_initiation

  """
  delete data from the table: "transfers.transfer_initiation_payments"
  """
  delete_transfers_transfer_initiation_payments(
    """filter the rows which have to be deleted"""
    where: transfers_transfer_initiation_payments_bool_exp!
  ): transfers_transfer_initiation_payments_mutation_response

  """
  delete single row from the table: "transfers.transfer_initiation_payments"
  """
  delete_transfers_transfer_initiation_payments_by_pk(payment_id: String!, transfer_initiation_id: String!): transfers_transfer_initiation_payments

  """
  delete data from the table: "transfers.transfer_reversal"
  """
  delete_transfers_transfer_reversal(
    """filter the rows which have to be deleted"""
    where: transfers_transfer_reversal_bool_exp!
  ): transfers_transfer_reversal_mutation_response

  """
  delete single row from the table: "transfers.transfer_reversal"
  """
  delete_transfers_transfer_reversal_by_pk(id: String!): transfers_transfer_reversal

  """
  insert data into the table: "accounts.account"
  """
  insert_accounts_account(
    """the rows to be inserted"""
    objects: [accounts_account_insert_input!]!

    """upsert condition"""
    on_conflict: accounts_account_on_conflict
  ): accounts_account_mutation_response

  """
  insert a single row into the table: "accounts.account"
  """
  insert_accounts_account_one(
    """the row to be inserted"""
    object: accounts_account_insert_input!

    """upsert condition"""
    on_conflict: accounts_account_on_conflict
  ): accounts_account

  """
  insert data into the table: "accounts.balances"
  """
  insert_accounts_balances(
    """the rows to be inserted"""
    objects: [accounts_balances_insert_input!]!

    """upsert condition"""
    on_conflict: accounts_balances_on_conflict
  ): accounts_balances_mutation_response

  """
  insert a single row into the table: "accounts.balances"
  """
  insert_accounts_balances_one(
    """the row to be inserted"""
    object: accounts_balances_insert_input!

    """upsert condition"""
    on_conflict: accounts_balances_on_conflict
  ): accounts_balances

  """
  insert data into the table: "accounts.bank_account"
  """
  insert_accounts_bank_account(
    """the rows to be inserted"""
    objects: [accounts_bank_account_insert_input!]!

    """upsert condition"""
    on_conflict: accounts_bank_account_on_conflict
  ): accounts_bank_account_mutation_response

  """
  insert a single row into the table: "accounts.bank_account"
  """
  insert_accounts_bank_account_one(
    """the row to be inserted"""
    object: accounts_bank_account_insert_input!

    """upsert condition"""
    on_conflict: accounts_bank_account_on_conflict
  ): accounts_bank_account

  """
  insert data into the table: "accounts.bank_account_related_accounts"
  """
  insert_accounts_bank_account_related_accounts(
    """the rows to be inserted"""
    objects: [accounts_bank_account_related_accounts_insert_input!]!

    """upsert condition"""
    on_conflict: accounts_bank_account_related_accounts_on_conflict
  ): accounts_bank_account_related_accounts_mutation_response

  """
  insert a single row into the table: "accounts.bank_account_related_accounts"
  """
  insert_accounts_bank_account_related_accounts_one(
    """the row to be inserted"""
    object: accounts_bank_account_related_accounts_insert_input!

    """upsert condition"""
    on_conflict: accounts_bank_account_related_accounts_on_conflict
  ): accounts_bank_account_related_accounts

  """
  insert data into the table: "accounts.pool_accounts"
  """
  insert_accounts_pool_accounts(
    """the rows to be inserted"""
    objects: [accounts_pool_accounts_insert_input!]!

    """upsert condition"""
    on_conflict: accounts_pool_accounts_on_conflict
  ): accounts_pool_accounts_mutation_response

  """
  insert a single row into the table: "accounts.pool_accounts"
  """
  insert_accounts_pool_accounts_one(
    """the row to be inserted"""
    object: accounts_pool_accounts_insert_input!

    """upsert condition"""
    on_conflict: accounts_pool_accounts_on_conflict
  ): accounts_pool_accounts

  """
  insert data into the table: "accounts.pools"
  """
  insert_accounts_pools(
    """the rows to be inserted"""
    objects: [accounts_pools_insert_input!]!

    """upsert condition"""
    on_conflict: accounts_pools_on_conflict
  ): accounts_pools_mutation_response

  """
  insert a single row into the table: "accounts.pools"
  """
  insert_accounts_pools_one(
    """the row to be inserted"""
    object: accounts_pools_insert_input!

    """upsert condition"""
    on_conflict: accounts_pools_on_conflict
  ): accounts_pools

  """
  insert data into the table: "areas"
  """
  insert_areas(
    """the rows to be inserted"""
    objects: [areas_insert_input!]!

    """upsert condition"""
    on_conflict: areas_on_conflict
  ): areas_mutation_response

  """
  insert a single row into the table: "areas"
  """
  insert_areas_one(
    """the row to be inserted"""
    object: areas_insert_input!

    """upsert condition"""
    on_conflict: areas_on_conflict
  ): areas

  """
  insert data into the table: "audit_logs"
  """
  insert_audit_logs(
    """the rows to be inserted"""
    objects: [audit_logs_insert_input!]!
  ): audit_logs_mutation_response

  """
  insert a single row into the table: "audit_logs"
  """
  insert_audit_logs_one(
    """the row to be inserted"""
    object: audit_logs_insert_input!
  ): audit_logs

  """
  insert data into the table: "checkout_baskets"
  """
  insert_checkout_baskets(
    """the rows to be inserted"""
    objects: [checkout_baskets_insert_input!]!

    """upsert condition"""
    on_conflict: checkout_baskets_on_conflict
  ): checkout_baskets_mutation_response

  """
  insert a single row into the table: "checkout_baskets"
  """
  insert_checkout_baskets_one(
    """the row to be inserted"""
    object: checkout_baskets_insert_input!

    """upsert condition"""
    on_conflict: checkout_baskets_on_conflict
  ): checkout_baskets

  """
  insert data into the table: "cities"
  """
  insert_cities(
    """the rows to be inserted"""
    objects: [cities_insert_input!]!

    """upsert condition"""
    on_conflict: cities_on_conflict
  ): cities_mutation_response

  """
  insert a single row into the table: "cities"
  """
  insert_cities_one(
    """the row to be inserted"""
    object: cities_insert_input!

    """upsert condition"""
    on_conflict: cities_on_conflict
  ): cities

  """
  insert data into the table: "command"
  """
  insert_command(
    """the rows to be inserted"""
    objects: [command_insert_input!]!

    """upsert condition"""
    on_conflict: command_on_conflict
  ): command_mutation_response

  """
  insert a single row into the table: "command"
  """
  insert_command_one(
    """the row to be inserted"""
    object: command_insert_input!

    """upsert condition"""
    on_conflict: command_on_conflict
  ): command

  """
  insert data into the table: "commercial_offer"
  """
  insert_commercial_offer(
    """the rows to be inserted"""
    objects: [commercial_offer_insert_input!]!

    """upsert condition"""
    on_conflict: commercial_offer_on_conflict
  ): commercial_offer_mutation_response

  """
  insert a single row into the table: "commercial_offer"
  """
  insert_commercial_offer_one(
    """the row to be inserted"""
    object: commercial_offer_insert_input!

    """upsert condition"""
    on_conflict: commercial_offer_on_conflict
  ): commercial_offer

  """
  insert data into the table: "connectors.connector"
  """
  insert_connectors_connector(
    """the rows to be inserted"""
    objects: [connectors_connector_insert_input!]!

    """upsert condition"""
    on_conflict: connectors_connector_on_conflict
  ): connectors_connector_mutation_response

  """
  insert a single row into the table: "connectors.connector"
  """
  insert_connectors_connector_one(
    """the row to be inserted"""
    object: connectors_connector_insert_input!

    """upsert condition"""
    on_conflict: connectors_connector_on_conflict
  ): connectors_connector

  """
  insert data into the table: "connectors.webhook"
  """
  insert_connectors_webhook(
    """the rows to be inserted"""
    objects: [connectors_webhook_insert_input!]!

    """upsert condition"""
    on_conflict: connectors_webhook_on_conflict
  ): connectors_webhook_mutation_response

  """
  insert a single row into the table: "connectors.webhook"
  """
  insert_connectors_webhook_one(
    """the row to be inserted"""
    object: connectors_webhook_insert_input!

    """upsert condition"""
    on_conflict: connectors_webhook_on_conflict
  ): connectors_webhook

  """
  insert data into the table: "consumers"
  """
  insert_consumers(
    """the rows to be inserted"""
    objects: [consumers_insert_input!]!

    """upsert condition"""
    on_conflict: consumers_on_conflict
  ): consumers_mutation_response

  """
  insert data into the table: "consumers_credit_limits"
  """
  insert_consumers_credit_limits(
    """the rows to be inserted"""
    objects: [consumers_credit_limits_insert_input!]!

    """upsert condition"""
    on_conflict: consumers_credit_limits_on_conflict
  ): consumers_credit_limits_mutation_response

  """
  insert a single row into the table: "consumers_credit_limits"
  """
  insert_consumers_credit_limits_one(
    """the row to be inserted"""
    object: consumers_credit_limits_insert_input!

    """upsert condition"""
    on_conflict: consumers_credit_limits_on_conflict
  ): consumers_credit_limits

  """
  insert a single row into the table: "consumers"
  """
  insert_consumers_one(
    """the row to be inserted"""
    object: consumers_insert_input!

    """upsert condition"""
    on_conflict: consumers_on_conflict
  ): consumers

  """
  insert data into the table: "entry"
  """
  insert_entry(
    """the rows to be inserted"""
    objects: [entry_insert_input!]!

    """upsert condition"""
    on_conflict: entry_on_conflict
  ): entry_mutation_response

  """
  insert a single row into the table: "entry"
  """
  insert_entry_one(
    """the row to be inserted"""
    object: entry_insert_input!

    """upsert condition"""
    on_conflict: entry_on_conflict
  ): entry

  """
  insert data into the table: "governorates"
  """
  insert_governorates(
    """the rows to be inserted"""
    objects: [governorates_insert_input!]!

    """upsert condition"""
    on_conflict: governorates_on_conflict
  ): governorates_mutation_response

  """
  insert a single row into the table: "governorates"
  """
  insert_governorates_one(
    """the row to be inserted"""
    object: governorates_insert_input!

    """upsert condition"""
    on_conflict: governorates_on_conflict
  ): governorates

  """
  insert data into the table: "identities"
  """
  insert_identities(
    """the rows to be inserted"""
    objects: [identities_insert_input!]!

    """upsert condition"""
    on_conflict: identities_on_conflict
  ): identities_mutation_response

  """
  insert a single row into the table: "identities"
  """
  insert_identities_one(
    """the row to be inserted"""
    object: identities_insert_input!

    """upsert condition"""
    on_conflict: identities_on_conflict
  ): identities

  """
  insert data into the table: "identity_verifiable_addresses"
  """
  insert_identity_verifiable_addresses(
    """the rows to be inserted"""
    objects: [identity_verifiable_addresses_insert_input!]!

    """upsert condition"""
    on_conflict: identity_verifiable_addresses_on_conflict
  ): identity_verifiable_addresses_mutation_response

  """
  insert a single row into the table: "identity_verifiable_addresses"
  """
  insert_identity_verifiable_addresses_one(
    """the row to be inserted"""
    object: identity_verifiable_addresses_insert_input!

    """upsert condition"""
    on_conflict: identity_verifiable_addresses_on_conflict
  ): identity_verifiable_addresses

  """
  insert data into the table: "journal"
  """
  insert_journal(
    """the rows to be inserted"""
    objects: [journal_insert_input!]!

    """upsert condition"""
    on_conflict: journal_on_conflict
  ): journal_mutation_response

  """
  insert a single row into the table: "journal"
  """
  insert_journal_one(
    """the row to be inserted"""
    object: journal_insert_input!

    """upsert condition"""
    on_conflict: journal_on_conflict
  ): journal

  """
  insert data into the table: "journal_voucher_entries"
  """
  insert_journal_voucher_entries(
    """the rows to be inserted"""
    objects: [journal_voucher_entries_insert_input!]!

    """upsert condition"""
    on_conflict: journal_voucher_entries_on_conflict
  ): journal_voucher_entries_mutation_response

  """
  insert a single row into the table: "journal_voucher_entries"
  """
  insert_journal_voucher_entries_one(
    """the row to be inserted"""
    object: journal_voucher_entries_insert_input!

    """upsert condition"""
    on_conflict: journal_voucher_entries_on_conflict
  ): journal_voucher_entries

  """
  insert data into the table: "keto_relation_tuples"
  """
  insert_keto_relation_tuples(
    """the rows to be inserted"""
    objects: [keto_relation_tuples_insert_input!]!

    """upsert condition"""
    on_conflict: keto_relation_tuples_on_conflict
  ): keto_relation_tuples_mutation_response

  """
  insert a single row into the table: "keto_relation_tuples"
  """
  insert_keto_relation_tuples_one(
    """the row to be inserted"""
    object: keto_relation_tuples_insert_input!

    """upsert condition"""
    on_conflict: keto_relation_tuples_on_conflict
  ): keto_relation_tuples

  """
  insert data into the table: "keto_uuid_mappings"
  """
  insert_keto_uuid_mappings(
    """the rows to be inserted"""
    objects: [keto_uuid_mappings_insert_input!]!

    """upsert condition"""
    on_conflict: keto_uuid_mappings_on_conflict
  ): keto_uuid_mappings_mutation_response

  """
  insert a single row into the table: "keto_uuid_mappings"
  """
  insert_keto_uuid_mappings_one(
    """the row to be inserted"""
    object: keto_uuid_mappings_insert_input!

    """upsert condition"""
    on_conflict: keto_uuid_mappings_on_conflict
  ): keto_uuid_mappings

  """
  insert data into the table: "loan"
  """
  insert_loan(
    """the rows to be inserted"""
    objects: [loan_insert_input!]!

    """upsert condition"""
    on_conflict: loan_on_conflict
  ): loan_mutation_response

  """
  insert a single row into the table: "loan"
  """
  insert_loan_one(
    """the row to be inserted"""
    object: loan_insert_input!

    """upsert condition"""
    on_conflict: loan_on_conflict
  ): loan

  """
  insert data into the table: "loan_schedule"
  """
  insert_loan_schedule(
    """the rows to be inserted"""
    objects: [loan_schedule_insert_input!]!

    """upsert condition"""
    on_conflict: loan_schedule_on_conflict
  ): loan_schedule_mutation_response

  """
  insert a single row into the table: "loan_schedule"
  """
  insert_loan_schedule_one(
    """the row to be inserted"""
    object: loan_schedule_insert_input!

    """upsert condition"""
    on_conflict: loan_schedule_on_conflict
  ): loan_schedule

  """
  insert data into the table: "loan_status"
  """
  insert_loan_status(
    """the rows to be inserted"""
    objects: [loan_status_insert_input!]!

    """upsert condition"""
    on_conflict: loan_status_on_conflict
  ): loan_status_mutation_response

  """
  insert a single row into the table: "loan_status"
  """
  insert_loan_status_one(
    """the row to be inserted"""
    object: loan_status_insert_input!

    """upsert condition"""
    on_conflict: loan_status_on_conflict
  ): loan_status

  """
  insert data into the table: "merchant_payment"
  """
  insert_merchant_payment(
    """the rows to be inserted"""
    objects: [merchant_payment_insert_input!]!

    """upsert condition"""
    on_conflict: merchant_payment_on_conflict
  ): merchant_payment_mutation_response

  """
  insert a single row into the table: "merchant_payment"
  """
  insert_merchant_payment_one(
    """the row to be inserted"""
    object: merchant_payment_insert_input!

    """upsert condition"""
    on_conflict: merchant_payment_on_conflict
  ): merchant_payment

  """
  insert data into the table: "merchant_transaction_slip"
  """
  insert_merchant_transaction_slip(
    """the rows to be inserted"""
    objects: [merchant_transaction_slip_insert_input!]!

    """upsert condition"""
    on_conflict: merchant_transaction_slip_on_conflict
  ): merchant_transaction_slip_mutation_response

  """
  insert a single row into the table: "merchant_transaction_slip"
  """
  insert_merchant_transaction_slip_one(
    """the row to be inserted"""
    object: merchant_transaction_slip_insert_input!

    """upsert condition"""
    on_conflict: merchant_transaction_slip_on_conflict
  ): merchant_transaction_slip

  """
  insert data into the table: "partner"
  """
  insert_partner(
    """the rows to be inserted"""
    objects: [partner_insert_input!]!

    """upsert condition"""
    on_conflict: partner_on_conflict
  ): partner_mutation_response

  """
  insert data into the table: "partner_bank_account"
  """
  insert_partner_bank_account(
    """the rows to be inserted"""
    objects: [partner_bank_account_insert_input!]!

    """upsert condition"""
    on_conflict: partner_bank_account_on_conflict
  ): partner_bank_account_mutation_response

  """
  insert a single row into the table: "partner_bank_account"
  """
  insert_partner_bank_account_one(
    """the row to be inserted"""
    object: partner_bank_account_insert_input!

    """upsert condition"""
    on_conflict: partner_bank_account_on_conflict
  ): partner_bank_account

  """
  insert data into the table: "partner_branch"
  """
  insert_partner_branch(
    """the rows to be inserted"""
    objects: [partner_branch_insert_input!]!

    """upsert condition"""
    on_conflict: partner_branch_on_conflict
  ): partner_branch_mutation_response

  """
  insert a single row into the table: "partner_branch"
  """
  insert_partner_branch_one(
    """the row to be inserted"""
    object: partner_branch_insert_input!

    """upsert condition"""
    on_conflict: partner_branch_on_conflict
  ): partner_branch

  """
  insert a single row into the table: "partner"
  """
  insert_partner_one(
    """the row to be inserted"""
    object: partner_insert_input!

    """upsert condition"""
    on_conflict: partner_on_conflict
  ): partner

  """
  insert data into the table: "partner_top"
  """
  insert_partner_top(
    """the rows to be inserted"""
    objects: [partner_top_insert_input!]!

    """upsert condition"""
    on_conflict: partner_top_on_conflict
  ): partner_top_mutation_response

  """
  insert a single row into the table: "partner_top"
  """
  insert_partner_top_one(
    """the row to be inserted"""
    object: partner_top_insert_input!

    """upsert condition"""
    on_conflict: partner_top_on_conflict
  ): partner_top

  """
  insert data into the table: "partner_user_profile"
  """
  insert_partner_user_profile(
    """the rows to be inserted"""
    objects: [partner_user_profile_insert_input!]!

    """upsert condition"""
    on_conflict: partner_user_profile_on_conflict
  ): partner_user_profile_mutation_response

  """
  insert a single row into the table: "partner_user_profile"
  """
  insert_partner_user_profile_one(
    """the row to be inserted"""
    object: partner_user_profile_insert_input!

    """upsert condition"""
    on_conflict: partner_user_profile_on_conflict
  ): partner_user_profile

  """
  insert data into the table: "party_account"
  """
  insert_party_account(
    """the rows to be inserted"""
    objects: [party_account_insert_input!]!

    """upsert condition"""
    on_conflict: party_account_on_conflict
  ): party_account_mutation_response

  """
  insert a single row into the table: "party_account"
  """
  insert_party_account_one(
    """the row to be inserted"""
    object: party_account_insert_input!

    """upsert condition"""
    on_conflict: party_account_on_conflict
  ): party_account

  """
  insert data into the table: "payments.adjustment"
  """
  insert_payments_adjustment(
    """the rows to be inserted"""
    objects: [payments_adjustment_insert_input!]!

    """upsert condition"""
    on_conflict: payments_adjustment_on_conflict
  ): payments_adjustment_mutation_response

  """
  insert a single row into the table: "payments.adjustment"
  """
  insert_payments_adjustment_one(
    """the row to be inserted"""
    object: payments_adjustment_insert_input!

    """upsert condition"""
    on_conflict: payments_adjustment_on_conflict
  ): payments_adjustment

  """
  insert data into the table: "payments.metadata"
  """
  insert_payments_metadata(
    """the rows to be inserted"""
    objects: [payments_metadata_insert_input!]!

    """upsert condition"""
    on_conflict: payments_metadata_on_conflict
  ): payments_metadata_mutation_response

  """
  insert a single row into the table: "payments.metadata"
  """
  insert_payments_metadata_one(
    """the row to be inserted"""
    object: payments_metadata_insert_input!

    """upsert condition"""
    on_conflict: payments_metadata_on_conflict
  ): payments_metadata

  """
  insert data into the table: "payments.payment"
  """
  insert_payments_payment(
    """the rows to be inserted"""
    objects: [payments_payment_insert_input!]!

    """upsert condition"""
    on_conflict: payments_payment_on_conflict
  ): payments_payment_mutation_response

  """
  insert a single row into the table: "payments.payment"
  """
  insert_payments_payment_one(
    """the row to be inserted"""
    object: payments_payment_insert_input!

    """upsert condition"""
    on_conflict: payments_payment_on_conflict
  ): payments_payment

  """
  insert data into the table: "payments.transfers"
  """
  insert_payments_transfers(
    """the rows to be inserted"""
    objects: [payments_transfers_insert_input!]!

    """upsert condition"""
    on_conflict: payments_transfers_on_conflict
  ): payments_transfers_mutation_response

  """
  insert a single row into the table: "payments.transfers"
  """
  insert_payments_transfers_one(
    """the row to be inserted"""
    object: payments_transfers_insert_input!

    """upsert condition"""
    on_conflict: payments_transfers_on_conflict
  ): payments_transfers

  """
  insert data into the table: "registry_payment"
  """
  insert_registry_payment(
    """the rows to be inserted"""
    objects: [registry_payment_insert_input!]!

    """upsert condition"""
    on_conflict: registry_payment_on_conflict
  ): registry_payment_mutation_response

  """
  insert a single row into the table: "registry_payment"
  """
  insert_registry_payment_one(
    """the row to be inserted"""
    object: registry_payment_insert_input!

    """upsert condition"""
    on_conflict: registry_payment_on_conflict
  ): registry_payment

  """
  insert data into the table: "session_baskets"
  """
  insert_session_baskets(
    """the rows to be inserted"""
    objects: [session_baskets_insert_input!]!

    """upsert condition"""
    on_conflict: session_baskets_on_conflict
  ): session_baskets_mutation_response

  """
  insert a single row into the table: "session_baskets"
  """
  insert_session_baskets_one(
    """the row to be inserted"""
    object: session_baskets_insert_input!

    """upsert condition"""
    on_conflict: session_baskets_on_conflict
  ): session_baskets

  """
  insert data into the table: "transfers.transfer_initiation"
  """
  insert_transfers_transfer_initiation(
    """the rows to be inserted"""
    objects: [transfers_transfer_initiation_insert_input!]!

    """upsert condition"""
    on_conflict: transfers_transfer_initiation_on_conflict
  ): transfers_transfer_initiation_mutation_response

  """
  insert data into the table: "transfers.transfer_initiation_adjustments"
  """
  insert_transfers_transfer_initiation_adjustments(
    """the rows to be inserted"""
    objects: [transfers_transfer_initiation_adjustments_insert_input!]!

    """upsert condition"""
    on_conflict: transfers_transfer_initiation_adjustments_on_conflict
  ): transfers_transfer_initiation_adjustments_mutation_response

  """
  insert a single row into the table: "transfers.transfer_initiation_adjustments"
  """
  insert_transfers_transfer_initiation_adjustments_one(
    """the row to be inserted"""
    object: transfers_transfer_initiation_adjustments_insert_input!

    """upsert condition"""
    on_conflict: transfers_transfer_initiation_adjustments_on_conflict
  ): transfers_transfer_initiation_adjustments

  """
  insert a single row into the table: "transfers.transfer_initiation"
  """
  insert_transfers_transfer_initiation_one(
    """the row to be inserted"""
    object: transfers_transfer_initiation_insert_input!

    """upsert condition"""
    on_conflict: transfers_transfer_initiation_on_conflict
  ): transfers_transfer_initiation

  """
  insert data into the table: "transfers.transfer_initiation_payments"
  """
  insert_transfers_transfer_initiation_payments(
    """the rows to be inserted"""
    objects: [transfers_transfer_initiation_payments_insert_input!]!

    """upsert condition"""
    on_conflict: transfers_transfer_initiation_payments_on_conflict
  ): transfers_transfer_initiation_payments_mutation_response

  """
  insert a single row into the table: "transfers.transfer_initiation_payments"
  """
  insert_transfers_transfer_initiation_payments_one(
    """the row to be inserted"""
    object: transfers_transfer_initiation_payments_insert_input!

    """upsert condition"""
    on_conflict: transfers_transfer_initiation_payments_on_conflict
  ): transfers_transfer_initiation_payments

  """
  insert data into the table: "transfers.transfer_reversal"
  """
  insert_transfers_transfer_reversal(
    """the rows to be inserted"""
    objects: [transfers_transfer_reversal_insert_input!]!

    """upsert condition"""
    on_conflict: transfers_transfer_reversal_on_conflict
  ): transfers_transfer_reversal_mutation_response

  """
  insert a single row into the table: "transfers.transfer_reversal"
  """
  insert_transfers_transfer_reversal_one(
    """the row to be inserted"""
    object: transfers_transfer_reversal_insert_input!

    """upsert condition"""
    on_conflict: transfers_transfer_reversal_on_conflict
  ): transfers_transfer_reversal

  """
  update data of the table: "accounts.account"
  """
  update_accounts_account(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: accounts_account_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: accounts_account_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: accounts_account_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: accounts_account_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: accounts_account_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_account_set_input

    """filter the rows which have to be updated"""
    where: accounts_account_bool_exp!
  ): accounts_account_mutation_response

  """
  update single row of the table: "accounts.account"
  """
  update_accounts_account_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: accounts_account_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: accounts_account_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: accounts_account_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: accounts_account_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: accounts_account_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_account_set_input
    pk_columns: accounts_account_pk_columns_input!
  ): accounts_account

  """
  update multiples rows of table: "accounts.account"
  """
  update_accounts_account_many(
    """updates to execute, in order"""
    updates: [accounts_account_updates!]!
  ): [accounts_account_mutation_response]

  """
  update data of the table: "accounts.balances"
  """
  update_accounts_balances(
    """increments the numeric columns with given value of the filtered values"""
    _inc: accounts_balances_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_balances_set_input

    """filter the rows which have to be updated"""
    where: accounts_balances_bool_exp!
  ): accounts_balances_mutation_response

  """
  update single row of the table: "accounts.balances"
  """
  update_accounts_balances_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: accounts_balances_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_balances_set_input
    pk_columns: accounts_balances_pk_columns_input!
  ): accounts_balances

  """
  update multiples rows of table: "accounts.balances"
  """
  update_accounts_balances_many(
    """updates to execute, in order"""
    updates: [accounts_balances_updates!]!
  ): [accounts_balances_mutation_response]

  """
  update data of the table: "accounts.bank_account"
  """
  update_accounts_bank_account(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: accounts_bank_account_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: accounts_bank_account_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: accounts_bank_account_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: accounts_bank_account_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: accounts_bank_account_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_bank_account_set_input

    """filter the rows which have to be updated"""
    where: accounts_bank_account_bool_exp!
  ): accounts_bank_account_mutation_response

  """
  update single row of the table: "accounts.bank_account"
  """
  update_accounts_bank_account_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: accounts_bank_account_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: accounts_bank_account_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: accounts_bank_account_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: accounts_bank_account_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: accounts_bank_account_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_bank_account_set_input
    pk_columns: accounts_bank_account_pk_columns_input!
  ): accounts_bank_account

  """
  update multiples rows of table: "accounts.bank_account"
  """
  update_accounts_bank_account_many(
    """updates to execute, in order"""
    updates: [accounts_bank_account_updates!]!
  ): [accounts_bank_account_mutation_response]

  """
  update data of the table: "accounts.bank_account_related_accounts"
  """
  update_accounts_bank_account_related_accounts(
    """sets the columns of the filtered rows to the given values"""
    _set: accounts_bank_account_related_accounts_set_input

    """filter the rows which have to be updated"""
    where: accounts_bank_account_related_accounts_bool_exp!
  ): accounts_bank_account_related_accounts_mutation_response

  """
  update single row of the table: "accounts.bank_account_related_accounts"
  """
  update_accounts_bank_account_related_accounts_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: accounts_bank_account_related_accounts_set_input
    pk_columns: accounts_bank_account_related_accounts_pk_columns_input!
  ): accounts_bank_account_related_accounts

  """
  update multiples rows of table: "accounts.bank_account_related_accounts"
  """
  update_accounts_bank_account_related_accounts_many(
    """updates to execute, in order"""
    updates: [accounts_bank_account_related_accounts_updates!]!
  ): [accounts_bank_account_related_accounts_mutation_response]

  """
  update data of the table: "accounts.pool_accounts"
  """
  update_accounts_pool_accounts(
    """sets the columns of the filtered rows to the given values"""
    _set: accounts_pool_accounts_set_input

    """filter the rows which have to be updated"""
    where: accounts_pool_accounts_bool_exp!
  ): accounts_pool_accounts_mutation_response

  """
  update single row of the table: "accounts.pool_accounts"
  """
  update_accounts_pool_accounts_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: accounts_pool_accounts_set_input
    pk_columns: accounts_pool_accounts_pk_columns_input!
  ): accounts_pool_accounts

  """
  update multiples rows of table: "accounts.pool_accounts"
  """
  update_accounts_pool_accounts_many(
    """updates to execute, in order"""
    updates: [accounts_pool_accounts_updates!]!
  ): [accounts_pool_accounts_mutation_response]

  """
  update data of the table: "accounts.pools"
  """
  update_accounts_pools(
    """sets the columns of the filtered rows to the given values"""
    _set: accounts_pools_set_input

    """filter the rows which have to be updated"""
    where: accounts_pools_bool_exp!
  ): accounts_pools_mutation_response

  """
  update single row of the table: "accounts.pools"
  """
  update_accounts_pools_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: accounts_pools_set_input
    pk_columns: accounts_pools_pk_columns_input!
  ): accounts_pools

  """
  update multiples rows of table: "accounts.pools"
  """
  update_accounts_pools_many(
    """updates to execute, in order"""
    updates: [accounts_pools_updates!]!
  ): [accounts_pools_mutation_response]

  """
  update data of the table: "areas"
  """
  update_areas(
    """increments the numeric columns with given value of the filtered values"""
    _inc: areas_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: areas_set_input

    """filter the rows which have to be updated"""
    where: areas_bool_exp!
  ): areas_mutation_response

  """
  update single row of the table: "areas"
  """
  update_areas_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: areas_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: areas_set_input
    pk_columns: areas_pk_columns_input!
  ): areas

  """
  update multiples rows of table: "areas"
  """
  update_areas_many(
    """updates to execute, in order"""
    updates: [areas_updates!]!
  ): [areas_mutation_response]

  """
  update data of the table: "audit_logs"
  """
  update_audit_logs(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: audit_logs_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_logs_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_logs_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_logs_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: audit_logs_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: audit_logs_set_input

    """filter the rows which have to be updated"""
    where: audit_logs_bool_exp!
  ): audit_logs_mutation_response

  """
  update multiples rows of table: "audit_logs"
  """
  update_audit_logs_many(
    """updates to execute, in order"""
    updates: [audit_logs_updates!]!
  ): [audit_logs_mutation_response]

  """
  update data of the table: "checkout_baskets"
  """
  update_checkout_baskets(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: checkout_baskets_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: checkout_baskets_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: checkout_baskets_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: checkout_baskets_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: checkout_baskets_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: checkout_baskets_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: checkout_baskets_set_input

    """filter the rows which have to be updated"""
    where: checkout_baskets_bool_exp!
  ): checkout_baskets_mutation_response

  """
  update single row of the table: "checkout_baskets"
  """
  update_checkout_baskets_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: checkout_baskets_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: checkout_baskets_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: checkout_baskets_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: checkout_baskets_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: checkout_baskets_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: checkout_baskets_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: checkout_baskets_set_input
    pk_columns: checkout_baskets_pk_columns_input!
  ): checkout_baskets

  """
  update multiples rows of table: "checkout_baskets"
  """
  update_checkout_baskets_many(
    """updates to execute, in order"""
    updates: [checkout_baskets_updates!]!
  ): [checkout_baskets_mutation_response]

  """
  update data of the table: "cities"
  """
  update_cities(
    """increments the numeric columns with given value of the filtered values"""
    _inc: cities_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: cities_set_input

    """filter the rows which have to be updated"""
    where: cities_bool_exp!
  ): cities_mutation_response

  """
  update single row of the table: "cities"
  """
  update_cities_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: cities_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: cities_set_input
    pk_columns: cities_pk_columns_input!
  ): cities

  """
  update multiples rows of table: "cities"
  """
  update_cities_many(
    """updates to execute, in order"""
    updates: [cities_updates!]!
  ): [cities_mutation_response]

  """
  update data of the table: "command"
  """
  update_command(
    """increments the numeric columns with given value of the filtered values"""
    _inc: command_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: command_set_input

    """filter the rows which have to be updated"""
    where: command_bool_exp!
  ): command_mutation_response

  """
  update single row of the table: "command"
  """
  update_command_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: command_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: command_set_input
    pk_columns: command_pk_columns_input!
  ): command

  """
  update multiples rows of table: "command"
  """
  update_command_many(
    """updates to execute, in order"""
    updates: [command_updates!]!
  ): [command_mutation_response]

  """
  update data of the table: "commercial_offer"
  """
  update_commercial_offer(
    """increments the numeric columns with given value of the filtered values"""
    _inc: commercial_offer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: commercial_offer_set_input

    """filter the rows which have to be updated"""
    where: commercial_offer_bool_exp!
  ): commercial_offer_mutation_response

  """
  update single row of the table: "commercial_offer"
  """
  update_commercial_offer_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: commercial_offer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: commercial_offer_set_input
    pk_columns: commercial_offer_pk_columns_input!
  ): commercial_offer

  """
  update multiples rows of table: "commercial_offer"
  """
  update_commercial_offer_many(
    """updates to execute, in order"""
    updates: [commercial_offer_updates!]!
  ): [commercial_offer_mutation_response]

  """
  update data of the table: "connectors.connector"
  """
  update_connectors_connector(
    """sets the columns of the filtered rows to the given values"""
    _set: connectors_connector_set_input

    """filter the rows which have to be updated"""
    where: connectors_connector_bool_exp!
  ): connectors_connector_mutation_response

  """
  update single row of the table: "connectors.connector"
  """
  update_connectors_connector_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: connectors_connector_set_input
    pk_columns: connectors_connector_pk_columns_input!
  ): connectors_connector

  """
  update multiples rows of table: "connectors.connector"
  """
  update_connectors_connector_many(
    """updates to execute, in order"""
    updates: [connectors_connector_updates!]!
  ): [connectors_connector_mutation_response]

  """
  update data of the table: "connectors.webhook"
  """
  update_connectors_webhook(
    """sets the columns of the filtered rows to the given values"""
    _set: connectors_webhook_set_input

    """filter the rows which have to be updated"""
    where: connectors_webhook_bool_exp!
  ): connectors_webhook_mutation_response

  """
  update single row of the table: "connectors.webhook"
  """
  update_connectors_webhook_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: connectors_webhook_set_input
    pk_columns: connectors_webhook_pk_columns_input!
  ): connectors_webhook

  """
  update multiples rows of table: "connectors.webhook"
  """
  update_connectors_webhook_many(
    """updates to execute, in order"""
    updates: [connectors_webhook_updates!]!
  ): [connectors_webhook_mutation_response]

  """
  update data of the table: "consumers"
  """
  update_consumers(
    """increments the numeric columns with given value of the filtered values"""
    _inc: consumers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: consumers_set_input

    """filter the rows which have to be updated"""
    where: consumers_bool_exp!
  ): consumers_mutation_response

  """
  update single row of the table: "consumers"
  """
  update_consumers_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: consumers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: consumers_set_input
    pk_columns: consumers_pk_columns_input!
  ): consumers

  """
  update data of the table: "consumers_credit_limits"
  """
  update_consumers_credit_limits(
    """increments the numeric columns with given value of the filtered values"""
    _inc: consumers_credit_limits_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: consumers_credit_limits_set_input

    """filter the rows which have to be updated"""
    where: consumers_credit_limits_bool_exp!
  ): consumers_credit_limits_mutation_response

  """
  update single row of the table: "consumers_credit_limits"
  """
  update_consumers_credit_limits_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: consumers_credit_limits_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: consumers_credit_limits_set_input
    pk_columns: consumers_credit_limits_pk_columns_input!
  ): consumers_credit_limits

  """
  update multiples rows of table: "consumers_credit_limits"
  """
  update_consumers_credit_limits_many(
    """updates to execute, in order"""
    updates: [consumers_credit_limits_updates!]!
  ): [consumers_credit_limits_mutation_response]

  """
  update multiples rows of table: "consumers"
  """
  update_consumers_many(
    """updates to execute, in order"""
    updates: [consumers_updates!]!
  ): [consumers_mutation_response]

  """
  update data of the table: "entry"
  """
  update_entry(
    """increments the numeric columns with given value of the filtered values"""
    _inc: entry_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: entry_set_input

    """filter the rows which have to be updated"""
    where: entry_bool_exp!
  ): entry_mutation_response

  """
  update single row of the table: "entry"
  """
  update_entry_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: entry_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: entry_set_input
    pk_columns: entry_pk_columns_input!
  ): entry

  """
  update multiples rows of table: "entry"
  """
  update_entry_many(
    """updates to execute, in order"""
    updates: [entry_updates!]!
  ): [entry_mutation_response]

  """
  update data of the table: "governorates"
  """
  update_governorates(
    """increments the numeric columns with given value of the filtered values"""
    _inc: governorates_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: governorates_set_input

    """filter the rows which have to be updated"""
    where: governorates_bool_exp!
  ): governorates_mutation_response

  """
  update single row of the table: "governorates"
  """
  update_governorates_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: governorates_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: governorates_set_input
    pk_columns: governorates_pk_columns_input!
  ): governorates

  """
  update multiples rows of table: "governorates"
  """
  update_governorates_many(
    """updates to execute, in order"""
    updates: [governorates_updates!]!
  ): [governorates_mutation_response]

  """
  update data of the table: "identities"
  """
  update_identities(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: identities_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: identities_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: identities_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: identities_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: identities_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: identities_set_input

    """filter the rows which have to be updated"""
    where: identities_bool_exp!
  ): identities_mutation_response

  """
  update single row of the table: "identities"
  """
  update_identities_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: identities_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: identities_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: identities_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: identities_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: identities_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: identities_set_input
    pk_columns: identities_pk_columns_input!
  ): identities

  """
  update multiples rows of table: "identities"
  """
  update_identities_many(
    """updates to execute, in order"""
    updates: [identities_updates!]!
  ): [identities_mutation_response]

  """
  update data of the table: "identity_verifiable_addresses"
  """
  update_identity_verifiable_addresses(
    """sets the columns of the filtered rows to the given values"""
    _set: identity_verifiable_addresses_set_input

    """filter the rows which have to be updated"""
    where: identity_verifiable_addresses_bool_exp!
  ): identity_verifiable_addresses_mutation_response

  """
  update single row of the table: "identity_verifiable_addresses"
  """
  update_identity_verifiable_addresses_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: identity_verifiable_addresses_set_input
    pk_columns: identity_verifiable_addresses_pk_columns_input!
  ): identity_verifiable_addresses

  """
  update multiples rows of table: "identity_verifiable_addresses"
  """
  update_identity_verifiable_addresses_many(
    """updates to execute, in order"""
    updates: [identity_verifiable_addresses_updates!]!
  ): [identity_verifiable_addresses_mutation_response]

  """
  update data of the table: "journal"
  """
  update_journal(
    """increments the numeric columns with given value of the filtered values"""
    _inc: journal_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: journal_set_input

    """filter the rows which have to be updated"""
    where: journal_bool_exp!
  ): journal_mutation_response

  """
  update single row of the table: "journal"
  """
  update_journal_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: journal_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: journal_set_input
    pk_columns: journal_pk_columns_input!
  ): journal

  """
  update multiples rows of table: "journal"
  """
  update_journal_many(
    """updates to execute, in order"""
    updates: [journal_updates!]!
  ): [journal_mutation_response]

  """
  update data of the table: "journal_voucher_entries"
  """
  update_journal_voucher_entries(
    """increments the numeric columns with given value of the filtered values"""
    _inc: journal_voucher_entries_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: journal_voucher_entries_set_input

    """filter the rows which have to be updated"""
    where: journal_voucher_entries_bool_exp!
  ): journal_voucher_entries_mutation_response

  """
  update multiples rows of table: "journal_voucher_entries"
  """
  update_journal_voucher_entries_many(
    """updates to execute, in order"""
    updates: [journal_voucher_entries_updates!]!
  ): [journal_voucher_entries_mutation_response]

  """
  update data of the table: "keto_relation_tuples"
  """
  update_keto_relation_tuples(
    """sets the columns of the filtered rows to the given values"""
    _set: keto_relation_tuples_set_input

    """filter the rows which have to be updated"""
    where: keto_relation_tuples_bool_exp!
  ): keto_relation_tuples_mutation_response

  """
  update single row of the table: "keto_relation_tuples"
  """
  update_keto_relation_tuples_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: keto_relation_tuples_set_input
    pk_columns: keto_relation_tuples_pk_columns_input!
  ): keto_relation_tuples

  """
  update multiples rows of table: "keto_relation_tuples"
  """
  update_keto_relation_tuples_many(
    """updates to execute, in order"""
    updates: [keto_relation_tuples_updates!]!
  ): [keto_relation_tuples_mutation_response]

  """
  update data of the table: "keto_uuid_mappings"
  """
  update_keto_uuid_mappings(
    """sets the columns of the filtered rows to the given values"""
    _set: keto_uuid_mappings_set_input

    """filter the rows which have to be updated"""
    where: keto_uuid_mappings_bool_exp!
  ): keto_uuid_mappings_mutation_response

  """
  update single row of the table: "keto_uuid_mappings"
  """
  update_keto_uuid_mappings_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: keto_uuid_mappings_set_input
    pk_columns: keto_uuid_mappings_pk_columns_input!
  ): keto_uuid_mappings

  """
  update multiples rows of table: "keto_uuid_mappings"
  """
  update_keto_uuid_mappings_many(
    """updates to execute, in order"""
    updates: [keto_uuid_mappings_updates!]!
  ): [keto_uuid_mappings_mutation_response]

  """
  update data of the table: "loan"
  """
  update_loan(
    """sets the columns of the filtered rows to the given values"""
    _set: loan_set_input

    """filter the rows which have to be updated"""
    where: loan_bool_exp!
  ): loan_mutation_response

  """
  update single row of the table: "loan"
  """
  update_loan_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: loan_set_input
    pk_columns: loan_pk_columns_input!
  ): loan

  """
  update multiples rows of table: "loan"
  """
  update_loan_many(
    """updates to execute, in order"""
    updates: [loan_updates!]!
  ): [loan_mutation_response]

  """
  update data of the table: "loan_schedule"
  """
  update_loan_schedule(
    """increments the numeric columns with given value of the filtered values"""
    _inc: loan_schedule_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: loan_schedule_set_input

    """filter the rows which have to be updated"""
    where: loan_schedule_bool_exp!
  ): loan_schedule_mutation_response

  """
  update single row of the table: "loan_schedule"
  """
  update_loan_schedule_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: loan_schedule_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: loan_schedule_set_input
    pk_columns: loan_schedule_pk_columns_input!
  ): loan_schedule

  """
  update multiples rows of table: "loan_schedule"
  """
  update_loan_schedule_many(
    """updates to execute, in order"""
    updates: [loan_schedule_updates!]!
  ): [loan_schedule_mutation_response]

  """
  update data of the table: "loan_status"
  """
  update_loan_status(
    """sets the columns of the filtered rows to the given values"""
    _set: loan_status_set_input

    """filter the rows which have to be updated"""
    where: loan_status_bool_exp!
  ): loan_status_mutation_response

  """
  update single row of the table: "loan_status"
  """
  update_loan_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: loan_status_set_input
    pk_columns: loan_status_pk_columns_input!
  ): loan_status

  """
  update multiples rows of table: "loan_status"
  """
  update_loan_status_many(
    """updates to execute, in order"""
    updates: [loan_status_updates!]!
  ): [loan_status_mutation_response]

  """
  update data of the table: "merchant_payment"
  """
  update_merchant_payment(
    """increments the numeric columns with given value of the filtered values"""
    _inc: merchant_payment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: merchant_payment_set_input

    """filter the rows which have to be updated"""
    where: merchant_payment_bool_exp!
  ): merchant_payment_mutation_response

  """
  update single row of the table: "merchant_payment"
  """
  update_merchant_payment_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: merchant_payment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: merchant_payment_set_input
    pk_columns: merchant_payment_pk_columns_input!
  ): merchant_payment

  """
  update multiples rows of table: "merchant_payment"
  """
  update_merchant_payment_many(
    """updates to execute, in order"""
    updates: [merchant_payment_updates!]!
  ): [merchant_payment_mutation_response]

  """
  update data of the table: "merchant_transaction_slip"
  """
  update_merchant_transaction_slip(
    """increments the numeric columns with given value of the filtered values"""
    _inc: merchant_transaction_slip_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: merchant_transaction_slip_set_input

    """filter the rows which have to be updated"""
    where: merchant_transaction_slip_bool_exp!
  ): merchant_transaction_slip_mutation_response

  """
  update single row of the table: "merchant_transaction_slip"
  """
  update_merchant_transaction_slip_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: merchant_transaction_slip_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: merchant_transaction_slip_set_input
    pk_columns: merchant_transaction_slip_pk_columns_input!
  ): merchant_transaction_slip

  """
  update multiples rows of table: "merchant_transaction_slip"
  """
  update_merchant_transaction_slip_many(
    """updates to execute, in order"""
    updates: [merchant_transaction_slip_updates!]!
  ): [merchant_transaction_slip_mutation_response]

  """
  update data of the table: "partner"
  """
  update_partner(
    """sets the columns of the filtered rows to the given values"""
    _set: partner_set_input

    """filter the rows which have to be updated"""
    where: partner_bool_exp!
  ): partner_mutation_response

  """
  update data of the table: "partner_bank_account"
  """
  update_partner_bank_account(
    """sets the columns of the filtered rows to the given values"""
    _set: partner_bank_account_set_input

    """filter the rows which have to be updated"""
    where: partner_bank_account_bool_exp!
  ): partner_bank_account_mutation_response

  """
  update single row of the table: "partner_bank_account"
  """
  update_partner_bank_account_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: partner_bank_account_set_input
    pk_columns: partner_bank_account_pk_columns_input!
  ): partner_bank_account

  """
  update multiples rows of table: "partner_bank_account"
  """
  update_partner_bank_account_many(
    """updates to execute, in order"""
    updates: [partner_bank_account_updates!]!
  ): [partner_bank_account_mutation_response]

  """
  update data of the table: "partner_branch"
  """
  update_partner_branch(
    """increments the numeric columns with given value of the filtered values"""
    _inc: partner_branch_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: partner_branch_set_input

    """filter the rows which have to be updated"""
    where: partner_branch_bool_exp!
  ): partner_branch_mutation_response

  """
  update single row of the table: "partner_branch"
  """
  update_partner_branch_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: partner_branch_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: partner_branch_set_input
    pk_columns: partner_branch_pk_columns_input!
  ): partner_branch

  """
  update multiples rows of table: "partner_branch"
  """
  update_partner_branch_many(
    """updates to execute, in order"""
    updates: [partner_branch_updates!]!
  ): [partner_branch_mutation_response]

  """
  update single row of the table: "partner"
  """
  update_partner_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: partner_set_input
    pk_columns: partner_pk_columns_input!
  ): partner

  """
  update multiples rows of table: "partner"
  """
  update_partner_many(
    """updates to execute, in order"""
    updates: [partner_updates!]!
  ): [partner_mutation_response]

  """
  update data of the table: "partner_top"
  """
  update_partner_top(
    """sets the columns of the filtered rows to the given values"""
    _set: partner_top_set_input

    """filter the rows which have to be updated"""
    where: partner_top_bool_exp!
  ): partner_top_mutation_response

  """
  update single row of the table: "partner_top"
  """
  update_partner_top_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: partner_top_set_input
    pk_columns: partner_top_pk_columns_input!
  ): partner_top

  """
  update multiples rows of table: "partner_top"
  """
  update_partner_top_many(
    """updates to execute, in order"""
    updates: [partner_top_updates!]!
  ): [partner_top_mutation_response]

  """
  update data of the table: "partner_user_profile"
  """
  update_partner_user_profile(
    """sets the columns of the filtered rows to the given values"""
    _set: partner_user_profile_set_input

    """filter the rows which have to be updated"""
    where: partner_user_profile_bool_exp!
  ): partner_user_profile_mutation_response

  """
  update single row of the table: "partner_user_profile"
  """
  update_partner_user_profile_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: partner_user_profile_set_input
    pk_columns: partner_user_profile_pk_columns_input!
  ): partner_user_profile

  """
  update multiples rows of table: "partner_user_profile"
  """
  update_partner_user_profile_many(
    """updates to execute, in order"""
    updates: [partner_user_profile_updates!]!
  ): [partner_user_profile_mutation_response]

  """
  update data of the table: "party_account"
  """
  update_party_account(
    """increments the numeric columns with given value of the filtered values"""
    _inc: party_account_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: party_account_set_input

    """filter the rows which have to be updated"""
    where: party_account_bool_exp!
  ): party_account_mutation_response

  """
  update single row of the table: "party_account"
  """
  update_party_account_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: party_account_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: party_account_set_input
    pk_columns: party_account_pk_columns_input!
  ): party_account

  """
  update multiples rows of table: "party_account"
  """
  update_party_account_many(
    """updates to execute, in order"""
    updates: [party_account_updates!]!
  ): [party_account_mutation_response]

  """
  update data of the table: "payments.adjustment"
  """
  update_payments_adjustment(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payments_adjustment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payments_adjustment_set_input

    """filter the rows which have to be updated"""
    where: payments_adjustment_bool_exp!
  ): payments_adjustment_mutation_response

  """
  update single row of the table: "payments.adjustment"
  """
  update_payments_adjustment_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payments_adjustment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payments_adjustment_set_input
    pk_columns: payments_adjustment_pk_columns_input!
  ): payments_adjustment

  """
  update multiples rows of table: "payments.adjustment"
  """
  update_payments_adjustment_many(
    """updates to execute, in order"""
    updates: [payments_adjustment_updates!]!
  ): [payments_adjustment_mutation_response]

  """
  update data of the table: "payments.metadata"
  """
  update_payments_metadata(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: payments_metadata_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: payments_metadata_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: payments_metadata_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: payments_metadata_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: payments_metadata_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: payments_metadata_set_input

    """filter the rows which have to be updated"""
    where: payments_metadata_bool_exp!
  ): payments_metadata_mutation_response

  """
  update single row of the table: "payments.metadata"
  """
  update_payments_metadata_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: payments_metadata_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: payments_metadata_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: payments_metadata_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: payments_metadata_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: payments_metadata_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: payments_metadata_set_input
    pk_columns: payments_metadata_pk_columns_input!
  ): payments_metadata

  """
  update multiples rows of table: "payments.metadata"
  """
  update_payments_metadata_many(
    """updates to execute, in order"""
    updates: [payments_metadata_updates!]!
  ): [payments_metadata_mutation_response]

  """
  update data of the table: "payments.payment"
  """
  update_payments_payment(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payments_payment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payments_payment_set_input

    """filter the rows which have to be updated"""
    where: payments_payment_bool_exp!
  ): payments_payment_mutation_response

  """
  update single row of the table: "payments.payment"
  """
  update_payments_payment_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payments_payment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payments_payment_set_input
    pk_columns: payments_payment_pk_columns_input!
  ): payments_payment

  """
  update multiples rows of table: "payments.payment"
  """
  update_payments_payment_many(
    """updates to execute, in order"""
    updates: [payments_payment_updates!]!
  ): [payments_payment_mutation_response]

  """
  update data of the table: "payments.transfers"
  """
  update_payments_transfers(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payments_transfers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payments_transfers_set_input

    """filter the rows which have to be updated"""
    where: payments_transfers_bool_exp!
  ): payments_transfers_mutation_response

  """
  update single row of the table: "payments.transfers"
  """
  update_payments_transfers_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payments_transfers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payments_transfers_set_input
    pk_columns: payments_transfers_pk_columns_input!
  ): payments_transfers

  """
  update multiples rows of table: "payments.transfers"
  """
  update_payments_transfers_many(
    """updates to execute, in order"""
    updates: [payments_transfers_updates!]!
  ): [payments_transfers_mutation_response]

  """
  update data of the table: "registry_payment"
  """
  update_registry_payment(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: registry_payment_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: registry_payment_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: registry_payment_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: registry_payment_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: registry_payment_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: registry_payment_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: registry_payment_set_input

    """filter the rows which have to be updated"""
    where: registry_payment_bool_exp!
  ): registry_payment_mutation_response

  """
  update single row of the table: "registry_payment"
  """
  update_registry_payment_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: registry_payment_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: registry_payment_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: registry_payment_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: registry_payment_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: registry_payment_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: registry_payment_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: registry_payment_set_input
    pk_columns: registry_payment_pk_columns_input!
  ): registry_payment

  """
  update multiples rows of table: "registry_payment"
  """
  update_registry_payment_many(
    """updates to execute, in order"""
    updates: [registry_payment_updates!]!
  ): [registry_payment_mutation_response]

  """
  update data of the table: "session_baskets"
  """
  update_session_baskets(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: session_baskets_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: session_baskets_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: session_baskets_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: session_baskets_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: session_baskets_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: session_baskets_set_input

    """filter the rows which have to be updated"""
    where: session_baskets_bool_exp!
  ): session_baskets_mutation_response

  """
  update single row of the table: "session_baskets"
  """
  update_session_baskets_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: session_baskets_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: session_baskets_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: session_baskets_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: session_baskets_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: session_baskets_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: session_baskets_set_input
    pk_columns: session_baskets_pk_columns_input!
  ): session_baskets

  """
  update multiples rows of table: "session_baskets"
  """
  update_session_baskets_many(
    """updates to execute, in order"""
    updates: [session_baskets_updates!]!
  ): [session_baskets_mutation_response]

  """
  update data of the table: "transfers.transfer_initiation"
  """
  update_transfers_transfer_initiation(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: transfers_transfer_initiation_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: transfers_transfer_initiation_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: transfers_transfer_initiation_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: transfers_transfer_initiation_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: transfers_transfer_initiation_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: transfers_transfer_initiation_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: transfers_transfer_initiation_set_input

    """filter the rows which have to be updated"""
    where: transfers_transfer_initiation_bool_exp!
  ): transfers_transfer_initiation_mutation_response

  """
  update data of the table: "transfers.transfer_initiation_adjustments"
  """
  update_transfers_transfer_initiation_adjustments(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: transfers_transfer_initiation_adjustments_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: transfers_transfer_initiation_adjustments_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: transfers_transfer_initiation_adjustments_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: transfers_transfer_initiation_adjustments_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: transfers_transfer_initiation_adjustments_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: transfers_transfer_initiation_adjustments_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: transfers_transfer_initiation_adjustments_set_input

    """filter the rows which have to be updated"""
    where: transfers_transfer_initiation_adjustments_bool_exp!
  ): transfers_transfer_initiation_adjustments_mutation_response

  """
  update single row of the table: "transfers.transfer_initiation_adjustments"
  """
  update_transfers_transfer_initiation_adjustments_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: transfers_transfer_initiation_adjustments_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: transfers_transfer_initiation_adjustments_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: transfers_transfer_initiation_adjustments_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: transfers_transfer_initiation_adjustments_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: transfers_transfer_initiation_adjustments_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: transfers_transfer_initiation_adjustments_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: transfers_transfer_initiation_adjustments_set_input
    pk_columns: transfers_transfer_initiation_adjustments_pk_columns_input!
  ): transfers_transfer_initiation_adjustments

  """
  update multiples rows of table: "transfers.transfer_initiation_adjustments"
  """
  update_transfers_transfer_initiation_adjustments_many(
    """updates to execute, in order"""
    updates: [transfers_transfer_initiation_adjustments_updates!]!
  ): [transfers_transfer_initiation_adjustments_mutation_response]

  """
  update single row of the table: "transfers.transfer_initiation"
  """
  update_transfers_transfer_initiation_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: transfers_transfer_initiation_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: transfers_transfer_initiation_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: transfers_transfer_initiation_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: transfers_transfer_initiation_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: transfers_transfer_initiation_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: transfers_transfer_initiation_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: transfers_transfer_initiation_set_input
    pk_columns: transfers_transfer_initiation_pk_columns_input!
  ): transfers_transfer_initiation

  """
  update multiples rows of table: "transfers.transfer_initiation"
  """
  update_transfers_transfer_initiation_many(
    """updates to execute, in order"""
    updates: [transfers_transfer_initiation_updates!]!
  ): [transfers_transfer_initiation_mutation_response]

  """
  update data of the table: "transfers.transfer_initiation_payments"
  """
  update_transfers_transfer_initiation_payments(
    """increments the numeric columns with given value of the filtered values"""
    _inc: transfers_transfer_initiation_payments_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: transfers_transfer_initiation_payments_set_input

    """filter the rows which have to be updated"""
    where: transfers_transfer_initiation_payments_bool_exp!
  ): transfers_transfer_initiation_payments_mutation_response

  """
  update single row of the table: "transfers.transfer_initiation_payments"
  """
  update_transfers_transfer_initiation_payments_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: transfers_transfer_initiation_payments_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: transfers_transfer_initiation_payments_set_input
    pk_columns: transfers_transfer_initiation_payments_pk_columns_input!
  ): transfers_transfer_initiation_payments

  """
  update multiples rows of table: "transfers.transfer_initiation_payments"
  """
  update_transfers_transfer_initiation_payments_many(
    """updates to execute, in order"""
    updates: [transfers_transfer_initiation_payments_updates!]!
  ): [transfers_transfer_initiation_payments_mutation_response]

  """
  update data of the table: "transfers.transfer_reversal"
  """
  update_transfers_transfer_reversal(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: transfers_transfer_reversal_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: transfers_transfer_reversal_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: transfers_transfer_reversal_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: transfers_transfer_reversal_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: transfers_transfer_reversal_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: transfers_transfer_reversal_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: transfers_transfer_reversal_set_input

    """filter the rows which have to be updated"""
    where: transfers_transfer_reversal_bool_exp!
  ): transfers_transfer_reversal_mutation_response

  """
  update single row of the table: "transfers.transfer_reversal"
  """
  update_transfers_transfer_reversal_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: transfers_transfer_reversal_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: transfers_transfer_reversal_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: transfers_transfer_reversal_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: transfers_transfer_reversal_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: transfers_transfer_reversal_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: transfers_transfer_reversal_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: transfers_transfer_reversal_set_input
    pk_columns: transfers_transfer_reversal_pk_columns_input!
  ): transfers_transfer_reversal

  """
  update multiples rows of table: "transfers.transfer_reversal"
  """
  update_transfers_transfer_reversal_many(
    """updates to execute, in order"""
    updates: [transfers_transfer_reversal_updates!]!
  ): [transfers_transfer_reversal_mutation_response]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "partner"
"""
type partner {
  categories: [partnercategory!]!
  commercial_registration_number: String
  created_at: timestamp!
  id: uuid!
  name: String!

  """An array relationship"""
  partner_bank_accounts(
    """distinct select on columns"""
    distinct_on: [partner_bank_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_bank_account_order_by!]

    """filter the rows returned"""
    where: partner_bank_account_bool_exp
  ): [partner_bank_account!]!

  """An aggregate relationship"""
  partner_bank_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [partner_bank_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_bank_account_order_by!]

    """filter the rows returned"""
    where: partner_bank_account_bool_exp
  ): partner_bank_account_aggregate!

  """An array relationship"""
  partner_branches(
    """distinct select on columns"""
    distinct_on: [partner_branch_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_branch_order_by!]

    """filter the rows returned"""
    where: partner_branch_bool_exp
  ): [partner_branch!]!

  """An aggregate relationship"""
  partner_branches_aggregate(
    """distinct select on columns"""
    distinct_on: [partner_branch_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_branch_order_by!]

    """filter the rows returned"""
    where: partner_branch_bool_exp
  ): partner_branch_aggregate!

  """An array relationship"""
  partner_tops(
    """distinct select on columns"""
    distinct_on: [partner_top_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_top_order_by!]

    """filter the rows returned"""
    where: partner_top_bool_exp
  ): [partner_top!]!

  """An aggregate relationship"""
  partner_tops_aggregate(
    """distinct select on columns"""
    distinct_on: [partner_top_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_top_order_by!]

    """filter the rows returned"""
    where: partner_top_bool_exp
  ): partner_top_aggregate!

  """An array relationship"""
  partner_user_profiles(
    """distinct select on columns"""
    distinct_on: [partner_user_profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_user_profile_order_by!]

    """filter the rows returned"""
    where: partner_user_profile_bool_exp
  ): [partner_user_profile!]!

  """An aggregate relationship"""
  partner_user_profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [partner_user_profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_user_profile_order_by!]

    """filter the rows returned"""
    where: partner_user_profile_bool_exp
  ): partner_user_profile_aggregate!
  payments(
    """distinct select on columns"""
    distinct_on: [merchant_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [merchant_payment_order_by!]

    """filter the rows returned"""
    where: merchant_payment_bool_exp
  ): [merchant_payment!]!
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [merchant_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [merchant_payment_order_by!]

    """filter the rows returned"""
    where: merchant_payment_bool_exp
  ): merchant_payment_aggregate!
  status: partnerstatus!
  tax_registration_number: String!
  updated_at: timestamp!
}

"""
aggregated selection of "partner"
"""
type partner_aggregate {
  aggregate: partner_aggregate_fields
  nodes: [partner!]!
}

"""
aggregate fields of "partner"
"""
type partner_aggregate_fields {
  count(columns: [partner_select_column!], distinct: Boolean): Int!
  max: partner_max_fields
  min: partner_min_fields
}

"""
columns and relationships of "partner_bank_account"
"""
type partner_bank_account {
  account_number: String!
  bank_name: bankname!
  beneficiary_name: String!
  branch_name: String!
  created_at: timestamp!
  iban: String!
  id: uuid!

  """An object relationship"""
  partner: partner!
  partner_id: uuid!
  swift_code: String!
  updated_at: timestamp!
}

"""
aggregated selection of "partner_bank_account"
"""
type partner_bank_account_aggregate {
  aggregate: partner_bank_account_aggregate_fields
  nodes: [partner_bank_account!]!
}

input partner_bank_account_aggregate_bool_exp {
  count: partner_bank_account_aggregate_bool_exp_count
}

input partner_bank_account_aggregate_bool_exp_count {
  arguments: [partner_bank_account_select_column!]
  distinct: Boolean
  filter: partner_bank_account_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "partner_bank_account"
"""
type partner_bank_account_aggregate_fields {
  count(columns: [partner_bank_account_select_column!], distinct: Boolean): Int!
  max: partner_bank_account_max_fields
  min: partner_bank_account_min_fields
}

"""
order by aggregate values of table "partner_bank_account"
"""
input partner_bank_account_aggregate_order_by {
  count: order_by
  max: partner_bank_account_max_order_by
  min: partner_bank_account_min_order_by
}

"""
input type for inserting array relation for remote table "partner_bank_account"
"""
input partner_bank_account_arr_rel_insert_input {
  data: [partner_bank_account_insert_input!]!

  """upsert condition"""
  on_conflict: partner_bank_account_on_conflict
}

"""
Boolean expression to filter rows from the table "partner_bank_account". All fields are combined with a logical 'AND'.
"""
input partner_bank_account_bool_exp {
  _and: [partner_bank_account_bool_exp!]
  _not: partner_bank_account_bool_exp
  _or: [partner_bank_account_bool_exp!]
  account_number: String_comparison_exp
  bank_name: bankname_comparison_exp
  beneficiary_name: String_comparison_exp
  branch_name: String_comparison_exp
  created_at: timestamp_comparison_exp
  iban: String_comparison_exp
  id: uuid_comparison_exp
  partner: partner_bool_exp
  partner_id: uuid_comparison_exp
  swift_code: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "partner_bank_account"
"""
enum partner_bank_account_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  partner_bank_account_pkey
}

"""
input type for inserting data into table "partner_bank_account"
"""
input partner_bank_account_insert_input {
  account_number: String
  bank_name: bankname
  beneficiary_name: String
  branch_name: String
  created_at: timestamp
  iban: String
  id: uuid
  partner: partner_obj_rel_insert_input
  partner_id: uuid
  swift_code: String
  updated_at: timestamp
}

"""aggregate max on columns"""
type partner_bank_account_max_fields {
  account_number: String
  bank_name: bankname
  beneficiary_name: String
  branch_name: String
  created_at: timestamp
  iban: String
  id: uuid
  partner_id: uuid
  swift_code: String
  updated_at: timestamp
}

"""
order by max() on columns of table "partner_bank_account"
"""
input partner_bank_account_max_order_by {
  account_number: order_by
  bank_name: order_by
  beneficiary_name: order_by
  branch_name: order_by
  created_at: order_by
  iban: order_by
  id: order_by
  partner_id: order_by
  swift_code: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type partner_bank_account_min_fields {
  account_number: String
  bank_name: bankname
  beneficiary_name: String
  branch_name: String
  created_at: timestamp
  iban: String
  id: uuid
  partner_id: uuid
  swift_code: String
  updated_at: timestamp
}

"""
order by min() on columns of table "partner_bank_account"
"""
input partner_bank_account_min_order_by {
  account_number: order_by
  bank_name: order_by
  beneficiary_name: order_by
  branch_name: order_by
  created_at: order_by
  iban: order_by
  id: order_by
  partner_id: order_by
  swift_code: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "partner_bank_account"
"""
type partner_bank_account_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [partner_bank_account!]!
}

"""
on_conflict condition type for table "partner_bank_account"
"""
input partner_bank_account_on_conflict {
  constraint: partner_bank_account_constraint!
  update_columns: [partner_bank_account_update_column!]! = []
  where: partner_bank_account_bool_exp
}

"""Ordering options when selecting data from "partner_bank_account"."""
input partner_bank_account_order_by {
  account_number: order_by
  bank_name: order_by
  beneficiary_name: order_by
  branch_name: order_by
  created_at: order_by
  iban: order_by
  id: order_by
  partner: partner_order_by
  partner_id: order_by
  swift_code: order_by
  updated_at: order_by
}

"""primary key columns input for table: partner_bank_account"""
input partner_bank_account_pk_columns_input {
  id: uuid!
}

"""
select columns of table "partner_bank_account"
"""
enum partner_bank_account_select_column {
  """column name"""
  account_number

  """column name"""
  bank_name

  """column name"""
  beneficiary_name

  """column name"""
  branch_name

  """column name"""
  created_at

  """column name"""
  iban

  """column name"""
  id

  """column name"""
  partner_id

  """column name"""
  swift_code

  """column name"""
  updated_at
}

"""
input type for updating data in table "partner_bank_account"
"""
input partner_bank_account_set_input {
  account_number: String
  bank_name: bankname
  beneficiary_name: String
  branch_name: String
  created_at: timestamp
  iban: String
  id: uuid
  partner_id: uuid
  swift_code: String
  updated_at: timestamp
}

"""
Streaming cursor of the table "partner_bank_account"
"""
input partner_bank_account_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: partner_bank_account_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input partner_bank_account_stream_cursor_value_input {
  account_number: String
  bank_name: bankname
  beneficiary_name: String
  branch_name: String
  created_at: timestamp
  iban: String
  id: uuid
  partner_id: uuid
  swift_code: String
  updated_at: timestamp
}

"""
update columns of table "partner_bank_account"
"""
enum partner_bank_account_update_column {
  """column name"""
  account_number

  """column name"""
  bank_name

  """column name"""
  beneficiary_name

  """column name"""
  branch_name

  """column name"""
  created_at

  """column name"""
  iban

  """column name"""
  id

  """column name"""
  partner_id

  """column name"""
  swift_code

  """column name"""
  updated_at
}

input partner_bank_account_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: partner_bank_account_set_input

  """filter the rows which have to be updated"""
  where: partner_bank_account_bool_exp!
}

"""
Boolean expression to filter rows from the table "partner". All fields are combined with a logical 'AND'.
"""
input partner_bool_exp {
  _and: [partner_bool_exp!]
  _not: partner_bool_exp
  _or: [partner_bool_exp!]
  categories: partnercategory_array_comparison_exp
  commercial_registration_number: String_comparison_exp
  created_at: timestamp_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  partner_bank_accounts: partner_bank_account_bool_exp
  partner_bank_accounts_aggregate: partner_bank_account_aggregate_bool_exp
  partner_branches: partner_branch_bool_exp
  partner_branches_aggregate: partner_branch_aggregate_bool_exp
  partner_tops: partner_top_bool_exp
  partner_tops_aggregate: partner_top_aggregate_bool_exp
  partner_user_profiles: partner_user_profile_bool_exp
  partner_user_profiles_aggregate: partner_user_profile_aggregate_bool_exp
  status: partnerstatus_comparison_exp
  tax_registration_number: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
columns and relationships of "partner_branch"
"""
type partner_branch {
  area: String
  area_id: Int

  """An object relationship"""
  area_record: areas
  city_id: Int

  """An object relationship"""
  city_record: cities
  created_at: timestamp!
  google_maps_link: String
  governorate_id: Int

  """An object relationship"""
  governorate_record: governorates
  id: uuid!
  location_latitude: String!
  location_longitude: String!
  name: String!

  """An object relationship"""
  partner: partner!
  partner_id: uuid!
  street: String!
  updated_at: timestamp!
}

"""
aggregated selection of "partner_branch"
"""
type partner_branch_aggregate {
  aggregate: partner_branch_aggregate_fields
  nodes: [partner_branch!]!
}

input partner_branch_aggregate_bool_exp {
  count: partner_branch_aggregate_bool_exp_count
}

input partner_branch_aggregate_bool_exp_count {
  arguments: [partner_branch_select_column!]
  distinct: Boolean
  filter: partner_branch_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "partner_branch"
"""
type partner_branch_aggregate_fields {
  avg: partner_branch_avg_fields
  count(columns: [partner_branch_select_column!], distinct: Boolean): Int!
  max: partner_branch_max_fields
  min: partner_branch_min_fields
  stddev: partner_branch_stddev_fields
  stddev_pop: partner_branch_stddev_pop_fields
  stddev_samp: partner_branch_stddev_samp_fields
  sum: partner_branch_sum_fields
  var_pop: partner_branch_var_pop_fields
  var_samp: partner_branch_var_samp_fields
  variance: partner_branch_variance_fields
}

"""
order by aggregate values of table "partner_branch"
"""
input partner_branch_aggregate_order_by {
  avg: partner_branch_avg_order_by
  count: order_by
  max: partner_branch_max_order_by
  min: partner_branch_min_order_by
  stddev: partner_branch_stddev_order_by
  stddev_pop: partner_branch_stddev_pop_order_by
  stddev_samp: partner_branch_stddev_samp_order_by
  sum: partner_branch_sum_order_by
  var_pop: partner_branch_var_pop_order_by
  var_samp: partner_branch_var_samp_order_by
  variance: partner_branch_variance_order_by
}

"""
input type for inserting array relation for remote table "partner_branch"
"""
input partner_branch_arr_rel_insert_input {
  data: [partner_branch_insert_input!]!

  """upsert condition"""
  on_conflict: partner_branch_on_conflict
}

"""aggregate avg on columns"""
type partner_branch_avg_fields {
  area_id: Float
  city_id: Float
  governorate_id: Float
}

"""
order by avg() on columns of table "partner_branch"
"""
input partner_branch_avg_order_by {
  area_id: order_by
  city_id: order_by
  governorate_id: order_by
}

"""
Boolean expression to filter rows from the table "partner_branch". All fields are combined with a logical 'AND'.
"""
input partner_branch_bool_exp {
  _and: [partner_branch_bool_exp!]
  _not: partner_branch_bool_exp
  _or: [partner_branch_bool_exp!]
  area: String_comparison_exp
  area_id: Int_comparison_exp
  area_record: areas_bool_exp
  city_id: Int_comparison_exp
  city_record: cities_bool_exp
  created_at: timestamp_comparison_exp
  google_maps_link: String_comparison_exp
  governorate_id: Int_comparison_exp
  governorate_record: governorates_bool_exp
  id: uuid_comparison_exp
  location_latitude: String_comparison_exp
  location_longitude: String_comparison_exp
  name: String_comparison_exp
  partner: partner_bool_exp
  partner_id: uuid_comparison_exp
  street: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "partner_branch"
"""
enum partner_branch_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  partner_branch_pkey
}

"""
input type for incrementing numeric columns in table "partner_branch"
"""
input partner_branch_inc_input {
  area_id: Int
  city_id: Int
  governorate_id: Int
}

"""
input type for inserting data into table "partner_branch"
"""
input partner_branch_insert_input {
  area: String
  area_id: Int
  area_record: areas_obj_rel_insert_input
  city_id: Int
  city_record: cities_obj_rel_insert_input
  created_at: timestamp
  google_maps_link: String
  governorate_id: Int
  governorate_record: governorates_obj_rel_insert_input
  id: uuid
  location_latitude: String
  location_longitude: String
  name: String
  partner: partner_obj_rel_insert_input
  partner_id: uuid
  street: String
  updated_at: timestamp
}

"""aggregate max on columns"""
type partner_branch_max_fields {
  area: String
  area_id: Int
  city_id: Int
  created_at: timestamp
  google_maps_link: String
  governorate_id: Int
  id: uuid
  location_latitude: String
  location_longitude: String
  name: String
  partner_id: uuid
  street: String
  updated_at: timestamp
}

"""
order by max() on columns of table "partner_branch"
"""
input partner_branch_max_order_by {
  area: order_by
  area_id: order_by
  city_id: order_by
  created_at: order_by
  google_maps_link: order_by
  governorate_id: order_by
  id: order_by
  location_latitude: order_by
  location_longitude: order_by
  name: order_by
  partner_id: order_by
  street: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type partner_branch_min_fields {
  area: String
  area_id: Int
  city_id: Int
  created_at: timestamp
  google_maps_link: String
  governorate_id: Int
  id: uuid
  location_latitude: String
  location_longitude: String
  name: String
  partner_id: uuid
  street: String
  updated_at: timestamp
}

"""
order by min() on columns of table "partner_branch"
"""
input partner_branch_min_order_by {
  area: order_by
  area_id: order_by
  city_id: order_by
  created_at: order_by
  google_maps_link: order_by
  governorate_id: order_by
  id: order_by
  location_latitude: order_by
  location_longitude: order_by
  name: order_by
  partner_id: order_by
  street: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "partner_branch"
"""
type partner_branch_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [partner_branch!]!
}

"""
input type for inserting object relation for remote table "partner_branch"
"""
input partner_branch_obj_rel_insert_input {
  data: partner_branch_insert_input!

  """upsert condition"""
  on_conflict: partner_branch_on_conflict
}

"""
on_conflict condition type for table "partner_branch"
"""
input partner_branch_on_conflict {
  constraint: partner_branch_constraint!
  update_columns: [partner_branch_update_column!]! = []
  where: partner_branch_bool_exp
}

"""Ordering options when selecting data from "partner_branch"."""
input partner_branch_order_by {
  area: order_by
  area_id: order_by
  area_record: areas_order_by
  city_id: order_by
  city_record: cities_order_by
  created_at: order_by
  google_maps_link: order_by
  governorate_id: order_by
  governorate_record: governorates_order_by
  id: order_by
  location_latitude: order_by
  location_longitude: order_by
  name: order_by
  partner: partner_order_by
  partner_id: order_by
  street: order_by
  updated_at: order_by
}

"""primary key columns input for table: partner_branch"""
input partner_branch_pk_columns_input {
  id: uuid!
}

"""
select columns of table "partner_branch"
"""
enum partner_branch_select_column {
  """column name"""
  area

  """column name"""
  area_id

  """column name"""
  city_id

  """column name"""
  created_at

  """column name"""
  google_maps_link

  """column name"""
  governorate_id

  """column name"""
  id

  """column name"""
  location_latitude

  """column name"""
  location_longitude

  """column name"""
  name

  """column name"""
  partner_id

  """column name"""
  street

  """column name"""
  updated_at
}

"""
input type for updating data in table "partner_branch"
"""
input partner_branch_set_input {
  area: String
  area_id: Int
  city_id: Int
  created_at: timestamp
  google_maps_link: String
  governorate_id: Int
  id: uuid
  location_latitude: String
  location_longitude: String
  name: String
  partner_id: uuid
  street: String
  updated_at: timestamp
}

"""aggregate stddev on columns"""
type partner_branch_stddev_fields {
  area_id: Float
  city_id: Float
  governorate_id: Float
}

"""
order by stddev() on columns of table "partner_branch"
"""
input partner_branch_stddev_order_by {
  area_id: order_by
  city_id: order_by
  governorate_id: order_by
}

"""aggregate stddev_pop on columns"""
type partner_branch_stddev_pop_fields {
  area_id: Float
  city_id: Float
  governorate_id: Float
}

"""
order by stddev_pop() on columns of table "partner_branch"
"""
input partner_branch_stddev_pop_order_by {
  area_id: order_by
  city_id: order_by
  governorate_id: order_by
}

"""aggregate stddev_samp on columns"""
type partner_branch_stddev_samp_fields {
  area_id: Float
  city_id: Float
  governorate_id: Float
}

"""
order by stddev_samp() on columns of table "partner_branch"
"""
input partner_branch_stddev_samp_order_by {
  area_id: order_by
  city_id: order_by
  governorate_id: order_by
}

"""
Streaming cursor of the table "partner_branch"
"""
input partner_branch_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: partner_branch_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input partner_branch_stream_cursor_value_input {
  area: String
  area_id: Int
  city_id: Int
  created_at: timestamp
  google_maps_link: String
  governorate_id: Int
  id: uuid
  location_latitude: String
  location_longitude: String
  name: String
  partner_id: uuid
  street: String
  updated_at: timestamp
}

"""aggregate sum on columns"""
type partner_branch_sum_fields {
  area_id: Int
  city_id: Int
  governorate_id: Int
}

"""
order by sum() on columns of table "partner_branch"
"""
input partner_branch_sum_order_by {
  area_id: order_by
  city_id: order_by
  governorate_id: order_by
}

"""
update columns of table "partner_branch"
"""
enum partner_branch_update_column {
  """column name"""
  area

  """column name"""
  area_id

  """column name"""
  city_id

  """column name"""
  created_at

  """column name"""
  google_maps_link

  """column name"""
  governorate_id

  """column name"""
  id

  """column name"""
  location_latitude

  """column name"""
  location_longitude

  """column name"""
  name

  """column name"""
  partner_id

  """column name"""
  street

  """column name"""
  updated_at
}

input partner_branch_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: partner_branch_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: partner_branch_set_input

  """filter the rows which have to be updated"""
  where: partner_branch_bool_exp!
}

"""aggregate var_pop on columns"""
type partner_branch_var_pop_fields {
  area_id: Float
  city_id: Float
  governorate_id: Float
}

"""
order by var_pop() on columns of table "partner_branch"
"""
input partner_branch_var_pop_order_by {
  area_id: order_by
  city_id: order_by
  governorate_id: order_by
}

"""aggregate var_samp on columns"""
type partner_branch_var_samp_fields {
  area_id: Float
  city_id: Float
  governorate_id: Float
}

"""
order by var_samp() on columns of table "partner_branch"
"""
input partner_branch_var_samp_order_by {
  area_id: order_by
  city_id: order_by
  governorate_id: order_by
}

"""aggregate variance on columns"""
type partner_branch_variance_fields {
  area_id: Float
  city_id: Float
  governorate_id: Float
}

"""
order by variance() on columns of table "partner_branch"
"""
input partner_branch_variance_order_by {
  area_id: order_by
  city_id: order_by
  governorate_id: order_by
}

"""
unique or primary key constraints on table "partner"
"""
enum partner_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  partner_name_key

  """
  unique or primary key constraint on columns "id"
  """
  partner_pkey

  """
  unique or primary key constraint on columns "tax_registration_number"
  """
  partner_tax_registration_number_key
}

"""
input type for inserting data into table "partner"
"""
input partner_insert_input {
  categories: [partnercategory!]
  commercial_registration_number: String
  created_at: timestamp
  id: uuid
  name: String
  partner_bank_accounts: partner_bank_account_arr_rel_insert_input
  partner_branches: partner_branch_arr_rel_insert_input
  partner_tops: partner_top_arr_rel_insert_input
  partner_user_profiles: partner_user_profile_arr_rel_insert_input
  status: partnerstatus
  tax_registration_number: String
  updated_at: timestamp
}

"""aggregate max on columns"""
type partner_max_fields {
  categories: [partnercategory!]
  commercial_registration_number: String
  created_at: timestamp
  id: uuid
  name: String
  status: partnerstatus
  tax_registration_number: String
  updated_at: timestamp
}

"""aggregate min on columns"""
type partner_min_fields {
  categories: [partnercategory!]
  commercial_registration_number: String
  created_at: timestamp
  id: uuid
  name: String
  status: partnerstatus
  tax_registration_number: String
  updated_at: timestamp
}

"""
response of any mutation on the table "partner"
"""
type partner_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [partner!]!
}

"""
input type for inserting object relation for remote table "partner"
"""
input partner_obj_rel_insert_input {
  data: partner_insert_input!

  """upsert condition"""
  on_conflict: partner_on_conflict
}

"""
on_conflict condition type for table "partner"
"""
input partner_on_conflict {
  constraint: partner_constraint!
  update_columns: [partner_update_column!]! = []
  where: partner_bool_exp
}

"""Ordering options when selecting data from "partner"."""
input partner_order_by {
  categories: order_by
  commercial_registration_number: order_by
  created_at: order_by
  id: order_by
  name: order_by
  partner_bank_accounts_aggregate: partner_bank_account_aggregate_order_by
  partner_branches_aggregate: partner_branch_aggregate_order_by
  partner_tops_aggregate: partner_top_aggregate_order_by
  partner_user_profiles_aggregate: partner_user_profile_aggregate_order_by
  status: order_by
  tax_registration_number: order_by
  updated_at: order_by
}

"""primary key columns input for table: partner"""
input partner_pk_columns_input {
  id: uuid!
}

"""
select columns of table "partner"
"""
enum partner_select_column {
  """column name"""
  categories

  """column name"""
  commercial_registration_number

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  status

  """column name"""
  tax_registration_number

  """column name"""
  updated_at
}

"""
input type for updating data in table "partner"
"""
input partner_set_input {
  categories: [partnercategory!]
  commercial_registration_number: String
  created_at: timestamp
  id: uuid
  name: String
  status: partnerstatus
  tax_registration_number: String
  updated_at: timestamp
}

"""
Streaming cursor of the table "partner"
"""
input partner_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: partner_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input partner_stream_cursor_value_input {
  categories: [partnercategory!]
  commercial_registration_number: String
  created_at: timestamp
  id: uuid
  name: String
  status: partnerstatus
  tax_registration_number: String
  updated_at: timestamp
}

"""
columns and relationships of "partner_top"
"""
type partner_top {
  created_at: timestamp!
  id: uuid!

  """An object relationship"""
  partner: partner!
  partner_id: uuid!
  updated_at: timestamp!
}

"""
aggregated selection of "partner_top"
"""
type partner_top_aggregate {
  aggregate: partner_top_aggregate_fields
  nodes: [partner_top!]!
}

input partner_top_aggregate_bool_exp {
  count: partner_top_aggregate_bool_exp_count
}

input partner_top_aggregate_bool_exp_count {
  arguments: [partner_top_select_column!]
  distinct: Boolean
  filter: partner_top_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "partner_top"
"""
type partner_top_aggregate_fields {
  count(columns: [partner_top_select_column!], distinct: Boolean): Int!
  max: partner_top_max_fields
  min: partner_top_min_fields
}

"""
order by aggregate values of table "partner_top"
"""
input partner_top_aggregate_order_by {
  count: order_by
  max: partner_top_max_order_by
  min: partner_top_min_order_by
}

"""
input type for inserting array relation for remote table "partner_top"
"""
input partner_top_arr_rel_insert_input {
  data: [partner_top_insert_input!]!

  """upsert condition"""
  on_conflict: partner_top_on_conflict
}

"""
Boolean expression to filter rows from the table "partner_top". All fields are combined with a logical 'AND'.
"""
input partner_top_bool_exp {
  _and: [partner_top_bool_exp!]
  _not: partner_top_bool_exp
  _or: [partner_top_bool_exp!]
  created_at: timestamp_comparison_exp
  id: uuid_comparison_exp
  partner: partner_bool_exp
  partner_id: uuid_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "partner_top"
"""
enum partner_top_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  partner_top_pkey
}

"""
input type for inserting data into table "partner_top"
"""
input partner_top_insert_input {
  created_at: timestamp
  id: uuid
  partner: partner_obj_rel_insert_input
  partner_id: uuid
  updated_at: timestamp
}

"""aggregate max on columns"""
type partner_top_max_fields {
  created_at: timestamp
  id: uuid
  partner_id: uuid
  updated_at: timestamp
}

"""
order by max() on columns of table "partner_top"
"""
input partner_top_max_order_by {
  created_at: order_by
  id: order_by
  partner_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type partner_top_min_fields {
  created_at: timestamp
  id: uuid
  partner_id: uuid
  updated_at: timestamp
}

"""
order by min() on columns of table "partner_top"
"""
input partner_top_min_order_by {
  created_at: order_by
  id: order_by
  partner_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "partner_top"
"""
type partner_top_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [partner_top!]!
}

"""
on_conflict condition type for table "partner_top"
"""
input partner_top_on_conflict {
  constraint: partner_top_constraint!
  update_columns: [partner_top_update_column!]! = []
  where: partner_top_bool_exp
}

"""Ordering options when selecting data from "partner_top"."""
input partner_top_order_by {
  created_at: order_by
  id: order_by
  partner: partner_order_by
  partner_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: partner_top"""
input partner_top_pk_columns_input {
  id: uuid!
}

"""
select columns of table "partner_top"
"""
enum partner_top_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  partner_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "partner_top"
"""
input partner_top_set_input {
  created_at: timestamp
  id: uuid
  partner_id: uuid
  updated_at: timestamp
}

"""
Streaming cursor of the table "partner_top"
"""
input partner_top_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: partner_top_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input partner_top_stream_cursor_value_input {
  created_at: timestamp
  id: uuid
  partner_id: uuid
  updated_at: timestamp
}

"""
update columns of table "partner_top"
"""
enum partner_top_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  partner_id

  """column name"""
  updated_at
}

input partner_top_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: partner_top_set_input

  """filter the rows which have to be updated"""
  where: partner_top_bool_exp!
}

"""
update columns of table "partner"
"""
enum partner_update_column {
  """column name"""
  categories

  """column name"""
  commercial_registration_number

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  status

  """column name"""
  tax_registration_number

  """column name"""
  updated_at
}

input partner_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: partner_set_input

  """filter the rows which have to be updated"""
  where: partner_bool_exp!
}

"""
columns and relationships of "partner_user_profile"
"""
type partner_user_profile {
  branch_id: uuid
  created_at: timestamp!
  email: String
  first_name: String!
  iam_id: uuid!
  id: uuid!
  identity: identities
  last_name: String!
  national_id: String

  """An object relationship"""
  partner: partner!

  """An object relationship"""
  partner_branch: partner_branch
  partner_id: uuid!
  phone_number: String!
  profile_type: profiletype!
  updated_at: timestamp!
}

"""
aggregated selection of "partner_user_profile"
"""
type partner_user_profile_aggregate {
  aggregate: partner_user_profile_aggregate_fields
  nodes: [partner_user_profile!]!
}

input partner_user_profile_aggregate_bool_exp {
  count: partner_user_profile_aggregate_bool_exp_count
}

input partner_user_profile_aggregate_bool_exp_count {
  arguments: [partner_user_profile_select_column!]
  distinct: Boolean
  filter: partner_user_profile_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "partner_user_profile"
"""
type partner_user_profile_aggregate_fields {
  count(columns: [partner_user_profile_select_column!], distinct: Boolean): Int!
  max: partner_user_profile_max_fields
  min: partner_user_profile_min_fields
}

"""
order by aggregate values of table "partner_user_profile"
"""
input partner_user_profile_aggregate_order_by {
  count: order_by
  max: partner_user_profile_max_order_by
  min: partner_user_profile_min_order_by
}

"""
input type for inserting array relation for remote table "partner_user_profile"
"""
input partner_user_profile_arr_rel_insert_input {
  data: [partner_user_profile_insert_input!]!

  """upsert condition"""
  on_conflict: partner_user_profile_on_conflict
}

"""
Boolean expression to filter rows from the table "partner_user_profile". All fields are combined with a logical 'AND'.
"""
input partner_user_profile_bool_exp {
  _and: [partner_user_profile_bool_exp!]
  _not: partner_user_profile_bool_exp
  _or: [partner_user_profile_bool_exp!]
  branch_id: uuid_comparison_exp
  created_at: timestamp_comparison_exp
  email: String_comparison_exp
  first_name: String_comparison_exp
  iam_id: uuid_comparison_exp
  id: uuid_comparison_exp
  last_name: String_comparison_exp
  national_id: String_comparison_exp
  partner: partner_bool_exp
  partner_branch: partner_branch_bool_exp
  partner_id: uuid_comparison_exp
  phone_number: String_comparison_exp
  profile_type: profiletype_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "partner_user_profile"
"""
enum partner_user_profile_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  partner_user_profile_pkey
}

"""
input type for inserting data into table "partner_user_profile"
"""
input partner_user_profile_insert_input {
  branch_id: uuid
  created_at: timestamp
  email: String
  first_name: String
  iam_id: uuid
  id: uuid
  last_name: String
  national_id: String
  partner: partner_obj_rel_insert_input
  partner_branch: partner_branch_obj_rel_insert_input
  partner_id: uuid
  phone_number: String
  profile_type: profiletype
  updated_at: timestamp
}

"""aggregate max on columns"""
type partner_user_profile_max_fields {
  branch_id: uuid
  created_at: timestamp
  email: String
  first_name: String
  iam_id: uuid
  id: uuid
  last_name: String
  national_id: String
  partner_id: uuid
  phone_number: String
  profile_type: profiletype
  updated_at: timestamp
}

"""
order by max() on columns of table "partner_user_profile"
"""
input partner_user_profile_max_order_by {
  branch_id: order_by
  created_at: order_by
  email: order_by
  first_name: order_by
  iam_id: order_by
  id: order_by
  last_name: order_by
  national_id: order_by
  partner_id: order_by
  phone_number: order_by
  profile_type: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type partner_user_profile_min_fields {
  branch_id: uuid
  created_at: timestamp
  email: String
  first_name: String
  iam_id: uuid
  id: uuid
  last_name: String
  national_id: String
  partner_id: uuid
  phone_number: String
  profile_type: profiletype
  updated_at: timestamp
}

"""
order by min() on columns of table "partner_user_profile"
"""
input partner_user_profile_min_order_by {
  branch_id: order_by
  created_at: order_by
  email: order_by
  first_name: order_by
  iam_id: order_by
  id: order_by
  last_name: order_by
  national_id: order_by
  partner_id: order_by
  phone_number: order_by
  profile_type: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "partner_user_profile"
"""
type partner_user_profile_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [partner_user_profile!]!
}

"""
input type for inserting object relation for remote table "partner_user_profile"
"""
input partner_user_profile_obj_rel_insert_input {
  data: partner_user_profile_insert_input!

  """upsert condition"""
  on_conflict: partner_user_profile_on_conflict
}

"""
on_conflict condition type for table "partner_user_profile"
"""
input partner_user_profile_on_conflict {
  constraint: partner_user_profile_constraint!
  update_columns: [partner_user_profile_update_column!]! = []
  where: partner_user_profile_bool_exp
}

"""Ordering options when selecting data from "partner_user_profile"."""
input partner_user_profile_order_by {
  branch_id: order_by
  created_at: order_by
  email: order_by
  first_name: order_by
  iam_id: order_by
  id: order_by
  last_name: order_by
  national_id: order_by
  partner: partner_order_by
  partner_branch: partner_branch_order_by
  partner_id: order_by
  phone_number: order_by
  profile_type: order_by
  updated_at: order_by
}

"""primary key columns input for table: partner_user_profile"""
input partner_user_profile_pk_columns_input {
  id: uuid!
}

"""
select columns of table "partner_user_profile"
"""
enum partner_user_profile_select_column {
  """column name"""
  branch_id

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  iam_id

  """column name"""
  id

  """column name"""
  last_name

  """column name"""
  national_id

  """column name"""
  partner_id

  """column name"""
  phone_number

  """column name"""
  profile_type

  """column name"""
  updated_at
}

"""
input type for updating data in table "partner_user_profile"
"""
input partner_user_profile_set_input {
  branch_id: uuid
  created_at: timestamp
  email: String
  first_name: String
  iam_id: uuid
  id: uuid
  last_name: String
  national_id: String
  partner_id: uuid
  phone_number: String
  profile_type: profiletype
  updated_at: timestamp
}

"""
Streaming cursor of the table "partner_user_profile"
"""
input partner_user_profile_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: partner_user_profile_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input partner_user_profile_stream_cursor_value_input {
  branch_id: uuid
  created_at: timestamp
  email: String
  first_name: String
  iam_id: uuid
  id: uuid
  last_name: String
  national_id: String
  partner_id: uuid
  phone_number: String
  profile_type: profiletype
  updated_at: timestamp
}

"""
update columns of table "partner_user_profile"
"""
enum partner_user_profile_update_column {
  """column name"""
  branch_id

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  iam_id

  """column name"""
  id

  """column name"""
  last_name

  """column name"""
  national_id

  """column name"""
  partner_id

  """column name"""
  phone_number

  """column name"""
  profile_type

  """column name"""
  updated_at
}

input partner_user_profile_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: partner_user_profile_set_input

  """filter the rows which have to be updated"""
  where: partner_user_profile_bool_exp!
}

scalar partnercategory

"""
Boolean expression to compare columns of type "partnercategory". All fields are combined with logical 'AND'.
"""
input partnercategory_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [partnercategory!]

  """does the array contain the given value"""
  _contains: [partnercategory!]
  _eq: [partnercategory!]
  _gt: [partnercategory!]
  _gte: [partnercategory!]
  _in: [[partnercategory!]!]
  _is_null: Boolean
  _lt: [partnercategory!]
  _lte: [partnercategory!]
  _neq: [partnercategory!]
  _nin: [[partnercategory!]!]
}

scalar partnerstatus

"""
Boolean expression to compare columns of type "partnerstatus". All fields are combined with logical 'AND'.
"""
input partnerstatus_comparison_exp {
  _eq: partnerstatus
  _gt: partnerstatus
  _gte: partnerstatus
  _in: [partnerstatus!]
  _is_null: Boolean
  _lt: partnerstatus
  _lte: partnerstatus
  _neq: partnerstatus
  _nin: [partnerstatus!]
}

"""
columns and relationships of "party_account"
"""
type party_account {
  account_status: String!
  account_type: party_account_type!
  created_at: timestamptz!
  global_reference_id: String!
  id: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "party_account"
"""
type party_account_aggregate {
  aggregate: party_account_aggregate_fields
  nodes: [party_account!]!
}

"""
aggregate fields of "party_account"
"""
type party_account_aggregate_fields {
  avg: party_account_avg_fields
  count(columns: [party_account_select_column!], distinct: Boolean): Int!
  max: party_account_max_fields
  min: party_account_min_fields
  stddev: party_account_stddev_fields
  stddev_pop: party_account_stddev_pop_fields
  stddev_samp: party_account_stddev_samp_fields
  sum: party_account_sum_fields
  var_pop: party_account_var_pop_fields
  var_samp: party_account_var_samp_fields
  variance: party_account_variance_fields
}

"""aggregate avg on columns"""
type party_account_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "party_account". All fields are combined with a logical 'AND'.
"""
input party_account_bool_exp {
  _and: [party_account_bool_exp!]
  _not: party_account_bool_exp
  _or: [party_account_bool_exp!]
  account_status: String_comparison_exp
  account_type: party_account_type_comparison_exp
  created_at: timestamptz_comparison_exp
  global_reference_id: String_comparison_exp
  id: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "party_account"
"""
enum party_account_constraint {
  """
  unique or primary key constraint on columns "global_reference_id"
  """
  party_account_global_reference_id_key

  """
  unique or primary key constraint on columns "id"
  """
  party_account_pkey
}

"""
input type for incrementing numeric columns in table "party_account"
"""
input party_account_inc_input {
  id: Int
}

"""
input type for inserting data into table "party_account"
"""
input party_account_insert_input {
  account_status: String
  account_type: party_account_type
  created_at: timestamptz
  global_reference_id: String
  id: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type party_account_max_fields {
  account_status: String
  account_type: party_account_type
  created_at: timestamptz
  global_reference_id: String
  id: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type party_account_min_fields {
  account_status: String
  account_type: party_account_type
  created_at: timestamptz
  global_reference_id: String
  id: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "party_account"
"""
type party_account_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [party_account!]!
}

"""
on_conflict condition type for table "party_account"
"""
input party_account_on_conflict {
  constraint: party_account_constraint!
  update_columns: [party_account_update_column!]! = []
  where: party_account_bool_exp
}

"""Ordering options when selecting data from "party_account"."""
input party_account_order_by {
  account_status: order_by
  account_type: order_by
  created_at: order_by
  global_reference_id: order_by
  id: order_by
  updated_at: order_by
}

"""primary key columns input for table: party_account"""
input party_account_pk_columns_input {
  id: Int!
}

"""
select columns of table "party_account"
"""
enum party_account_select_column {
  """column name"""
  account_status

  """column name"""
  account_type

  """column name"""
  created_at

  """column name"""
  global_reference_id

  """column name"""
  id

  """column name"""
  updated_at
}

"""
input type for updating data in table "party_account"
"""
input party_account_set_input {
  account_status: String
  account_type: party_account_type
  created_at: timestamptz
  global_reference_id: String
  id: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type party_account_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type party_account_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type party_account_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "party_account"
"""
input party_account_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: party_account_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input party_account_stream_cursor_value_input {
  account_status: String
  account_type: party_account_type
  created_at: timestamptz
  global_reference_id: String
  id: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type party_account_sum_fields {
  id: Int
}

scalar party_account_type

"""
Boolean expression to compare columns of type "party_account_type". All fields are combined with logical 'AND'.
"""
input party_account_type_comparison_exp {
  _eq: party_account_type
  _gt: party_account_type
  _gte: party_account_type
  _in: [party_account_type!]
  _is_null: Boolean
  _lt: party_account_type
  _lte: party_account_type
  _neq: party_account_type
  _nin: [party_account_type!]
}

"""
update columns of table "party_account"
"""
enum party_account_update_column {
  """column name"""
  account_status

  """column name"""
  account_type

  """column name"""
  created_at

  """column name"""
  global_reference_id

  """column name"""
  id

  """column name"""
  updated_at
}

input party_account_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: party_account_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: party_account_set_input

  """filter the rows which have to be updated"""
  where: party_account_bool_exp!
}

"""aggregate var_pop on columns"""
type party_account_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type party_account_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type party_account_variance_fields {
  id: Float
}

scalar payeeidtype

"""
Boolean expression to compare columns of type "payeeidtype". All fields are combined with logical 'AND'.
"""
input payeeidtype_comparison_exp {
  _eq: payeeidtype
  _gt: payeeidtype
  _gte: payeeidtype
  _in: [payeeidtype!]
  _is_null: Boolean
  _lt: payeeidtype
  _lte: payeeidtype
  _neq: payeeidtype
  _nin: [payeeidtype!]
}

scalar payeetype

"""
Boolean expression to compare columns of type "payeetype". All fields are combined with logical 'AND'.
"""
input payeetype_comparison_exp {
  _eq: payeetype
  _gt: payeetype
  _gte: payeetype
  _in: [payeetype!]
  _is_null: Boolean
  _lt: payeetype
  _lte: payeetype
  _neq: payeetype
  _nin: [payeetype!]
}

scalar payment_status

"""
Boolean expression to compare columns of type "payment_status". All fields are combined with logical 'AND'.
"""
input payment_status_comparison_exp {
  _eq: payment_status
  _gt: payment_status
  _gte: payment_status
  _in: [payment_status!]
  _is_null: Boolean
  _lt: payment_status
  _lte: payment_status
  _neq: payment_status
  _nin: [payment_status!]
}

scalar payment_type

"""
Boolean expression to compare columns of type "payment_type". All fields are combined with logical 'AND'.
"""
input payment_type_comparison_exp {
  _eq: payment_type
  _gt: payment_type
  _gte: payment_type
  _in: [payment_type!]
  _is_null: Boolean
  _lt: payment_type
  _lte: payment_type
  _neq: payment_type
  _nin: [payment_type!]
}

scalar paymentchannel

"""
Boolean expression to compare columns of type "paymentchannel". All fields are combined with logical 'AND'.
"""
input paymentchannel_comparison_exp {
  _eq: paymentchannel
  _gt: paymentchannel
  _gte: paymentchannel
  _in: [paymentchannel!]
  _is_null: Boolean
  _lt: paymentchannel
  _lte: paymentchannel
  _neq: paymentchannel
  _nin: [paymentchannel!]
}

"""
columns and relationships of "payments.adjustment"
"""
type payments_adjustment {
  absolute: Boolean!
  amount: numeric!
  created_at: timestamptz!
  id: uuid!

  """An object relationship"""
  payment: payments_payment!
  payment_id: String!
  raw_data(
    """JSON select path"""
    path: String
  ): json
  reference: String!
  status: payment_status!
}

"""
aggregated selection of "payments.adjustment"
"""
type payments_adjustment_aggregate {
  aggregate: payments_adjustment_aggregate_fields
  nodes: [payments_adjustment!]!
}

input payments_adjustment_aggregate_bool_exp {
  bool_and: payments_adjustment_aggregate_bool_exp_bool_and
  bool_or: payments_adjustment_aggregate_bool_exp_bool_or
  count: payments_adjustment_aggregate_bool_exp_count
}

input payments_adjustment_aggregate_bool_exp_bool_and {
  arguments: payments_adjustment_select_column_payments_adjustment_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: payments_adjustment_bool_exp
  predicate: Boolean_comparison_exp!
}

input payments_adjustment_aggregate_bool_exp_bool_or {
  arguments: payments_adjustment_select_column_payments_adjustment_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: payments_adjustment_bool_exp
  predicate: Boolean_comparison_exp!
}

input payments_adjustment_aggregate_bool_exp_count {
  arguments: [payments_adjustment_select_column!]
  distinct: Boolean
  filter: payments_adjustment_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "payments.adjustment"
"""
type payments_adjustment_aggregate_fields {
  avg: payments_adjustment_avg_fields
  count(columns: [payments_adjustment_select_column!], distinct: Boolean): Int!
  max: payments_adjustment_max_fields
  min: payments_adjustment_min_fields
  stddev: payments_adjustment_stddev_fields
  stddev_pop: payments_adjustment_stddev_pop_fields
  stddev_samp: payments_adjustment_stddev_samp_fields
  sum: payments_adjustment_sum_fields
  var_pop: payments_adjustment_var_pop_fields
  var_samp: payments_adjustment_var_samp_fields
  variance: payments_adjustment_variance_fields
}

"""
order by aggregate values of table "payments.adjustment"
"""
input payments_adjustment_aggregate_order_by {
  avg: payments_adjustment_avg_order_by
  count: order_by
  max: payments_adjustment_max_order_by
  min: payments_adjustment_min_order_by
  stddev: payments_adjustment_stddev_order_by
  stddev_pop: payments_adjustment_stddev_pop_order_by
  stddev_samp: payments_adjustment_stddev_samp_order_by
  sum: payments_adjustment_sum_order_by
  var_pop: payments_adjustment_var_pop_order_by
  var_samp: payments_adjustment_var_samp_order_by
  variance: payments_adjustment_variance_order_by
}

"""
input type for inserting array relation for remote table "payments.adjustment"
"""
input payments_adjustment_arr_rel_insert_input {
  data: [payments_adjustment_insert_input!]!

  """upsert condition"""
  on_conflict: payments_adjustment_on_conflict
}

"""aggregate avg on columns"""
type payments_adjustment_avg_fields {
  amount: Float
}

"""
order by avg() on columns of table "payments.adjustment"
"""
input payments_adjustment_avg_order_by {
  amount: order_by
}

"""
Boolean expression to filter rows from the table "payments.adjustment". All fields are combined with a logical 'AND'.
"""
input payments_adjustment_bool_exp {
  _and: [payments_adjustment_bool_exp!]
  _not: payments_adjustment_bool_exp
  _or: [payments_adjustment_bool_exp!]
  absolute: Boolean_comparison_exp
  amount: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  payment: payments_payment_bool_exp
  payment_id: String_comparison_exp
  raw_data: json_comparison_exp
  reference: String_comparison_exp
  status: payment_status_comparison_exp
}

"""
unique or primary key constraints on table "payments.adjustment"
"""
enum payments_adjustment_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  adjustment_pk

  """
  unique or primary key constraint on columns "reference"
  """
  adjustment_reference_key
}

"""
input type for incrementing numeric columns in table "payments.adjustment"
"""
input payments_adjustment_inc_input {
  amount: numeric
}

"""
input type for inserting data into table "payments.adjustment"
"""
input payments_adjustment_insert_input {
  absolute: Boolean
  amount: numeric
  created_at: timestamptz
  id: uuid
  payment: payments_payment_obj_rel_insert_input
  payment_id: String
  raw_data: json
  reference: String
  status: payment_status
}

"""aggregate max on columns"""
type payments_adjustment_max_fields {
  amount: numeric
  created_at: timestamptz
  id: uuid
  payment_id: String
  reference: String
  status: payment_status
}

"""
order by max() on columns of table "payments.adjustment"
"""
input payments_adjustment_max_order_by {
  amount: order_by
  created_at: order_by
  id: order_by
  payment_id: order_by
  reference: order_by
  status: order_by
}

"""aggregate min on columns"""
type payments_adjustment_min_fields {
  amount: numeric
  created_at: timestamptz
  id: uuid
  payment_id: String
  reference: String
  status: payment_status
}

"""
order by min() on columns of table "payments.adjustment"
"""
input payments_adjustment_min_order_by {
  amount: order_by
  created_at: order_by
  id: order_by
  payment_id: order_by
  reference: order_by
  status: order_by
}

"""
response of any mutation on the table "payments.adjustment"
"""
type payments_adjustment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payments_adjustment!]!
}

"""
on_conflict condition type for table "payments.adjustment"
"""
input payments_adjustment_on_conflict {
  constraint: payments_adjustment_constraint!
  update_columns: [payments_adjustment_update_column!]! = []
  where: payments_adjustment_bool_exp
}

"""Ordering options when selecting data from "payments.adjustment"."""
input payments_adjustment_order_by {
  absolute: order_by
  amount: order_by
  created_at: order_by
  id: order_by
  payment: payments_payment_order_by
  payment_id: order_by
  raw_data: order_by
  reference: order_by
  status: order_by
}

"""primary key columns input for table: payments.adjustment"""
input payments_adjustment_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payments.adjustment"
"""
enum payments_adjustment_select_column {
  """column name"""
  absolute

  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  payment_id

  """column name"""
  raw_data

  """column name"""
  reference

  """column name"""
  status
}

"""
select "payments_adjustment_aggregate_bool_exp_bool_and_arguments_columns" columns of table "payments.adjustment"
"""
enum payments_adjustment_select_column_payments_adjustment_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  absolute
}

"""
select "payments_adjustment_aggregate_bool_exp_bool_or_arguments_columns" columns of table "payments.adjustment"
"""
enum payments_adjustment_select_column_payments_adjustment_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  absolute
}

"""
input type for updating data in table "payments.adjustment"
"""
input payments_adjustment_set_input {
  absolute: Boolean
  amount: numeric
  created_at: timestamptz
  id: uuid
  payment_id: String
  raw_data: json
  reference: String
  status: payment_status
}

"""aggregate stddev on columns"""
type payments_adjustment_stddev_fields {
  amount: Float
}

"""
order by stddev() on columns of table "payments.adjustment"
"""
input payments_adjustment_stddev_order_by {
  amount: order_by
}

"""aggregate stddev_pop on columns"""
type payments_adjustment_stddev_pop_fields {
  amount: Float
}

"""
order by stddev_pop() on columns of table "payments.adjustment"
"""
input payments_adjustment_stddev_pop_order_by {
  amount: order_by
}

"""aggregate stddev_samp on columns"""
type payments_adjustment_stddev_samp_fields {
  amount: Float
}

"""
order by stddev_samp() on columns of table "payments.adjustment"
"""
input payments_adjustment_stddev_samp_order_by {
  amount: order_by
}

"""
Streaming cursor of the table "payments_adjustment"
"""
input payments_adjustment_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payments_adjustment_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payments_adjustment_stream_cursor_value_input {
  absolute: Boolean
  amount: numeric
  created_at: timestamptz
  id: uuid
  payment_id: String
  raw_data: json
  reference: String
  status: payment_status
}

"""aggregate sum on columns"""
type payments_adjustment_sum_fields {
  amount: numeric
}

"""
order by sum() on columns of table "payments.adjustment"
"""
input payments_adjustment_sum_order_by {
  amount: order_by
}

"""
update columns of table "payments.adjustment"
"""
enum payments_adjustment_update_column {
  """column name"""
  absolute

  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  payment_id

  """column name"""
  raw_data

  """column name"""
  reference

  """column name"""
  status
}

input payments_adjustment_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payments_adjustment_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: payments_adjustment_set_input

  """filter the rows which have to be updated"""
  where: payments_adjustment_bool_exp!
}

"""aggregate var_pop on columns"""
type payments_adjustment_var_pop_fields {
  amount: Float
}

"""
order by var_pop() on columns of table "payments.adjustment"
"""
input payments_adjustment_var_pop_order_by {
  amount: order_by
}

"""aggregate var_samp on columns"""
type payments_adjustment_var_samp_fields {
  amount: Float
}

"""
order by var_samp() on columns of table "payments.adjustment"
"""
input payments_adjustment_var_samp_order_by {
  amount: order_by
}

"""aggregate variance on columns"""
type payments_adjustment_variance_fields {
  amount: Float
}

"""
order by variance() on columns of table "payments.adjustment"
"""
input payments_adjustment_variance_order_by {
  amount: order_by
}

"""
columns and relationships of "payments.metadata"
"""
type payments_metadata {
  changelog(
    """JSON select path"""
    path: String
  ): jsonb!
  created_at: timestamptz!
  key: String!

  """An object relationship"""
  payment: payments_payment!
  payment_id: String!
  value: String!
}

"""
aggregated selection of "payments.metadata"
"""
type payments_metadata_aggregate {
  aggregate: payments_metadata_aggregate_fields
  nodes: [payments_metadata!]!
}

input payments_metadata_aggregate_bool_exp {
  count: payments_metadata_aggregate_bool_exp_count
}

input payments_metadata_aggregate_bool_exp_count {
  arguments: [payments_metadata_select_column!]
  distinct: Boolean
  filter: payments_metadata_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "payments.metadata"
"""
type payments_metadata_aggregate_fields {
  count(columns: [payments_metadata_select_column!], distinct: Boolean): Int!
  max: payments_metadata_max_fields
  min: payments_metadata_min_fields
}

"""
order by aggregate values of table "payments.metadata"
"""
input payments_metadata_aggregate_order_by {
  count: order_by
  max: payments_metadata_max_order_by
  min: payments_metadata_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input payments_metadata_append_input {
  changelog: jsonb
}

"""
input type for inserting array relation for remote table "payments.metadata"
"""
input payments_metadata_arr_rel_insert_input {
  data: [payments_metadata_insert_input!]!

  """upsert condition"""
  on_conflict: payments_metadata_on_conflict
}

"""
Boolean expression to filter rows from the table "payments.metadata". All fields are combined with a logical 'AND'.
"""
input payments_metadata_bool_exp {
  _and: [payments_metadata_bool_exp!]
  _not: payments_metadata_bool_exp
  _or: [payments_metadata_bool_exp!]
  changelog: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  key: String_comparison_exp
  payment: payments_payment_bool_exp
  payment_id: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "payments.metadata"
"""
enum payments_metadata_constraint {
  """
  unique or primary key constraint on columns "key", "payment_id"
  """
  metadata_pk
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input payments_metadata_delete_at_path_input {
  changelog: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input payments_metadata_delete_elem_input {
  changelog: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input payments_metadata_delete_key_input {
  changelog: String
}

"""
input type for inserting data into table "payments.metadata"
"""
input payments_metadata_insert_input {
  changelog: jsonb
  created_at: timestamptz
  key: String
  payment: payments_payment_obj_rel_insert_input
  payment_id: String
  value: String
}

"""aggregate max on columns"""
type payments_metadata_max_fields {
  created_at: timestamptz
  key: String
  payment_id: String
  value: String
}

"""
order by max() on columns of table "payments.metadata"
"""
input payments_metadata_max_order_by {
  created_at: order_by
  key: order_by
  payment_id: order_by
  value: order_by
}

"""aggregate min on columns"""
type payments_metadata_min_fields {
  created_at: timestamptz
  key: String
  payment_id: String
  value: String
}

"""
order by min() on columns of table "payments.metadata"
"""
input payments_metadata_min_order_by {
  created_at: order_by
  key: order_by
  payment_id: order_by
  value: order_by
}

"""
response of any mutation on the table "payments.metadata"
"""
type payments_metadata_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payments_metadata!]!
}

"""
on_conflict condition type for table "payments.metadata"
"""
input payments_metadata_on_conflict {
  constraint: payments_metadata_constraint!
  update_columns: [payments_metadata_update_column!]! = []
  where: payments_metadata_bool_exp
}

"""Ordering options when selecting data from "payments.metadata"."""
input payments_metadata_order_by {
  changelog: order_by
  created_at: order_by
  key: order_by
  payment: payments_payment_order_by
  payment_id: order_by
  value: order_by
}

"""primary key columns input for table: payments.metadata"""
input payments_metadata_pk_columns_input {
  key: String!
  payment_id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input payments_metadata_prepend_input {
  changelog: jsonb
}

"""
select columns of table "payments.metadata"
"""
enum payments_metadata_select_column {
  """column name"""
  changelog

  """column name"""
  created_at

  """column name"""
  key

  """column name"""
  payment_id

  """column name"""
  value
}

"""
input type for updating data in table "payments.metadata"
"""
input payments_metadata_set_input {
  changelog: jsonb
  created_at: timestamptz
  key: String
  payment_id: String
  value: String
}

"""
Streaming cursor of the table "payments_metadata"
"""
input payments_metadata_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payments_metadata_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payments_metadata_stream_cursor_value_input {
  changelog: jsonb
  created_at: timestamptz
  key: String
  payment_id: String
  value: String
}

"""
update columns of table "payments.metadata"
"""
enum payments_metadata_update_column {
  """column name"""
  changelog

  """column name"""
  created_at

  """column name"""
  key

  """column name"""
  payment_id

  """column name"""
  value
}

input payments_metadata_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: payments_metadata_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: payments_metadata_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: payments_metadata_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: payments_metadata_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: payments_metadata_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: payments_metadata_set_input

  """filter the rows which have to be updated"""
  where: payments_metadata_bool_exp!
}

"""
columns and relationships of "payments.payment"
"""
type payments_payment {
  """An array relationship"""
  adjustments(
    """distinct select on columns"""
    distinct_on: [payments_adjustment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_adjustment_order_by!]

    """filter the rows returned"""
    where: payments_adjustment_bool_exp
  ): [payments_adjustment!]!

  """An aggregate relationship"""
  adjustments_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_adjustment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_adjustment_order_by!]

    """filter the rows returned"""
    where: payments_adjustment_bool_exp
  ): payments_adjustment_aggregate!
  amount: numeric!
  asset: String!

  """An object relationship"""
  connector: connectors_connector!
  connector_id: String!
  created_at: timestamptz!

  """An object relationship"""
  destinationAccount: accounts_account
  destination_account_id: String
  id: String!
  initial_amount: numeric!

  """An array relationship"""
  metadata(
    """distinct select on columns"""
    distinct_on: [payments_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_metadata_order_by!]

    """filter the rows returned"""
    where: payments_metadata_bool_exp
  ): [payments_metadata!]!

  """An aggregate relationship"""
  metadata_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_metadata_order_by!]

    """filter the rows returned"""
    where: payments_metadata_bool_exp
  ): payments_metadata_aggregate!
  raw_data(
    """JSON select path"""
    path: String
  ): json
  reference: String!
  scheme: String!

  """An object relationship"""
  sourceAccount: accounts_account
  source_account_id: String
  status: payment_status!
  type: payment_type!
}

"""
aggregated selection of "payments.payment"
"""
type payments_payment_aggregate {
  aggregate: payments_payment_aggregate_fields
  nodes: [payments_payment!]!
}

input payments_payment_aggregate_bool_exp {
  count: payments_payment_aggregate_bool_exp_count
}

input payments_payment_aggregate_bool_exp_count {
  arguments: [payments_payment_select_column!]
  distinct: Boolean
  filter: payments_payment_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "payments.payment"
"""
type payments_payment_aggregate_fields {
  avg: payments_payment_avg_fields
  count(columns: [payments_payment_select_column!], distinct: Boolean): Int!
  max: payments_payment_max_fields
  min: payments_payment_min_fields
  stddev: payments_payment_stddev_fields
  stddev_pop: payments_payment_stddev_pop_fields
  stddev_samp: payments_payment_stddev_samp_fields
  sum: payments_payment_sum_fields
  var_pop: payments_payment_var_pop_fields
  var_samp: payments_payment_var_samp_fields
  variance: payments_payment_variance_fields
}

"""
order by aggregate values of table "payments.payment"
"""
input payments_payment_aggregate_order_by {
  avg: payments_payment_avg_order_by
  count: order_by
  max: payments_payment_max_order_by
  min: payments_payment_min_order_by
  stddev: payments_payment_stddev_order_by
  stddev_pop: payments_payment_stddev_pop_order_by
  stddev_samp: payments_payment_stddev_samp_order_by
  sum: payments_payment_sum_order_by
  var_pop: payments_payment_var_pop_order_by
  var_samp: payments_payment_var_samp_order_by
  variance: payments_payment_variance_order_by
}

"""
input type for inserting array relation for remote table "payments.payment"
"""
input payments_payment_arr_rel_insert_input {
  data: [payments_payment_insert_input!]!

  """upsert condition"""
  on_conflict: payments_payment_on_conflict
}

"""aggregate avg on columns"""
type payments_payment_avg_fields {
  amount: Float
  initial_amount: Float
}

"""
order by avg() on columns of table "payments.payment"
"""
input payments_payment_avg_order_by {
  amount: order_by
  initial_amount: order_by
}

"""
Boolean expression to filter rows from the table "payments.payment". All fields are combined with a logical 'AND'.
"""
input payments_payment_bool_exp {
  _and: [payments_payment_bool_exp!]
  _not: payments_payment_bool_exp
  _or: [payments_payment_bool_exp!]
  adjustments: payments_adjustment_bool_exp
  adjustments_aggregate: payments_adjustment_aggregate_bool_exp
  amount: numeric_comparison_exp
  asset: String_comparison_exp
  connector: connectors_connector_bool_exp
  connector_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  destinationAccount: accounts_account_bool_exp
  destination_account_id: String_comparison_exp
  id: String_comparison_exp
  initial_amount: numeric_comparison_exp
  metadata: payments_metadata_bool_exp
  metadata_aggregate: payments_metadata_aggregate_bool_exp
  raw_data: json_comparison_exp
  reference: String_comparison_exp
  scheme: String_comparison_exp
  sourceAccount: accounts_account_bool_exp
  source_account_id: String_comparison_exp
  status: payment_status_comparison_exp
  type: payment_type_comparison_exp
}

"""
unique or primary key constraints on table "payments.payment"
"""
enum payments_payment_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payment_pk

  """
  unique or primary key constraint on columns "reference"
  """
  payment_reference_key
}

"""
input type for incrementing numeric columns in table "payments.payment"
"""
input payments_payment_inc_input {
  amount: numeric
  initial_amount: numeric
}

"""
input type for inserting data into table "payments.payment"
"""
input payments_payment_insert_input {
  adjustments: payments_adjustment_arr_rel_insert_input
  amount: numeric
  asset: String
  connector: connectors_connector_obj_rel_insert_input
  connector_id: String
  created_at: timestamptz
  destinationAccount: accounts_account_obj_rel_insert_input
  destination_account_id: String
  id: String
  initial_amount: numeric
  metadata: payments_metadata_arr_rel_insert_input
  raw_data: json
  reference: String
  scheme: String
  sourceAccount: accounts_account_obj_rel_insert_input
  source_account_id: String
  status: payment_status
  type: payment_type
}

"""aggregate max on columns"""
type payments_payment_max_fields {
  amount: numeric
  asset: String
  connector_id: String
  created_at: timestamptz
  destination_account_id: String
  id: String
  initial_amount: numeric
  reference: String
  scheme: String
  source_account_id: String
  status: payment_status
  type: payment_type
}

"""
order by max() on columns of table "payments.payment"
"""
input payments_payment_max_order_by {
  amount: order_by
  asset: order_by
  connector_id: order_by
  created_at: order_by
  destination_account_id: order_by
  id: order_by
  initial_amount: order_by
  reference: order_by
  scheme: order_by
  source_account_id: order_by
  status: order_by
  type: order_by
}

"""aggregate min on columns"""
type payments_payment_min_fields {
  amount: numeric
  asset: String
  connector_id: String
  created_at: timestamptz
  destination_account_id: String
  id: String
  initial_amount: numeric
  reference: String
  scheme: String
  source_account_id: String
  status: payment_status
  type: payment_type
}

"""
order by min() on columns of table "payments.payment"
"""
input payments_payment_min_order_by {
  amount: order_by
  asset: order_by
  connector_id: order_by
  created_at: order_by
  destination_account_id: order_by
  id: order_by
  initial_amount: order_by
  reference: order_by
  scheme: order_by
  source_account_id: order_by
  status: order_by
  type: order_by
}

"""
response of any mutation on the table "payments.payment"
"""
type payments_payment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payments_payment!]!
}

"""
input type for inserting object relation for remote table "payments.payment"
"""
input payments_payment_obj_rel_insert_input {
  data: payments_payment_insert_input!

  """upsert condition"""
  on_conflict: payments_payment_on_conflict
}

"""
on_conflict condition type for table "payments.payment"
"""
input payments_payment_on_conflict {
  constraint: payments_payment_constraint!
  update_columns: [payments_payment_update_column!]! = []
  where: payments_payment_bool_exp
}

"""Ordering options when selecting data from "payments.payment"."""
input payments_payment_order_by {
  adjustments_aggregate: payments_adjustment_aggregate_order_by
  amount: order_by
  asset: order_by
  connector: connectors_connector_order_by
  connector_id: order_by
  created_at: order_by
  destinationAccount: accounts_account_order_by
  destination_account_id: order_by
  id: order_by
  initial_amount: order_by
  metadata_aggregate: payments_metadata_aggregate_order_by
  raw_data: order_by
  reference: order_by
  scheme: order_by
  sourceAccount: accounts_account_order_by
  source_account_id: order_by
  status: order_by
  type: order_by
}

"""primary key columns input for table: payments.payment"""
input payments_payment_pk_columns_input {
  id: String!
}

"""
select columns of table "payments.payment"
"""
enum payments_payment_select_column {
  """column name"""
  amount

  """column name"""
  asset

  """column name"""
  connector_id

  """column name"""
  created_at

  """column name"""
  destination_account_id

  """column name"""
  id

  """column name"""
  initial_amount

  """column name"""
  raw_data

  """column name"""
  reference

  """column name"""
  scheme

  """column name"""
  source_account_id

  """column name"""
  status

  """column name"""
  type
}

"""
input type for updating data in table "payments.payment"
"""
input payments_payment_set_input {
  amount: numeric
  asset: String
  connector_id: String
  created_at: timestamptz
  destination_account_id: String
  id: String
  initial_amount: numeric
  raw_data: json
  reference: String
  scheme: String
  source_account_id: String
  status: payment_status
  type: payment_type
}

"""aggregate stddev on columns"""
type payments_payment_stddev_fields {
  amount: Float
  initial_amount: Float
}

"""
order by stddev() on columns of table "payments.payment"
"""
input payments_payment_stddev_order_by {
  amount: order_by
  initial_amount: order_by
}

"""aggregate stddev_pop on columns"""
type payments_payment_stddev_pop_fields {
  amount: Float
  initial_amount: Float
}

"""
order by stddev_pop() on columns of table "payments.payment"
"""
input payments_payment_stddev_pop_order_by {
  amount: order_by
  initial_amount: order_by
}

"""aggregate stddev_samp on columns"""
type payments_payment_stddev_samp_fields {
  amount: Float
  initial_amount: Float
}

"""
order by stddev_samp() on columns of table "payments.payment"
"""
input payments_payment_stddev_samp_order_by {
  amount: order_by
  initial_amount: order_by
}

"""
Streaming cursor of the table "payments_payment"
"""
input payments_payment_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payments_payment_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payments_payment_stream_cursor_value_input {
  amount: numeric
  asset: String
  connector_id: String
  created_at: timestamptz
  destination_account_id: String
  id: String
  initial_amount: numeric
  raw_data: json
  reference: String
  scheme: String
  source_account_id: String
  status: payment_status
  type: payment_type
}

"""aggregate sum on columns"""
type payments_payment_sum_fields {
  amount: numeric
  initial_amount: numeric
}

"""
order by sum() on columns of table "payments.payment"
"""
input payments_payment_sum_order_by {
  amount: order_by
  initial_amount: order_by
}

"""
update columns of table "payments.payment"
"""
enum payments_payment_update_column {
  """column name"""
  amount

  """column name"""
  asset

  """column name"""
  connector_id

  """column name"""
  created_at

  """column name"""
  destination_account_id

  """column name"""
  id

  """column name"""
  initial_amount

  """column name"""
  raw_data

  """column name"""
  reference

  """column name"""
  scheme

  """column name"""
  source_account_id

  """column name"""
  status

  """column name"""
  type
}

input payments_payment_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payments_payment_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: payments_payment_set_input

  """filter the rows which have to be updated"""
  where: payments_payment_bool_exp!
}

"""aggregate var_pop on columns"""
type payments_payment_var_pop_fields {
  amount: Float
  initial_amount: Float
}

"""
order by var_pop() on columns of table "payments.payment"
"""
input payments_payment_var_pop_order_by {
  amount: order_by
  initial_amount: order_by
}

"""aggregate var_samp on columns"""
type payments_payment_var_samp_fields {
  amount: Float
  initial_amount: Float
}

"""
order by var_samp() on columns of table "payments.payment"
"""
input payments_payment_var_samp_order_by {
  amount: order_by
  initial_amount: order_by
}

"""aggregate variance on columns"""
type payments_payment_variance_fields {
  amount: Float
  initial_amount: Float
}

"""
order by variance() on columns of table "payments.payment"
"""
input payments_payment_variance_order_by {
  amount: order_by
  initial_amount: order_by
}

"""
columns and relationships of "payments.transfers"
"""
type payments_transfers {
  amount: numeric!
  connector_id: String!
  created_at: timestamptz!
  currency: String!
  destination: String!
  error: String
  id: uuid!
  payment_id: String
  reference: String
  source: String!
  status: transfer_status!
}

"""
aggregated selection of "payments.transfers"
"""
type payments_transfers_aggregate {
  aggregate: payments_transfers_aggregate_fields
  nodes: [payments_transfers!]!
}

"""
aggregate fields of "payments.transfers"
"""
type payments_transfers_aggregate_fields {
  avg: payments_transfers_avg_fields
  count(columns: [payments_transfers_select_column!], distinct: Boolean): Int!
  max: payments_transfers_max_fields
  min: payments_transfers_min_fields
  stddev: payments_transfers_stddev_fields
  stddev_pop: payments_transfers_stddev_pop_fields
  stddev_samp: payments_transfers_stddev_samp_fields
  sum: payments_transfers_sum_fields
  var_pop: payments_transfers_var_pop_fields
  var_samp: payments_transfers_var_samp_fields
  variance: payments_transfers_variance_fields
}

"""aggregate avg on columns"""
type payments_transfers_avg_fields {
  amount: Float
}

"""
Boolean expression to filter rows from the table "payments.transfers". All fields are combined with a logical 'AND'.
"""
input payments_transfers_bool_exp {
  _and: [payments_transfers_bool_exp!]
  _not: payments_transfers_bool_exp
  _or: [payments_transfers_bool_exp!]
  amount: numeric_comparison_exp
  connector_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  destination: String_comparison_exp
  error: String_comparison_exp
  id: uuid_comparison_exp
  payment_id: String_comparison_exp
  reference: String_comparison_exp
  source: String_comparison_exp
  status: transfer_status_comparison_exp
}

"""
unique or primary key constraints on table "payments.transfers"
"""
enum payments_transfers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  transfer_pk

  """
  unique or primary key constraint on columns "reference"
  """
  transfers_reference_key
}

"""
input type for incrementing numeric columns in table "payments.transfers"
"""
input payments_transfers_inc_input {
  amount: numeric
}

"""
input type for inserting data into table "payments.transfers"
"""
input payments_transfers_insert_input {
  amount: numeric
  connector_id: String
  created_at: timestamptz
  currency: String
  destination: String
  error: String
  id: uuid
  payment_id: String
  reference: String
  source: String
  status: transfer_status
}

"""aggregate max on columns"""
type payments_transfers_max_fields {
  amount: numeric
  connector_id: String
  created_at: timestamptz
  currency: String
  destination: String
  error: String
  id: uuid
  payment_id: String
  reference: String
  source: String
  status: transfer_status
}

"""aggregate min on columns"""
type payments_transfers_min_fields {
  amount: numeric
  connector_id: String
  created_at: timestamptz
  currency: String
  destination: String
  error: String
  id: uuid
  payment_id: String
  reference: String
  source: String
  status: transfer_status
}

"""
response of any mutation on the table "payments.transfers"
"""
type payments_transfers_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payments_transfers!]!
}

"""
on_conflict condition type for table "payments.transfers"
"""
input payments_transfers_on_conflict {
  constraint: payments_transfers_constraint!
  update_columns: [payments_transfers_update_column!]! = []
  where: payments_transfers_bool_exp
}

"""Ordering options when selecting data from "payments.transfers"."""
input payments_transfers_order_by {
  amount: order_by
  connector_id: order_by
  created_at: order_by
  currency: order_by
  destination: order_by
  error: order_by
  id: order_by
  payment_id: order_by
  reference: order_by
  source: order_by
  status: order_by
}

"""primary key columns input for table: payments.transfers"""
input payments_transfers_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payments.transfers"
"""
enum payments_transfers_select_column {
  """column name"""
  amount

  """column name"""
  connector_id

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  destination

  """column name"""
  error

  """column name"""
  id

  """column name"""
  payment_id

  """column name"""
  reference

  """column name"""
  source

  """column name"""
  status
}

"""
input type for updating data in table "payments.transfers"
"""
input payments_transfers_set_input {
  amount: numeric
  connector_id: String
  created_at: timestamptz
  currency: String
  destination: String
  error: String
  id: uuid
  payment_id: String
  reference: String
  source: String
  status: transfer_status
}

"""aggregate stddev on columns"""
type payments_transfers_stddev_fields {
  amount: Float
}

"""aggregate stddev_pop on columns"""
type payments_transfers_stddev_pop_fields {
  amount: Float
}

"""aggregate stddev_samp on columns"""
type payments_transfers_stddev_samp_fields {
  amount: Float
}

"""
Streaming cursor of the table "payments_transfers"
"""
input payments_transfers_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payments_transfers_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payments_transfers_stream_cursor_value_input {
  amount: numeric
  connector_id: String
  created_at: timestamptz
  currency: String
  destination: String
  error: String
  id: uuid
  payment_id: String
  reference: String
  source: String
  status: transfer_status
}

"""aggregate sum on columns"""
type payments_transfers_sum_fields {
  amount: numeric
}

"""
update columns of table "payments.transfers"
"""
enum payments_transfers_update_column {
  """column name"""
  amount

  """column name"""
  connector_id

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  destination

  """column name"""
  error

  """column name"""
  id

  """column name"""
  payment_id

  """column name"""
  reference

  """column name"""
  source

  """column name"""
  status
}

input payments_transfers_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payments_transfers_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: payments_transfers_set_input

  """filter the rows which have to be updated"""
  where: payments_transfers_bool_exp!
}

"""aggregate var_pop on columns"""
type payments_transfers_var_pop_fields {
  amount: Float
}

"""aggregate var_samp on columns"""
type payments_transfers_var_samp_fields {
  amount: Float
}

"""aggregate variance on columns"""
type payments_transfers_variance_fields {
  amount: Float
}

scalar paymentstatus

"""
Boolean expression to compare columns of type "paymentstatus". All fields are combined with logical 'AND'.
"""
input paymentstatus_comparison_exp {
  _eq: paymentstatus
  _gt: paymentstatus
  _gte: paymentstatus
  _in: [paymentstatus!]
  _is_null: Boolean
  _lt: paymentstatus
  _lte: paymentstatus
  _neq: paymentstatus
  _nin: [paymentstatus!]
}

scalar profiletype

"""
Boolean expression to compare columns of type "profiletype". All fields are combined with logical 'AND'.
"""
input profiletype_comparison_exp {
  _eq: profiletype
  _gt: profiletype
  _gte: profiletype
  _in: [profiletype!]
  _is_null: Boolean
  _lt: profiletype
  _lte: profiletype
  _neq: profiletype
  _nin: [profiletype!]
}

type query_root {
  """
  fetch data from the table: "accounts.account"
  """
  accounts_account(
    """distinct select on columns"""
    distinct_on: [accounts_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_account_order_by!]

    """filter the rows returned"""
    where: accounts_account_bool_exp
  ): [accounts_account!]!

  """
  fetch aggregated fields from the table: "accounts.account"
  """
  accounts_account_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_account_order_by!]

    """filter the rows returned"""
    where: accounts_account_bool_exp
  ): accounts_account_aggregate!

  """
  fetch data from the table: "accounts.account" using primary key columns
  """
  accounts_account_by_pk(id: String!): accounts_account

  """
  fetch data from the table: "accounts.balances"
  """
  accounts_balances(
    """distinct select on columns"""
    distinct_on: [accounts_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_balances_order_by!]

    """filter the rows returned"""
    where: accounts_balances_bool_exp
  ): [accounts_balances!]!

  """
  fetch aggregated fields from the table: "accounts.balances"
  """
  accounts_balances_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_balances_order_by!]

    """filter the rows returned"""
    where: accounts_balances_bool_exp
  ): accounts_balances_aggregate!

  """
  fetch data from the table: "accounts.balances" using primary key columns
  """
  accounts_balances_by_pk(account_id: String!, created_at: timestamptz!, currency: String!): accounts_balances

  """
  fetch data from the table: "accounts.bank_account"
  """
  accounts_bank_account(
    """distinct select on columns"""
    distinct_on: [accounts_bank_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_bank_account_order_by!]

    """filter the rows returned"""
    where: accounts_bank_account_bool_exp
  ): [accounts_bank_account!]!

  """
  fetch aggregated fields from the table: "accounts.bank_account"
  """
  accounts_bank_account_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_bank_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_bank_account_order_by!]

    """filter the rows returned"""
    where: accounts_bank_account_bool_exp
  ): accounts_bank_account_aggregate!

  """
  fetch data from the table: "accounts.bank_account" using primary key columns
  """
  accounts_bank_account_by_pk(id: uuid!): accounts_bank_account

  """
  fetch data from the table: "accounts.bank_account_related_accounts"
  """
  accounts_bank_account_related_accounts(
    """distinct select on columns"""
    distinct_on: [accounts_bank_account_related_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_bank_account_related_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bank_account_related_accounts_bool_exp
  ): [accounts_bank_account_related_accounts!]!

  """
  fetch aggregated fields from the table: "accounts.bank_account_related_accounts"
  """
  accounts_bank_account_related_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_bank_account_related_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_bank_account_related_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bank_account_related_accounts_bool_exp
  ): accounts_bank_account_related_accounts_aggregate!

  """
  fetch data from the table: "accounts.bank_account_related_accounts" using primary key columns
  """
  accounts_bank_account_related_accounts_by_pk(id: uuid!): accounts_bank_account_related_accounts

  """
  fetch data from the table: "accounts.pool_accounts"
  """
  accounts_pool_accounts(
    """distinct select on columns"""
    distinct_on: [accounts_pool_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_pool_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_pool_accounts_bool_exp
  ): [accounts_pool_accounts!]!

  """
  fetch aggregated fields from the table: "accounts.pool_accounts"
  """
  accounts_pool_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_pool_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_pool_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_pool_accounts_bool_exp
  ): accounts_pool_accounts_aggregate!

  """
  fetch data from the table: "accounts.pool_accounts" using primary key columns
  """
  accounts_pool_accounts_by_pk(account_id: String!, pool_id: uuid!): accounts_pool_accounts

  """
  fetch data from the table: "accounts.pools"
  """
  accounts_pools(
    """distinct select on columns"""
    distinct_on: [accounts_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_pools_order_by!]

    """filter the rows returned"""
    where: accounts_pools_bool_exp
  ): [accounts_pools!]!

  """
  fetch aggregated fields from the table: "accounts.pools"
  """
  accounts_pools_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_pools_order_by!]

    """filter the rows returned"""
    where: accounts_pools_bool_exp
  ): accounts_pools_aggregate!

  """fetch data from the table: "accounts.pools" using primary key columns"""
  accounts_pools_by_pk(id: uuid!): accounts_pools

  """An array relationship"""
  areas(
    """distinct select on columns"""
    distinct_on: [areas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [areas_order_by!]

    """filter the rows returned"""
    where: areas_bool_exp
  ): [areas!]!

  """An aggregate relationship"""
  areas_aggregate(
    """distinct select on columns"""
    distinct_on: [areas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [areas_order_by!]

    """filter the rows returned"""
    where: areas_bool_exp
  ): areas_aggregate!

  """fetch data from the table: "areas" using primary key columns"""
  areas_by_pk(id: Int!): areas

  """
  fetch data from the table: "audit_logs"
  """
  audit_logs(
    """distinct select on columns"""
    distinct_on: [audit_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_logs_order_by!]

    """filter the rows returned"""
    where: audit_logs_bool_exp
  ): [audit_logs!]!

  """
  fetch aggregated fields from the table: "audit_logs"
  """
  audit_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [audit_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_logs_order_by!]

    """filter the rows returned"""
    where: audit_logs_bool_exp
  ): audit_logs_aggregate!

  """
  fetch data from the table: "checkout_baskets"
  """
  checkout_baskets(
    """distinct select on columns"""
    distinct_on: [checkout_baskets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [checkout_baskets_order_by!]

    """filter the rows returned"""
    where: checkout_baskets_bool_exp
  ): [checkout_baskets!]!

  """
  fetch aggregated fields from the table: "checkout_baskets"
  """
  checkout_baskets_aggregate(
    """distinct select on columns"""
    distinct_on: [checkout_baskets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [checkout_baskets_order_by!]

    """filter the rows returned"""
    where: checkout_baskets_bool_exp
  ): checkout_baskets_aggregate!

  """
  fetch data from the table: "checkout_baskets" using primary key columns
  """
  checkout_baskets_by_pk(id: uuid!): checkout_baskets

  """An array relationship"""
  cities(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): [cities!]!

  """An aggregate relationship"""
  cities_aggregate(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): cities_aggregate!

  """fetch data from the table: "cities" using primary key columns"""
  cities_by_pk(id: Int!): cities

  """
  fetch data from the table: "command"
  """
  command(
    """distinct select on columns"""
    distinct_on: [command_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [command_order_by!]

    """filter the rows returned"""
    where: command_bool_exp
  ): [command!]!

  """
  fetch aggregated fields from the table: "command"
  """
  command_aggregate(
    """distinct select on columns"""
    distinct_on: [command_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [command_order_by!]

    """filter the rows returned"""
    where: command_bool_exp
  ): command_aggregate!

  """fetch data from the table: "command" using primary key columns"""
  command_by_pk(id: Int!): command

  """
  fetch data from the table: "commercial_offer"
  """
  commercial_offer(
    """distinct select on columns"""
    distinct_on: [commercial_offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commercial_offer_order_by!]

    """filter the rows returned"""
    where: commercial_offer_bool_exp
  ): [commercial_offer!]!

  """
  fetch aggregated fields from the table: "commercial_offer"
  """
  commercial_offer_aggregate(
    """distinct select on columns"""
    distinct_on: [commercial_offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commercial_offer_order_by!]

    """filter the rows returned"""
    where: commercial_offer_bool_exp
  ): commercial_offer_aggregate!

  """
  fetch data from the table: "commercial_offer" using primary key columns
  """
  commercial_offer_by_pk(id: String!): commercial_offer

  """
  fetch data from the table: "connectors.connector"
  """
  connectors_connector(
    """distinct select on columns"""
    distinct_on: [connectors_connector_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connectors_connector_order_by!]

    """filter the rows returned"""
    where: connectors_connector_bool_exp
  ): [connectors_connector!]!

  """
  fetch aggregated fields from the table: "connectors.connector"
  """
  connectors_connector_aggregate(
    """distinct select on columns"""
    distinct_on: [connectors_connector_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connectors_connector_order_by!]

    """filter the rows returned"""
    where: connectors_connector_bool_exp
  ): connectors_connector_aggregate!

  """
  fetch data from the table: "connectors.connector" using primary key columns
  """
  connectors_connector_by_pk(id: String!): connectors_connector

  """
  fetch data from the table: "connectors.webhook"
  """
  connectors_webhook(
    """distinct select on columns"""
    distinct_on: [connectors_webhook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connectors_webhook_order_by!]

    """filter the rows returned"""
    where: connectors_webhook_bool_exp
  ): [connectors_webhook!]!

  """
  fetch aggregated fields from the table: "connectors.webhook"
  """
  connectors_webhook_aggregate(
    """distinct select on columns"""
    distinct_on: [connectors_webhook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connectors_webhook_order_by!]

    """filter the rows returned"""
    where: connectors_webhook_bool_exp
  ): connectors_webhook_aggregate!

  """
  fetch data from the table: "connectors.webhook" using primary key columns
  """
  connectors_webhook_by_pk(id: uuid!): connectors_webhook

  """
  fetch data from the table: "consumers"
  """
  consumers(
    """distinct select on columns"""
    distinct_on: [consumers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [consumers_order_by!]

    """filter the rows returned"""
    where: consumers_bool_exp
  ): [consumers!]!

  """
  fetch aggregated fields from the table: "consumers"
  """
  consumers_aggregate(
    """distinct select on columns"""
    distinct_on: [consumers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [consumers_order_by!]

    """filter the rows returned"""
    where: consumers_bool_exp
  ): consumers_aggregate!

  """fetch data from the table: "consumers" using primary key columns"""
  consumers_by_pk(id: uuid!): consumers

  """An array relationship"""
  consumers_credit_limits(
    """distinct select on columns"""
    distinct_on: [consumers_credit_limits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [consumers_credit_limits_order_by!]

    """filter the rows returned"""
    where: consumers_credit_limits_bool_exp
  ): [consumers_credit_limits!]!

  """An aggregate relationship"""
  consumers_credit_limits_aggregate(
    """distinct select on columns"""
    distinct_on: [consumers_credit_limits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [consumers_credit_limits_order_by!]

    """filter the rows returned"""
    where: consumers_credit_limits_bool_exp
  ): consumers_credit_limits_aggregate!

  """
  fetch data from the table: "consumers_credit_limits" using primary key columns
  """
  consumers_credit_limits_by_pk(id: uuid!): consumers_credit_limits

  """
  fetch data from the table: "entry"
  """
  entry(
    """distinct select on columns"""
    distinct_on: [entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entry_order_by!]

    """filter the rows returned"""
    where: entry_bool_exp
  ): [entry!]!

  """
  fetch aggregated fields from the table: "entry"
  """
  entry_aggregate(
    """distinct select on columns"""
    distinct_on: [entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entry_order_by!]

    """filter the rows returned"""
    where: entry_bool_exp
  ): entry_aggregate!

  """fetch data from the table: "entry" using primary key columns"""
  entry_by_pk(id: bigint!): entry

  """
  fetch data from the table: "governorates"
  """
  governorates(
    """distinct select on columns"""
    distinct_on: [governorates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [governorates_order_by!]

    """filter the rows returned"""
    where: governorates_bool_exp
  ): [governorates!]!

  """
  fetch aggregated fields from the table: "governorates"
  """
  governorates_aggregate(
    """distinct select on columns"""
    distinct_on: [governorates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [governorates_order_by!]

    """filter the rows returned"""
    where: governorates_bool_exp
  ): governorates_aggregate!

  """fetch data from the table: "governorates" using primary key columns"""
  governorates_by_pk(id: Int!): governorates

  """
  fetch data from the table: "identities"
  """
  identities(
    """distinct select on columns"""
    distinct_on: [identities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identities_order_by!]

    """filter the rows returned"""
    where: identities_bool_exp
  ): [identities!]!

  """
  fetch aggregated fields from the table: "identities"
  """
  identities_aggregate(
    """distinct select on columns"""
    distinct_on: [identities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identities_order_by!]

    """filter the rows returned"""
    where: identities_bool_exp
  ): identities_aggregate!

  """fetch data from the table: "identities" using primary key columns"""
  identities_by_pk(id: uuid!): identities

  """
  fetch data from the table: "identity_verifiable_addresses"
  """
  identity_verifiable_addresses(
    """distinct select on columns"""
    distinct_on: [identity_verifiable_addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identity_verifiable_addresses_order_by!]

    """filter the rows returned"""
    where: identity_verifiable_addresses_bool_exp
  ): [identity_verifiable_addresses!]!

  """
  fetch aggregated fields from the table: "identity_verifiable_addresses"
  """
  identity_verifiable_addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [identity_verifiable_addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identity_verifiable_addresses_order_by!]

    """filter the rows returned"""
    where: identity_verifiable_addresses_bool_exp
  ): identity_verifiable_addresses_aggregate!

  """
  fetch data from the table: "identity_verifiable_addresses" using primary key columns
  """
  identity_verifiable_addresses_by_pk(id: uuid!): identity_verifiable_addresses

  """
  fetch data from the table: "journal"
  """
  journal(
    """distinct select on columns"""
    distinct_on: [journal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [journal_order_by!]

    """filter the rows returned"""
    where: journal_bool_exp
  ): [journal!]!

  """
  fetch aggregated fields from the table: "journal"
  """
  journal_aggregate(
    """distinct select on columns"""
    distinct_on: [journal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [journal_order_by!]

    """filter the rows returned"""
    where: journal_bool_exp
  ): journal_aggregate!

  """fetch data from the table: "journal" using primary key columns"""
  journal_by_pk(id: Int!): journal

  """
  fetch data from the table: "journal_voucher_entries"
  """
  journal_voucher_entries(
    """distinct select on columns"""
    distinct_on: [journal_voucher_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [journal_voucher_entries_order_by!]

    """filter the rows returned"""
    where: journal_voucher_entries_bool_exp
  ): [journal_voucher_entries!]!

  """
  fetch aggregated fields from the table: "journal_voucher_entries"
  """
  journal_voucher_entries_aggregate(
    """distinct select on columns"""
    distinct_on: [journal_voucher_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [journal_voucher_entries_order_by!]

    """filter the rows returned"""
    where: journal_voucher_entries_bool_exp
  ): journal_voucher_entries_aggregate!

  """
  fetch data from the table: "keto_relation_tuples"
  """
  keto_relation_tuples(
    """distinct select on columns"""
    distinct_on: [keto_relation_tuples_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [keto_relation_tuples_order_by!]

    """filter the rows returned"""
    where: keto_relation_tuples_bool_exp
  ): [keto_relation_tuples!]!

  """
  fetch aggregated fields from the table: "keto_relation_tuples"
  """
  keto_relation_tuples_aggregate(
    """distinct select on columns"""
    distinct_on: [keto_relation_tuples_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [keto_relation_tuples_order_by!]

    """filter the rows returned"""
    where: keto_relation_tuples_bool_exp
  ): keto_relation_tuples_aggregate!

  """
  fetch data from the table: "keto_relation_tuples" using primary key columns
  """
  keto_relation_tuples_by_pk(nid: uuid!, shard_id: uuid!): keto_relation_tuples

  """
  fetch data from the table: "keto_uuid_mappings"
  """
  keto_uuid_mappings(
    """distinct select on columns"""
    distinct_on: [keto_uuid_mappings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [keto_uuid_mappings_order_by!]

    """filter the rows returned"""
    where: keto_uuid_mappings_bool_exp
  ): [keto_uuid_mappings!]!

  """
  fetch aggregated fields from the table: "keto_uuid_mappings"
  """
  keto_uuid_mappings_aggregate(
    """distinct select on columns"""
    distinct_on: [keto_uuid_mappings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [keto_uuid_mappings_order_by!]

    """filter the rows returned"""
    where: keto_uuid_mappings_bool_exp
  ): keto_uuid_mappings_aggregate!

  """
  fetch data from the table: "keto_uuid_mappings" using primary key columns
  """
  keto_uuid_mappings_by_pk(id: uuid!): keto_uuid_mappings

  """
  fetch data from the table: "loan"
  """
  loan(
    """distinct select on columns"""
    distinct_on: [loan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_order_by!]

    """filter the rows returned"""
    where: loan_bool_exp
  ): [loan!]!

  """
  fetch aggregated fields from the table: "loan"
  """
  loan_aggregate(
    """distinct select on columns"""
    distinct_on: [loan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_order_by!]

    """filter the rows returned"""
    where: loan_bool_exp
  ): loan_aggregate!

  """fetch data from the table: "loan" using primary key columns"""
  loan_by_pk(id: String!): loan

  """
  fetch data from the table: "loan_schedule"
  """
  loan_schedule(
    """distinct select on columns"""
    distinct_on: [loan_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_schedule_order_by!]

    """filter the rows returned"""
    where: loan_schedule_bool_exp
  ): [loan_schedule!]!

  """
  fetch aggregated fields from the table: "loan_schedule"
  """
  loan_schedule_aggregate(
    """distinct select on columns"""
    distinct_on: [loan_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_schedule_order_by!]

    """filter the rows returned"""
    where: loan_schedule_bool_exp
  ): loan_schedule_aggregate!

  """fetch data from the table: "loan_schedule" using primary key columns"""
  loan_schedule_by_pk(id: Int!): loan_schedule

  """
  fetch data from the table: "loan_status"
  """
  loan_status(
    """distinct select on columns"""
    distinct_on: [loan_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_status_order_by!]

    """filter the rows returned"""
    where: loan_status_bool_exp
  ): [loan_status!]!

  """
  fetch aggregated fields from the table: "loan_status"
  """
  loan_status_aggregate(
    """distinct select on columns"""
    distinct_on: [loan_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_status_order_by!]

    """filter the rows returned"""
    where: loan_status_bool_exp
  ): loan_status_aggregate!

  """fetch data from the table: "loan_status" using primary key columns"""
  loan_status_by_pk(loan_id: String!, status: String!): loan_status

  """
  fetch data from the table: "merchant_payment"
  """
  merchant_payment(
    """distinct select on columns"""
    distinct_on: [merchant_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [merchant_payment_order_by!]

    """filter the rows returned"""
    where: merchant_payment_bool_exp
  ): [merchant_payment!]!

  """
  fetch aggregated fields from the table: "merchant_payment"
  """
  merchant_payment_aggregate(
    """distinct select on columns"""
    distinct_on: [merchant_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [merchant_payment_order_by!]

    """filter the rows returned"""
    where: merchant_payment_bool_exp
  ): merchant_payment_aggregate!

  """
  fetch data from the table: "merchant_payment" using primary key columns
  """
  merchant_payment_by_pk(id: String!): merchant_payment

  """
  fetch data from the table: "merchant_transaction_slip"
  """
  merchant_transaction_slip(
    """distinct select on columns"""
    distinct_on: [merchant_transaction_slip_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [merchant_transaction_slip_order_by!]

    """filter the rows returned"""
    where: merchant_transaction_slip_bool_exp
  ): [merchant_transaction_slip!]!

  """
  fetch aggregated fields from the table: "merchant_transaction_slip"
  """
  merchant_transaction_slip_aggregate(
    """distinct select on columns"""
    distinct_on: [merchant_transaction_slip_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [merchant_transaction_slip_order_by!]

    """filter the rows returned"""
    where: merchant_transaction_slip_bool_exp
  ): merchant_transaction_slip_aggregate!

  """
  fetch data from the table: "merchant_transaction_slip" using primary key columns
  """
  merchant_transaction_slip_by_pk(id: String!): merchant_transaction_slip

  """
  fetch data from the table: "partner"
  """
  partner(
    """distinct select on columns"""
    distinct_on: [partner_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_order_by!]

    """filter the rows returned"""
    where: partner_bool_exp
  ): [partner!]!

  """
  fetch aggregated fields from the table: "partner"
  """
  partner_aggregate(
    """distinct select on columns"""
    distinct_on: [partner_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_order_by!]

    """filter the rows returned"""
    where: partner_bool_exp
  ): partner_aggregate!

  """
  fetch data from the table: "partner_bank_account"
  """
  partner_bank_account(
    """distinct select on columns"""
    distinct_on: [partner_bank_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_bank_account_order_by!]

    """filter the rows returned"""
    where: partner_bank_account_bool_exp
  ): [partner_bank_account!]!

  """
  fetch aggregated fields from the table: "partner_bank_account"
  """
  partner_bank_account_aggregate(
    """distinct select on columns"""
    distinct_on: [partner_bank_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_bank_account_order_by!]

    """filter the rows returned"""
    where: partner_bank_account_bool_exp
  ): partner_bank_account_aggregate!

  """
  fetch data from the table: "partner_bank_account" using primary key columns
  """
  partner_bank_account_by_pk(id: uuid!): partner_bank_account

  """
  fetch data from the table: "partner_branch"
  """
  partner_branch(
    """distinct select on columns"""
    distinct_on: [partner_branch_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_branch_order_by!]

    """filter the rows returned"""
    where: partner_branch_bool_exp
  ): [partner_branch!]!

  """
  fetch aggregated fields from the table: "partner_branch"
  """
  partner_branch_aggregate(
    """distinct select on columns"""
    distinct_on: [partner_branch_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_branch_order_by!]

    """filter the rows returned"""
    where: partner_branch_bool_exp
  ): partner_branch_aggregate!

  """fetch data from the table: "partner_branch" using primary key columns"""
  partner_branch_by_pk(id: uuid!): partner_branch

  """fetch data from the table: "partner" using primary key columns"""
  partner_by_pk(id: uuid!): partner

  """
  fetch data from the table: "partner_top"
  """
  partner_top(
    """distinct select on columns"""
    distinct_on: [partner_top_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_top_order_by!]

    """filter the rows returned"""
    where: partner_top_bool_exp
  ): [partner_top!]!

  """
  fetch aggregated fields from the table: "partner_top"
  """
  partner_top_aggregate(
    """distinct select on columns"""
    distinct_on: [partner_top_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_top_order_by!]

    """filter the rows returned"""
    where: partner_top_bool_exp
  ): partner_top_aggregate!

  """fetch data from the table: "partner_top" using primary key columns"""
  partner_top_by_pk(id: uuid!): partner_top

  """
  fetch data from the table: "partner_user_profile"
  """
  partner_user_profile(
    """distinct select on columns"""
    distinct_on: [partner_user_profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_user_profile_order_by!]

    """filter the rows returned"""
    where: partner_user_profile_bool_exp
  ): [partner_user_profile!]!

  """
  fetch aggregated fields from the table: "partner_user_profile"
  """
  partner_user_profile_aggregate(
    """distinct select on columns"""
    distinct_on: [partner_user_profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_user_profile_order_by!]

    """filter the rows returned"""
    where: partner_user_profile_bool_exp
  ): partner_user_profile_aggregate!

  """
  fetch data from the table: "partner_user_profile" using primary key columns
  """
  partner_user_profile_by_pk(id: uuid!): partner_user_profile

  """
  fetch data from the table: "party_account"
  """
  party_account(
    """distinct select on columns"""
    distinct_on: [party_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [party_account_order_by!]

    """filter the rows returned"""
    where: party_account_bool_exp
  ): [party_account!]!

  """
  fetch aggregated fields from the table: "party_account"
  """
  party_account_aggregate(
    """distinct select on columns"""
    distinct_on: [party_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [party_account_order_by!]

    """filter the rows returned"""
    where: party_account_bool_exp
  ): party_account_aggregate!

  """fetch data from the table: "party_account" using primary key columns"""
  party_account_by_pk(id: Int!): party_account

  """
  fetch data from the table: "payments.adjustment"
  """
  payments_adjustment(
    """distinct select on columns"""
    distinct_on: [payments_adjustment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_adjustment_order_by!]

    """filter the rows returned"""
    where: payments_adjustment_bool_exp
  ): [payments_adjustment!]!

  """
  fetch aggregated fields from the table: "payments.adjustment"
  """
  payments_adjustment_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_adjustment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_adjustment_order_by!]

    """filter the rows returned"""
    where: payments_adjustment_bool_exp
  ): payments_adjustment_aggregate!

  """
  fetch data from the table: "payments.adjustment" using primary key columns
  """
  payments_adjustment_by_pk(id: uuid!): payments_adjustment

  """
  fetch data from the table: "payments.metadata"
  """
  payments_metadata(
    """distinct select on columns"""
    distinct_on: [payments_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_metadata_order_by!]

    """filter the rows returned"""
    where: payments_metadata_bool_exp
  ): [payments_metadata!]!

  """
  fetch aggregated fields from the table: "payments.metadata"
  """
  payments_metadata_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_metadata_order_by!]

    """filter the rows returned"""
    where: payments_metadata_bool_exp
  ): payments_metadata_aggregate!

  """
  fetch data from the table: "payments.metadata" using primary key columns
  """
  payments_metadata_by_pk(key: String!, payment_id: String!): payments_metadata

  """
  fetch data from the table: "payments.payment"
  """
  payments_payment(
    """distinct select on columns"""
    distinct_on: [payments_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_payment_order_by!]

    """filter the rows returned"""
    where: payments_payment_bool_exp
  ): [payments_payment!]!

  """
  fetch aggregated fields from the table: "payments.payment"
  """
  payments_payment_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_payment_order_by!]

    """filter the rows returned"""
    where: payments_payment_bool_exp
  ): payments_payment_aggregate!

  """
  fetch data from the table: "payments.payment" using primary key columns
  """
  payments_payment_by_pk(id: String!): payments_payment

  """
  fetch data from the table: "payments.transfers"
  """
  payments_transfers(
    """distinct select on columns"""
    distinct_on: [payments_transfers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_transfers_order_by!]

    """filter the rows returned"""
    where: payments_transfers_bool_exp
  ): [payments_transfers!]!

  """
  fetch aggregated fields from the table: "payments.transfers"
  """
  payments_transfers_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_transfers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_transfers_order_by!]

    """filter the rows returned"""
    where: payments_transfers_bool_exp
  ): payments_transfers_aggregate!

  """
  fetch data from the table: "payments.transfers" using primary key columns
  """
  payments_transfers_by_pk(id: uuid!): payments_transfers

  """
  fetch data from the table: "registry_payment"
  """
  registry_payment(
    """distinct select on columns"""
    distinct_on: [registry_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [registry_payment_order_by!]

    """filter the rows returned"""
    where: registry_payment_bool_exp
  ): [registry_payment!]!

  """
  fetch aggregated fields from the table: "registry_payment"
  """
  registry_payment_aggregate(
    """distinct select on columns"""
    distinct_on: [registry_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [registry_payment_order_by!]

    """filter the rows returned"""
    where: registry_payment_bool_exp
  ): registry_payment_aggregate!

  """
  fetch data from the table: "registry_payment" using primary key columns
  """
  registry_payment_by_pk(id: String!): registry_payment

  """
  fetch data from the table: "session_baskets"
  """
  session_baskets(
    """distinct select on columns"""
    distinct_on: [session_baskets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_baskets_order_by!]

    """filter the rows returned"""
    where: session_baskets_bool_exp
  ): [session_baskets!]!

  """
  fetch aggregated fields from the table: "session_baskets"
  """
  session_baskets_aggregate(
    """distinct select on columns"""
    distinct_on: [session_baskets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_baskets_order_by!]

    """filter the rows returned"""
    where: session_baskets_bool_exp
  ): session_baskets_aggregate!

  """fetch data from the table: "session_baskets" using primary key columns"""
  session_baskets_by_pk(id: uuid!): session_baskets

  """
  fetch data from the table: "transfers.transfer_initiation"
  """
  transfers_transfer_initiation(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_bool_exp
  ): [transfers_transfer_initiation!]!

  """
  fetch data from the table: "transfers.transfer_initiation_adjustments"
  """
  transfers_transfer_initiation_adjustments(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_adjustments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_adjustments_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_adjustments_bool_exp
  ): [transfers_transfer_initiation_adjustments!]!

  """
  fetch aggregated fields from the table: "transfers.transfer_initiation_adjustments"
  """
  transfers_transfer_initiation_adjustments_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_adjustments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_adjustments_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_adjustments_bool_exp
  ): transfers_transfer_initiation_adjustments_aggregate!

  """
  fetch data from the table: "transfers.transfer_initiation_adjustments" using primary key columns
  """
  transfers_transfer_initiation_adjustments_by_pk(id: uuid!): transfers_transfer_initiation_adjustments

  """
  fetch aggregated fields from the table: "transfers.transfer_initiation"
  """
  transfers_transfer_initiation_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_bool_exp
  ): transfers_transfer_initiation_aggregate!

  """
  fetch data from the table: "transfers.transfer_initiation" using primary key columns
  """
  transfers_transfer_initiation_by_pk(id: String!): transfers_transfer_initiation

  """
  fetch data from the table: "transfers.transfer_initiation_payments"
  """
  transfers_transfer_initiation_payments(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_payments_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_payments_bool_exp
  ): [transfers_transfer_initiation_payments!]!

  """
  fetch aggregated fields from the table: "transfers.transfer_initiation_payments"
  """
  transfers_transfer_initiation_payments_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_payments_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_payments_bool_exp
  ): transfers_transfer_initiation_payments_aggregate!

  """
  fetch data from the table: "transfers.transfer_initiation_payments" using primary key columns
  """
  transfers_transfer_initiation_payments_by_pk(payment_id: String!, transfer_initiation_id: String!): transfers_transfer_initiation_payments

  """
  fetch data from the table: "transfers.transfer_reversal"
  """
  transfers_transfer_reversal(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_reversal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_reversal_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_reversal_bool_exp
  ): [transfers_transfer_reversal!]!

  """
  fetch aggregated fields from the table: "transfers.transfer_reversal"
  """
  transfers_transfer_reversal_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_reversal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_reversal_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_reversal_bool_exp
  ): transfers_transfer_reversal_aggregate!

  """
  fetch data from the table: "transfers.transfer_reversal" using primary key columns
  """
  transfers_transfer_reversal_by_pk(id: String!): transfers_transfer_reversal
}

"""
columns and relationships of "registry_payment"
"""
type registry_payment {
  amount_currency: currencycode!
  amount_units: Int!
  billing_account: String!
  billing_account_schedule_id: Int!
  booking_time: timestamp!
  channel: paymentchannel!
  channel_reference_id: String!
  channel_transaction_id: String!
  created_at: timestamp!
  created_by: String!
  id: String!
  payee_id: String!
  payee_id_type: payeeidtype!
  payee_type: payeetype!
  raw_request(
    """JSON select path"""
    path: String
  ): jsonb
  status: paymentstatus!
  updated_at: timestamp!
}

"""
aggregated selection of "registry_payment"
"""
type registry_payment_aggregate {
  aggregate: registry_payment_aggregate_fields
  nodes: [registry_payment!]!
}

"""
aggregate fields of "registry_payment"
"""
type registry_payment_aggregate_fields {
  avg: registry_payment_avg_fields
  count(columns: [registry_payment_select_column!], distinct: Boolean): Int!
  max: registry_payment_max_fields
  min: registry_payment_min_fields
  stddev: registry_payment_stddev_fields
  stddev_pop: registry_payment_stddev_pop_fields
  stddev_samp: registry_payment_stddev_samp_fields
  sum: registry_payment_sum_fields
  var_pop: registry_payment_var_pop_fields
  var_samp: registry_payment_var_samp_fields
  variance: registry_payment_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input registry_payment_append_input {
  raw_request: jsonb
}

"""aggregate avg on columns"""
type registry_payment_avg_fields {
  amount_units: Float
  billing_account_schedule_id: Float
}

"""
Boolean expression to filter rows from the table "registry_payment". All fields are combined with a logical 'AND'.
"""
input registry_payment_bool_exp {
  _and: [registry_payment_bool_exp!]
  _not: registry_payment_bool_exp
  _or: [registry_payment_bool_exp!]
  amount_currency: currencycode_comparison_exp
  amount_units: Int_comparison_exp
  billing_account: String_comparison_exp
  billing_account_schedule_id: Int_comparison_exp
  booking_time: timestamp_comparison_exp
  channel: paymentchannel_comparison_exp
  channel_reference_id: String_comparison_exp
  channel_transaction_id: String_comparison_exp
  created_at: timestamp_comparison_exp
  created_by: String_comparison_exp
  id: String_comparison_exp
  payee_id: String_comparison_exp
  payee_id_type: payeeidtype_comparison_exp
  payee_type: payeetype_comparison_exp
  raw_request: jsonb_comparison_exp
  status: paymentstatus_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "registry_payment"
"""
enum registry_payment_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  registry_payment_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input registry_payment_delete_at_path_input {
  raw_request: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input registry_payment_delete_elem_input {
  raw_request: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input registry_payment_delete_key_input {
  raw_request: String
}

"""
input type for incrementing numeric columns in table "registry_payment"
"""
input registry_payment_inc_input {
  amount_units: Int
  billing_account_schedule_id: Int
}

"""
input type for inserting data into table "registry_payment"
"""
input registry_payment_insert_input {
  amount_currency: currencycode
  amount_units: Int
  billing_account: String
  billing_account_schedule_id: Int
  booking_time: timestamp
  channel: paymentchannel
  channel_reference_id: String
  channel_transaction_id: String
  created_at: timestamp
  created_by: String
  id: String
  payee_id: String
  payee_id_type: payeeidtype
  payee_type: payeetype
  raw_request: jsonb
  status: paymentstatus
  updated_at: timestamp
}

"""aggregate max on columns"""
type registry_payment_max_fields {
  amount_currency: currencycode
  amount_units: Int
  billing_account: String
  billing_account_schedule_id: Int
  booking_time: timestamp
  channel: paymentchannel
  channel_reference_id: String
  channel_transaction_id: String
  created_at: timestamp
  created_by: String
  id: String
  payee_id: String
  payee_id_type: payeeidtype
  payee_type: payeetype
  status: paymentstatus
  updated_at: timestamp
}

"""aggregate min on columns"""
type registry_payment_min_fields {
  amount_currency: currencycode
  amount_units: Int
  billing_account: String
  billing_account_schedule_id: Int
  booking_time: timestamp
  channel: paymentchannel
  channel_reference_id: String
  channel_transaction_id: String
  created_at: timestamp
  created_by: String
  id: String
  payee_id: String
  payee_id_type: payeeidtype
  payee_type: payeetype
  status: paymentstatus
  updated_at: timestamp
}

"""
response of any mutation on the table "registry_payment"
"""
type registry_payment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [registry_payment!]!
}

"""
on_conflict condition type for table "registry_payment"
"""
input registry_payment_on_conflict {
  constraint: registry_payment_constraint!
  update_columns: [registry_payment_update_column!]! = []
  where: registry_payment_bool_exp
}

"""Ordering options when selecting data from "registry_payment"."""
input registry_payment_order_by {
  amount_currency: order_by
  amount_units: order_by
  billing_account: order_by
  billing_account_schedule_id: order_by
  booking_time: order_by
  channel: order_by
  channel_reference_id: order_by
  channel_transaction_id: order_by
  created_at: order_by
  created_by: order_by
  id: order_by
  payee_id: order_by
  payee_id_type: order_by
  payee_type: order_by
  raw_request: order_by
  status: order_by
  updated_at: order_by
}

"""primary key columns input for table: registry_payment"""
input registry_payment_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input registry_payment_prepend_input {
  raw_request: jsonb
}

"""
select columns of table "registry_payment"
"""
enum registry_payment_select_column {
  """column name"""
  amount_currency

  """column name"""
  amount_units

  """column name"""
  billing_account

  """column name"""
  billing_account_schedule_id

  """column name"""
  booking_time

  """column name"""
  channel

  """column name"""
  channel_reference_id

  """column name"""
  channel_transaction_id

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  id

  """column name"""
  payee_id

  """column name"""
  payee_id_type

  """column name"""
  payee_type

  """column name"""
  raw_request

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "registry_payment"
"""
input registry_payment_set_input {
  amount_currency: currencycode
  amount_units: Int
  billing_account: String
  billing_account_schedule_id: Int
  booking_time: timestamp
  channel: paymentchannel
  channel_reference_id: String
  channel_transaction_id: String
  created_at: timestamp
  created_by: String
  id: String
  payee_id: String
  payee_id_type: payeeidtype
  payee_type: payeetype
  raw_request: jsonb
  status: paymentstatus
  updated_at: timestamp
}

"""aggregate stddev on columns"""
type registry_payment_stddev_fields {
  amount_units: Float
  billing_account_schedule_id: Float
}

"""aggregate stddev_pop on columns"""
type registry_payment_stddev_pop_fields {
  amount_units: Float
  billing_account_schedule_id: Float
}

"""aggregate stddev_samp on columns"""
type registry_payment_stddev_samp_fields {
  amount_units: Float
  billing_account_schedule_id: Float
}

"""
Streaming cursor of the table "registry_payment"
"""
input registry_payment_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: registry_payment_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input registry_payment_stream_cursor_value_input {
  amount_currency: currencycode
  amount_units: Int
  billing_account: String
  billing_account_schedule_id: Int
  booking_time: timestamp
  channel: paymentchannel
  channel_reference_id: String
  channel_transaction_id: String
  created_at: timestamp
  created_by: String
  id: String
  payee_id: String
  payee_id_type: payeeidtype
  payee_type: payeetype
  raw_request: jsonb
  status: paymentstatus
  updated_at: timestamp
}

"""aggregate sum on columns"""
type registry_payment_sum_fields {
  amount_units: Int
  billing_account_schedule_id: Int
}

"""
update columns of table "registry_payment"
"""
enum registry_payment_update_column {
  """column name"""
  amount_currency

  """column name"""
  amount_units

  """column name"""
  billing_account

  """column name"""
  billing_account_schedule_id

  """column name"""
  booking_time

  """column name"""
  channel

  """column name"""
  channel_reference_id

  """column name"""
  channel_transaction_id

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  id

  """column name"""
  payee_id

  """column name"""
  payee_id_type

  """column name"""
  payee_type

  """column name"""
  raw_request

  """column name"""
  status

  """column name"""
  updated_at
}

input registry_payment_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: registry_payment_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: registry_payment_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: registry_payment_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: registry_payment_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: registry_payment_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: registry_payment_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: registry_payment_set_input

  """filter the rows which have to be updated"""
  where: registry_payment_bool_exp!
}

"""aggregate var_pop on columns"""
type registry_payment_var_pop_fields {
  amount_units: Float
  billing_account_schedule_id: Float
}

"""aggregate var_samp on columns"""
type registry_payment_var_samp_fields {
  amount_units: Float
  billing_account_schedule_id: Float
}

"""aggregate variance on columns"""
type registry_payment_variance_fields {
  amount_units: Float
  billing_account_schedule_id: Float
}

"""
columns and relationships of "session_baskets"
"""
type session_baskets {
  branch_id: uuid
  cashier_id: uuid!

  """An object relationship"""
  checkout_basket: checkout_baskets
  consumer_id: uuid
  created_at: timestamp!
  id: uuid!
  partner_id: uuid!
  partner_name: String!
  product(
    """JSON select path"""
    path: String
  ): jsonb!
  status: String!
  updated_at: timestamp!
}

"""
aggregated selection of "session_baskets"
"""
type session_baskets_aggregate {
  aggregate: session_baskets_aggregate_fields
  nodes: [session_baskets!]!
}

"""
aggregate fields of "session_baskets"
"""
type session_baskets_aggregate_fields {
  count(columns: [session_baskets_select_column!], distinct: Boolean): Int!
  max: session_baskets_max_fields
  min: session_baskets_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input session_baskets_append_input {
  product: jsonb
}

"""
Boolean expression to filter rows from the table "session_baskets". All fields are combined with a logical 'AND'.
"""
input session_baskets_bool_exp {
  _and: [session_baskets_bool_exp!]
  _not: session_baskets_bool_exp
  _or: [session_baskets_bool_exp!]
  branch_id: uuid_comparison_exp
  cashier_id: uuid_comparison_exp
  checkout_basket: checkout_baskets_bool_exp
  consumer_id: uuid_comparison_exp
  created_at: timestamp_comparison_exp
  id: uuid_comparison_exp
  partner_id: uuid_comparison_exp
  partner_name: String_comparison_exp
  product: jsonb_comparison_exp
  status: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "session_baskets"
"""
enum session_baskets_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  session_baskets_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input session_baskets_delete_at_path_input {
  product: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input session_baskets_delete_elem_input {
  product: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input session_baskets_delete_key_input {
  product: String
}

"""
input type for inserting data into table "session_baskets"
"""
input session_baskets_insert_input {
  branch_id: uuid
  cashier_id: uuid
  checkout_basket: checkout_baskets_obj_rel_insert_input
  consumer_id: uuid
  created_at: timestamp
  id: uuid
  partner_id: uuid
  partner_name: String
  product: jsonb
  status: String
  updated_at: timestamp
}

"""aggregate max on columns"""
type session_baskets_max_fields {
  branch_id: uuid
  cashier_id: uuid
  consumer_id: uuid
  created_at: timestamp
  id: uuid
  partner_id: uuid
  partner_name: String
  status: String
  updated_at: timestamp
}

"""aggregate min on columns"""
type session_baskets_min_fields {
  branch_id: uuid
  cashier_id: uuid
  consumer_id: uuid
  created_at: timestamp
  id: uuid
  partner_id: uuid
  partner_name: String
  status: String
  updated_at: timestamp
}

"""
response of any mutation on the table "session_baskets"
"""
type session_baskets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [session_baskets!]!
}

"""
input type for inserting object relation for remote table "session_baskets"
"""
input session_baskets_obj_rel_insert_input {
  data: session_baskets_insert_input!

  """upsert condition"""
  on_conflict: session_baskets_on_conflict
}

"""
on_conflict condition type for table "session_baskets"
"""
input session_baskets_on_conflict {
  constraint: session_baskets_constraint!
  update_columns: [session_baskets_update_column!]! = []
  where: session_baskets_bool_exp
}

"""Ordering options when selecting data from "session_baskets"."""
input session_baskets_order_by {
  branch_id: order_by
  cashier_id: order_by
  checkout_basket: checkout_baskets_order_by
  consumer_id: order_by
  created_at: order_by
  id: order_by
  partner_id: order_by
  partner_name: order_by
  product: order_by
  status: order_by
  updated_at: order_by
}

"""primary key columns input for table: session_baskets"""
input session_baskets_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input session_baskets_prepend_input {
  product: jsonb
}

"""
select columns of table "session_baskets"
"""
enum session_baskets_select_column {
  """column name"""
  branch_id

  """column name"""
  cashier_id

  """column name"""
  consumer_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  partner_id

  """column name"""
  partner_name

  """column name"""
  product

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "session_baskets"
"""
input session_baskets_set_input {
  branch_id: uuid
  cashier_id: uuid
  consumer_id: uuid
  created_at: timestamp
  id: uuid
  partner_id: uuid
  partner_name: String
  product: jsonb
  status: String
  updated_at: timestamp
}

"""
Streaming cursor of the table "session_baskets"
"""
input session_baskets_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: session_baskets_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input session_baskets_stream_cursor_value_input {
  branch_id: uuid
  cashier_id: uuid
  consumer_id: uuid
  created_at: timestamp
  id: uuid
  partner_id: uuid
  partner_name: String
  product: jsonb
  status: String
  updated_at: timestamp
}

"""
update columns of table "session_baskets"
"""
enum session_baskets_update_column {
  """column name"""
  branch_id

  """column name"""
  cashier_id

  """column name"""
  consumer_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  partner_id

  """column name"""
  partner_name

  """column name"""
  product

  """column name"""
  status

  """column name"""
  updated_at
}

input session_baskets_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: session_baskets_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: session_baskets_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: session_baskets_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: session_baskets_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: session_baskets_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: session_baskets_set_input

  """filter the rows which have to be updated"""
  where: session_baskets_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "accounts.account"
  """
  accounts_account(
    """distinct select on columns"""
    distinct_on: [accounts_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_account_order_by!]

    """filter the rows returned"""
    where: accounts_account_bool_exp
  ): [accounts_account!]!

  """
  fetch aggregated fields from the table: "accounts.account"
  """
  accounts_account_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_account_order_by!]

    """filter the rows returned"""
    where: accounts_account_bool_exp
  ): accounts_account_aggregate!

  """
  fetch data from the table: "accounts.account" using primary key columns
  """
  accounts_account_by_pk(id: String!): accounts_account

  """
  fetch data from the table in a streaming manner: "accounts.account"
  """
  accounts_account_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [accounts_account_stream_cursor_input]!

    """filter the rows returned"""
    where: accounts_account_bool_exp
  ): [accounts_account!]!

  """
  fetch data from the table: "accounts.balances"
  """
  accounts_balances(
    """distinct select on columns"""
    distinct_on: [accounts_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_balances_order_by!]

    """filter the rows returned"""
    where: accounts_balances_bool_exp
  ): [accounts_balances!]!

  """
  fetch aggregated fields from the table: "accounts.balances"
  """
  accounts_balances_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_balances_order_by!]

    """filter the rows returned"""
    where: accounts_balances_bool_exp
  ): accounts_balances_aggregate!

  """
  fetch data from the table: "accounts.balances" using primary key columns
  """
  accounts_balances_by_pk(account_id: String!, created_at: timestamptz!, currency: String!): accounts_balances

  """
  fetch data from the table in a streaming manner: "accounts.balances"
  """
  accounts_balances_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [accounts_balances_stream_cursor_input]!

    """filter the rows returned"""
    where: accounts_balances_bool_exp
  ): [accounts_balances!]!

  """
  fetch data from the table: "accounts.bank_account"
  """
  accounts_bank_account(
    """distinct select on columns"""
    distinct_on: [accounts_bank_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_bank_account_order_by!]

    """filter the rows returned"""
    where: accounts_bank_account_bool_exp
  ): [accounts_bank_account!]!

  """
  fetch aggregated fields from the table: "accounts.bank_account"
  """
  accounts_bank_account_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_bank_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_bank_account_order_by!]

    """filter the rows returned"""
    where: accounts_bank_account_bool_exp
  ): accounts_bank_account_aggregate!

  """
  fetch data from the table: "accounts.bank_account" using primary key columns
  """
  accounts_bank_account_by_pk(id: uuid!): accounts_bank_account

  """
  fetch data from the table: "accounts.bank_account_related_accounts"
  """
  accounts_bank_account_related_accounts(
    """distinct select on columns"""
    distinct_on: [accounts_bank_account_related_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_bank_account_related_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bank_account_related_accounts_bool_exp
  ): [accounts_bank_account_related_accounts!]!

  """
  fetch aggregated fields from the table: "accounts.bank_account_related_accounts"
  """
  accounts_bank_account_related_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_bank_account_related_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_bank_account_related_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bank_account_related_accounts_bool_exp
  ): accounts_bank_account_related_accounts_aggregate!

  """
  fetch data from the table: "accounts.bank_account_related_accounts" using primary key columns
  """
  accounts_bank_account_related_accounts_by_pk(id: uuid!): accounts_bank_account_related_accounts

  """
  fetch data from the table in a streaming manner: "accounts.bank_account_related_accounts"
  """
  accounts_bank_account_related_accounts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [accounts_bank_account_related_accounts_stream_cursor_input]!

    """filter the rows returned"""
    where: accounts_bank_account_related_accounts_bool_exp
  ): [accounts_bank_account_related_accounts!]!

  """
  fetch data from the table in a streaming manner: "accounts.bank_account"
  """
  accounts_bank_account_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [accounts_bank_account_stream_cursor_input]!

    """filter the rows returned"""
    where: accounts_bank_account_bool_exp
  ): [accounts_bank_account!]!

  """
  fetch data from the table: "accounts.pool_accounts"
  """
  accounts_pool_accounts(
    """distinct select on columns"""
    distinct_on: [accounts_pool_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_pool_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_pool_accounts_bool_exp
  ): [accounts_pool_accounts!]!

  """
  fetch aggregated fields from the table: "accounts.pool_accounts"
  """
  accounts_pool_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_pool_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_pool_accounts_order_by!]

    """filter the rows returned"""
    where: accounts_pool_accounts_bool_exp
  ): accounts_pool_accounts_aggregate!

  """
  fetch data from the table: "accounts.pool_accounts" using primary key columns
  """
  accounts_pool_accounts_by_pk(account_id: String!, pool_id: uuid!): accounts_pool_accounts

  """
  fetch data from the table in a streaming manner: "accounts.pool_accounts"
  """
  accounts_pool_accounts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [accounts_pool_accounts_stream_cursor_input]!

    """filter the rows returned"""
    where: accounts_pool_accounts_bool_exp
  ): [accounts_pool_accounts!]!

  """
  fetch data from the table: "accounts.pools"
  """
  accounts_pools(
    """distinct select on columns"""
    distinct_on: [accounts_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_pools_order_by!]

    """filter the rows returned"""
    where: accounts_pools_bool_exp
  ): [accounts_pools!]!

  """
  fetch aggregated fields from the table: "accounts.pools"
  """
  accounts_pools_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_pools_order_by!]

    """filter the rows returned"""
    where: accounts_pools_bool_exp
  ): accounts_pools_aggregate!

  """fetch data from the table: "accounts.pools" using primary key columns"""
  accounts_pools_by_pk(id: uuid!): accounts_pools

  """
  fetch data from the table in a streaming manner: "accounts.pools"
  """
  accounts_pools_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [accounts_pools_stream_cursor_input]!

    """filter the rows returned"""
    where: accounts_pools_bool_exp
  ): [accounts_pools!]!

  """An array relationship"""
  areas(
    """distinct select on columns"""
    distinct_on: [areas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [areas_order_by!]

    """filter the rows returned"""
    where: areas_bool_exp
  ): [areas!]!

  """An aggregate relationship"""
  areas_aggregate(
    """distinct select on columns"""
    distinct_on: [areas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [areas_order_by!]

    """filter the rows returned"""
    where: areas_bool_exp
  ): areas_aggregate!

  """fetch data from the table: "areas" using primary key columns"""
  areas_by_pk(id: Int!): areas

  """
  fetch data from the table in a streaming manner: "areas"
  """
  areas_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [areas_stream_cursor_input]!

    """filter the rows returned"""
    where: areas_bool_exp
  ): [areas!]!

  """
  fetch data from the table: "audit_logs"
  """
  audit_logs(
    """distinct select on columns"""
    distinct_on: [audit_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_logs_order_by!]

    """filter the rows returned"""
    where: audit_logs_bool_exp
  ): [audit_logs!]!

  """
  fetch aggregated fields from the table: "audit_logs"
  """
  audit_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [audit_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_logs_order_by!]

    """filter the rows returned"""
    where: audit_logs_bool_exp
  ): audit_logs_aggregate!

  """
  fetch data from the table in a streaming manner: "audit_logs"
  """
  audit_logs_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [audit_logs_stream_cursor_input]!

    """filter the rows returned"""
    where: audit_logs_bool_exp
  ): [audit_logs!]!

  """
  fetch data from the table: "checkout_baskets"
  """
  checkout_baskets(
    """distinct select on columns"""
    distinct_on: [checkout_baskets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [checkout_baskets_order_by!]

    """filter the rows returned"""
    where: checkout_baskets_bool_exp
  ): [checkout_baskets!]!

  """
  fetch aggregated fields from the table: "checkout_baskets"
  """
  checkout_baskets_aggregate(
    """distinct select on columns"""
    distinct_on: [checkout_baskets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [checkout_baskets_order_by!]

    """filter the rows returned"""
    where: checkout_baskets_bool_exp
  ): checkout_baskets_aggregate!

  """
  fetch data from the table: "checkout_baskets" using primary key columns
  """
  checkout_baskets_by_pk(id: uuid!): checkout_baskets

  """
  fetch data from the table in a streaming manner: "checkout_baskets"
  """
  checkout_baskets_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [checkout_baskets_stream_cursor_input]!

    """filter the rows returned"""
    where: checkout_baskets_bool_exp
  ): [checkout_baskets!]!

  """An array relationship"""
  cities(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): [cities!]!

  """An aggregate relationship"""
  cities_aggregate(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): cities_aggregate!

  """fetch data from the table: "cities" using primary key columns"""
  cities_by_pk(id: Int!): cities

  """
  fetch data from the table in a streaming manner: "cities"
  """
  cities_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [cities_stream_cursor_input]!

    """filter the rows returned"""
    where: cities_bool_exp
  ): [cities!]!

  """
  fetch data from the table: "command"
  """
  command(
    """distinct select on columns"""
    distinct_on: [command_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [command_order_by!]

    """filter the rows returned"""
    where: command_bool_exp
  ): [command!]!

  """
  fetch aggregated fields from the table: "command"
  """
  command_aggregate(
    """distinct select on columns"""
    distinct_on: [command_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [command_order_by!]

    """filter the rows returned"""
    where: command_bool_exp
  ): command_aggregate!

  """fetch data from the table: "command" using primary key columns"""
  command_by_pk(id: Int!): command

  """
  fetch data from the table in a streaming manner: "command"
  """
  command_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [command_stream_cursor_input]!

    """filter the rows returned"""
    where: command_bool_exp
  ): [command!]!

  """
  fetch data from the table: "commercial_offer"
  """
  commercial_offer(
    """distinct select on columns"""
    distinct_on: [commercial_offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commercial_offer_order_by!]

    """filter the rows returned"""
    where: commercial_offer_bool_exp
  ): [commercial_offer!]!

  """
  fetch aggregated fields from the table: "commercial_offer"
  """
  commercial_offer_aggregate(
    """distinct select on columns"""
    distinct_on: [commercial_offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commercial_offer_order_by!]

    """filter the rows returned"""
    where: commercial_offer_bool_exp
  ): commercial_offer_aggregate!

  """
  fetch data from the table: "commercial_offer" using primary key columns
  """
  commercial_offer_by_pk(id: String!): commercial_offer

  """
  fetch data from the table in a streaming manner: "commercial_offer"
  """
  commercial_offer_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [commercial_offer_stream_cursor_input]!

    """filter the rows returned"""
    where: commercial_offer_bool_exp
  ): [commercial_offer!]!

  """
  fetch data from the table: "connectors.connector"
  """
  connectors_connector(
    """distinct select on columns"""
    distinct_on: [connectors_connector_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connectors_connector_order_by!]

    """filter the rows returned"""
    where: connectors_connector_bool_exp
  ): [connectors_connector!]!

  """
  fetch aggregated fields from the table: "connectors.connector"
  """
  connectors_connector_aggregate(
    """distinct select on columns"""
    distinct_on: [connectors_connector_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connectors_connector_order_by!]

    """filter the rows returned"""
    where: connectors_connector_bool_exp
  ): connectors_connector_aggregate!

  """
  fetch data from the table: "connectors.connector" using primary key columns
  """
  connectors_connector_by_pk(id: String!): connectors_connector

  """
  fetch data from the table in a streaming manner: "connectors.connector"
  """
  connectors_connector_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [connectors_connector_stream_cursor_input]!

    """filter the rows returned"""
    where: connectors_connector_bool_exp
  ): [connectors_connector!]!

  """
  fetch data from the table: "connectors.webhook"
  """
  connectors_webhook(
    """distinct select on columns"""
    distinct_on: [connectors_webhook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connectors_webhook_order_by!]

    """filter the rows returned"""
    where: connectors_webhook_bool_exp
  ): [connectors_webhook!]!

  """
  fetch aggregated fields from the table: "connectors.webhook"
  """
  connectors_webhook_aggregate(
    """distinct select on columns"""
    distinct_on: [connectors_webhook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connectors_webhook_order_by!]

    """filter the rows returned"""
    where: connectors_webhook_bool_exp
  ): connectors_webhook_aggregate!

  """
  fetch data from the table: "connectors.webhook" using primary key columns
  """
  connectors_webhook_by_pk(id: uuid!): connectors_webhook

  """
  fetch data from the table in a streaming manner: "connectors.webhook"
  """
  connectors_webhook_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [connectors_webhook_stream_cursor_input]!

    """filter the rows returned"""
    where: connectors_webhook_bool_exp
  ): [connectors_webhook!]!

  """
  fetch data from the table: "consumers"
  """
  consumers(
    """distinct select on columns"""
    distinct_on: [consumers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [consumers_order_by!]

    """filter the rows returned"""
    where: consumers_bool_exp
  ): [consumers!]!

  """
  fetch aggregated fields from the table: "consumers"
  """
  consumers_aggregate(
    """distinct select on columns"""
    distinct_on: [consumers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [consumers_order_by!]

    """filter the rows returned"""
    where: consumers_bool_exp
  ): consumers_aggregate!

  """fetch data from the table: "consumers" using primary key columns"""
  consumers_by_pk(id: uuid!): consumers

  """An array relationship"""
  consumers_credit_limits(
    """distinct select on columns"""
    distinct_on: [consumers_credit_limits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [consumers_credit_limits_order_by!]

    """filter the rows returned"""
    where: consumers_credit_limits_bool_exp
  ): [consumers_credit_limits!]!

  """An aggregate relationship"""
  consumers_credit_limits_aggregate(
    """distinct select on columns"""
    distinct_on: [consumers_credit_limits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [consumers_credit_limits_order_by!]

    """filter the rows returned"""
    where: consumers_credit_limits_bool_exp
  ): consumers_credit_limits_aggregate!

  """
  fetch data from the table: "consumers_credit_limits" using primary key columns
  """
  consumers_credit_limits_by_pk(id: uuid!): consumers_credit_limits

  """
  fetch data from the table in a streaming manner: "consumers_credit_limits"
  """
  consumers_credit_limits_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [consumers_credit_limits_stream_cursor_input]!

    """filter the rows returned"""
    where: consumers_credit_limits_bool_exp
  ): [consumers_credit_limits!]!

  """
  fetch data from the table in a streaming manner: "consumers"
  """
  consumers_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [consumers_stream_cursor_input]!

    """filter the rows returned"""
    where: consumers_bool_exp
  ): [consumers!]!

  """
  fetch data from the table: "entry"
  """
  entry(
    """distinct select on columns"""
    distinct_on: [entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entry_order_by!]

    """filter the rows returned"""
    where: entry_bool_exp
  ): [entry!]!

  """
  fetch aggregated fields from the table: "entry"
  """
  entry_aggregate(
    """distinct select on columns"""
    distinct_on: [entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entry_order_by!]

    """filter the rows returned"""
    where: entry_bool_exp
  ): entry_aggregate!

  """fetch data from the table: "entry" using primary key columns"""
  entry_by_pk(id: bigint!): entry

  """
  fetch data from the table in a streaming manner: "entry"
  """
  entry_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [entry_stream_cursor_input]!

    """filter the rows returned"""
    where: entry_bool_exp
  ): [entry!]!

  """
  fetch data from the table: "governorates"
  """
  governorates(
    """distinct select on columns"""
    distinct_on: [governorates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [governorates_order_by!]

    """filter the rows returned"""
    where: governorates_bool_exp
  ): [governorates!]!

  """
  fetch aggregated fields from the table: "governorates"
  """
  governorates_aggregate(
    """distinct select on columns"""
    distinct_on: [governorates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [governorates_order_by!]

    """filter the rows returned"""
    where: governorates_bool_exp
  ): governorates_aggregate!

  """fetch data from the table: "governorates" using primary key columns"""
  governorates_by_pk(id: Int!): governorates

  """
  fetch data from the table in a streaming manner: "governorates"
  """
  governorates_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [governorates_stream_cursor_input]!

    """filter the rows returned"""
    where: governorates_bool_exp
  ): [governorates!]!

  """
  fetch data from the table: "identities"
  """
  identities(
    """distinct select on columns"""
    distinct_on: [identities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identities_order_by!]

    """filter the rows returned"""
    where: identities_bool_exp
  ): [identities!]!

  """
  fetch aggregated fields from the table: "identities"
  """
  identities_aggregate(
    """distinct select on columns"""
    distinct_on: [identities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identities_order_by!]

    """filter the rows returned"""
    where: identities_bool_exp
  ): identities_aggregate!

  """fetch data from the table: "identities" using primary key columns"""
  identities_by_pk(id: uuid!): identities

  """
  fetch data from the table in a streaming manner: "identities"
  """
  identities_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [identities_stream_cursor_input]!

    """filter the rows returned"""
    where: identities_bool_exp
  ): [identities!]!

  """
  fetch data from the table: "identity_verifiable_addresses"
  """
  identity_verifiable_addresses(
    """distinct select on columns"""
    distinct_on: [identity_verifiable_addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identity_verifiable_addresses_order_by!]

    """filter the rows returned"""
    where: identity_verifiable_addresses_bool_exp
  ): [identity_verifiable_addresses!]!

  """
  fetch aggregated fields from the table: "identity_verifiable_addresses"
  """
  identity_verifiable_addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [identity_verifiable_addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identity_verifiable_addresses_order_by!]

    """filter the rows returned"""
    where: identity_verifiable_addresses_bool_exp
  ): identity_verifiable_addresses_aggregate!

  """
  fetch data from the table: "identity_verifiable_addresses" using primary key columns
  """
  identity_verifiable_addresses_by_pk(id: uuid!): identity_verifiable_addresses

  """
  fetch data from the table in a streaming manner: "identity_verifiable_addresses"
  """
  identity_verifiable_addresses_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [identity_verifiable_addresses_stream_cursor_input]!

    """filter the rows returned"""
    where: identity_verifiable_addresses_bool_exp
  ): [identity_verifiable_addresses!]!

  """
  fetch data from the table: "journal"
  """
  journal(
    """distinct select on columns"""
    distinct_on: [journal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [journal_order_by!]

    """filter the rows returned"""
    where: journal_bool_exp
  ): [journal!]!

  """
  fetch aggregated fields from the table: "journal"
  """
  journal_aggregate(
    """distinct select on columns"""
    distinct_on: [journal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [journal_order_by!]

    """filter the rows returned"""
    where: journal_bool_exp
  ): journal_aggregate!

  """fetch data from the table: "journal" using primary key columns"""
  journal_by_pk(id: Int!): journal

  """
  fetch data from the table in a streaming manner: "journal"
  """
  journal_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [journal_stream_cursor_input]!

    """filter the rows returned"""
    where: journal_bool_exp
  ): [journal!]!

  """
  fetch data from the table: "journal_voucher_entries"
  """
  journal_voucher_entries(
    """distinct select on columns"""
    distinct_on: [journal_voucher_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [journal_voucher_entries_order_by!]

    """filter the rows returned"""
    where: journal_voucher_entries_bool_exp
  ): [journal_voucher_entries!]!

  """
  fetch aggregated fields from the table: "journal_voucher_entries"
  """
  journal_voucher_entries_aggregate(
    """distinct select on columns"""
    distinct_on: [journal_voucher_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [journal_voucher_entries_order_by!]

    """filter the rows returned"""
    where: journal_voucher_entries_bool_exp
  ): journal_voucher_entries_aggregate!

  """
  fetch data from the table in a streaming manner: "journal_voucher_entries"
  """
  journal_voucher_entries_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [journal_voucher_entries_stream_cursor_input]!

    """filter the rows returned"""
    where: journal_voucher_entries_bool_exp
  ): [journal_voucher_entries!]!

  """
  fetch data from the table: "keto_relation_tuples"
  """
  keto_relation_tuples(
    """distinct select on columns"""
    distinct_on: [keto_relation_tuples_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [keto_relation_tuples_order_by!]

    """filter the rows returned"""
    where: keto_relation_tuples_bool_exp
  ): [keto_relation_tuples!]!

  """
  fetch aggregated fields from the table: "keto_relation_tuples"
  """
  keto_relation_tuples_aggregate(
    """distinct select on columns"""
    distinct_on: [keto_relation_tuples_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [keto_relation_tuples_order_by!]

    """filter the rows returned"""
    where: keto_relation_tuples_bool_exp
  ): keto_relation_tuples_aggregate!

  """
  fetch data from the table: "keto_relation_tuples" using primary key columns
  """
  keto_relation_tuples_by_pk(nid: uuid!, shard_id: uuid!): keto_relation_tuples

  """
  fetch data from the table in a streaming manner: "keto_relation_tuples"
  """
  keto_relation_tuples_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [keto_relation_tuples_stream_cursor_input]!

    """filter the rows returned"""
    where: keto_relation_tuples_bool_exp
  ): [keto_relation_tuples!]!

  """
  fetch data from the table: "keto_uuid_mappings"
  """
  keto_uuid_mappings(
    """distinct select on columns"""
    distinct_on: [keto_uuid_mappings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [keto_uuid_mappings_order_by!]

    """filter the rows returned"""
    where: keto_uuid_mappings_bool_exp
  ): [keto_uuid_mappings!]!

  """
  fetch aggregated fields from the table: "keto_uuid_mappings"
  """
  keto_uuid_mappings_aggregate(
    """distinct select on columns"""
    distinct_on: [keto_uuid_mappings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [keto_uuid_mappings_order_by!]

    """filter the rows returned"""
    where: keto_uuid_mappings_bool_exp
  ): keto_uuid_mappings_aggregate!

  """
  fetch data from the table: "keto_uuid_mappings" using primary key columns
  """
  keto_uuid_mappings_by_pk(id: uuid!): keto_uuid_mappings

  """
  fetch data from the table in a streaming manner: "keto_uuid_mappings"
  """
  keto_uuid_mappings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [keto_uuid_mappings_stream_cursor_input]!

    """filter the rows returned"""
    where: keto_uuid_mappings_bool_exp
  ): [keto_uuid_mappings!]!

  """
  fetch data from the table: "loan"
  """
  loan(
    """distinct select on columns"""
    distinct_on: [loan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_order_by!]

    """filter the rows returned"""
    where: loan_bool_exp
  ): [loan!]!

  """
  fetch aggregated fields from the table: "loan"
  """
  loan_aggregate(
    """distinct select on columns"""
    distinct_on: [loan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_order_by!]

    """filter the rows returned"""
    where: loan_bool_exp
  ): loan_aggregate!

  """fetch data from the table: "loan" using primary key columns"""
  loan_by_pk(id: String!): loan

  """
  fetch data from the table: "loan_schedule"
  """
  loan_schedule(
    """distinct select on columns"""
    distinct_on: [loan_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_schedule_order_by!]

    """filter the rows returned"""
    where: loan_schedule_bool_exp
  ): [loan_schedule!]!

  """
  fetch aggregated fields from the table: "loan_schedule"
  """
  loan_schedule_aggregate(
    """distinct select on columns"""
    distinct_on: [loan_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_schedule_order_by!]

    """filter the rows returned"""
    where: loan_schedule_bool_exp
  ): loan_schedule_aggregate!

  """fetch data from the table: "loan_schedule" using primary key columns"""
  loan_schedule_by_pk(id: Int!): loan_schedule

  """
  fetch data from the table in a streaming manner: "loan_schedule"
  """
  loan_schedule_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [loan_schedule_stream_cursor_input]!

    """filter the rows returned"""
    where: loan_schedule_bool_exp
  ): [loan_schedule!]!

  """
  fetch data from the table: "loan_status"
  """
  loan_status(
    """distinct select on columns"""
    distinct_on: [loan_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_status_order_by!]

    """filter the rows returned"""
    where: loan_status_bool_exp
  ): [loan_status!]!

  """
  fetch aggregated fields from the table: "loan_status"
  """
  loan_status_aggregate(
    """distinct select on columns"""
    distinct_on: [loan_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [loan_status_order_by!]

    """filter the rows returned"""
    where: loan_status_bool_exp
  ): loan_status_aggregate!

  """fetch data from the table: "loan_status" using primary key columns"""
  loan_status_by_pk(loan_id: String!, status: String!): loan_status

  """
  fetch data from the table in a streaming manner: "loan_status"
  """
  loan_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [loan_status_stream_cursor_input]!

    """filter the rows returned"""
    where: loan_status_bool_exp
  ): [loan_status!]!

  """
  fetch data from the table in a streaming manner: "loan"
  """
  loan_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [loan_stream_cursor_input]!

    """filter the rows returned"""
    where: loan_bool_exp
  ): [loan!]!

  """
  fetch data from the table: "merchant_payment"
  """
  merchant_payment(
    """distinct select on columns"""
    distinct_on: [merchant_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [merchant_payment_order_by!]

    """filter the rows returned"""
    where: merchant_payment_bool_exp
  ): [merchant_payment!]!

  """
  fetch aggregated fields from the table: "merchant_payment"
  """
  merchant_payment_aggregate(
    """distinct select on columns"""
    distinct_on: [merchant_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [merchant_payment_order_by!]

    """filter the rows returned"""
    where: merchant_payment_bool_exp
  ): merchant_payment_aggregate!

  """
  fetch data from the table: "merchant_payment" using primary key columns
  """
  merchant_payment_by_pk(id: String!): merchant_payment

  """
  fetch data from the table in a streaming manner: "merchant_payment"
  """
  merchant_payment_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [merchant_payment_stream_cursor_input]!

    """filter the rows returned"""
    where: merchant_payment_bool_exp
  ): [merchant_payment!]!

  """
  fetch data from the table: "merchant_transaction_slip"
  """
  merchant_transaction_slip(
    """distinct select on columns"""
    distinct_on: [merchant_transaction_slip_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [merchant_transaction_slip_order_by!]

    """filter the rows returned"""
    where: merchant_transaction_slip_bool_exp
  ): [merchant_transaction_slip!]!

  """
  fetch aggregated fields from the table: "merchant_transaction_slip"
  """
  merchant_transaction_slip_aggregate(
    """distinct select on columns"""
    distinct_on: [merchant_transaction_slip_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [merchant_transaction_slip_order_by!]

    """filter the rows returned"""
    where: merchant_transaction_slip_bool_exp
  ): merchant_transaction_slip_aggregate!

  """
  fetch data from the table: "merchant_transaction_slip" using primary key columns
  """
  merchant_transaction_slip_by_pk(id: String!): merchant_transaction_slip

  """
  fetch data from the table in a streaming manner: "merchant_transaction_slip"
  """
  merchant_transaction_slip_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [merchant_transaction_slip_stream_cursor_input]!

    """filter the rows returned"""
    where: merchant_transaction_slip_bool_exp
  ): [merchant_transaction_slip!]!

  """
  fetch data from the table: "partner"
  """
  partner(
    """distinct select on columns"""
    distinct_on: [partner_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_order_by!]

    """filter the rows returned"""
    where: partner_bool_exp
  ): [partner!]!

  """
  fetch aggregated fields from the table: "partner"
  """
  partner_aggregate(
    """distinct select on columns"""
    distinct_on: [partner_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_order_by!]

    """filter the rows returned"""
    where: partner_bool_exp
  ): partner_aggregate!

  """
  fetch data from the table: "partner_bank_account"
  """
  partner_bank_account(
    """distinct select on columns"""
    distinct_on: [partner_bank_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_bank_account_order_by!]

    """filter the rows returned"""
    where: partner_bank_account_bool_exp
  ): [partner_bank_account!]!

  """
  fetch aggregated fields from the table: "partner_bank_account"
  """
  partner_bank_account_aggregate(
    """distinct select on columns"""
    distinct_on: [partner_bank_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_bank_account_order_by!]

    """filter the rows returned"""
    where: partner_bank_account_bool_exp
  ): partner_bank_account_aggregate!

  """
  fetch data from the table: "partner_bank_account" using primary key columns
  """
  partner_bank_account_by_pk(id: uuid!): partner_bank_account

  """
  fetch data from the table in a streaming manner: "partner_bank_account"
  """
  partner_bank_account_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [partner_bank_account_stream_cursor_input]!

    """filter the rows returned"""
    where: partner_bank_account_bool_exp
  ): [partner_bank_account!]!

  """
  fetch data from the table: "partner_branch"
  """
  partner_branch(
    """distinct select on columns"""
    distinct_on: [partner_branch_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_branch_order_by!]

    """filter the rows returned"""
    where: partner_branch_bool_exp
  ): [partner_branch!]!

  """
  fetch aggregated fields from the table: "partner_branch"
  """
  partner_branch_aggregate(
    """distinct select on columns"""
    distinct_on: [partner_branch_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_branch_order_by!]

    """filter the rows returned"""
    where: partner_branch_bool_exp
  ): partner_branch_aggregate!

  """fetch data from the table: "partner_branch" using primary key columns"""
  partner_branch_by_pk(id: uuid!): partner_branch

  """
  fetch data from the table in a streaming manner: "partner_branch"
  """
  partner_branch_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [partner_branch_stream_cursor_input]!

    """filter the rows returned"""
    where: partner_branch_bool_exp
  ): [partner_branch!]!

  """fetch data from the table: "partner" using primary key columns"""
  partner_by_pk(id: uuid!): partner

  """
  fetch data from the table in a streaming manner: "partner"
  """
  partner_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [partner_stream_cursor_input]!

    """filter the rows returned"""
    where: partner_bool_exp
  ): [partner!]!

  """
  fetch data from the table: "partner_top"
  """
  partner_top(
    """distinct select on columns"""
    distinct_on: [partner_top_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_top_order_by!]

    """filter the rows returned"""
    where: partner_top_bool_exp
  ): [partner_top!]!

  """
  fetch aggregated fields from the table: "partner_top"
  """
  partner_top_aggregate(
    """distinct select on columns"""
    distinct_on: [partner_top_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_top_order_by!]

    """filter the rows returned"""
    where: partner_top_bool_exp
  ): partner_top_aggregate!

  """fetch data from the table: "partner_top" using primary key columns"""
  partner_top_by_pk(id: uuid!): partner_top

  """
  fetch data from the table in a streaming manner: "partner_top"
  """
  partner_top_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [partner_top_stream_cursor_input]!

    """filter the rows returned"""
    where: partner_top_bool_exp
  ): [partner_top!]!

  """
  fetch data from the table: "partner_user_profile"
  """
  partner_user_profile(
    """distinct select on columns"""
    distinct_on: [partner_user_profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_user_profile_order_by!]

    """filter the rows returned"""
    where: partner_user_profile_bool_exp
  ): [partner_user_profile!]!

  """
  fetch aggregated fields from the table: "partner_user_profile"
  """
  partner_user_profile_aggregate(
    """distinct select on columns"""
    distinct_on: [partner_user_profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partner_user_profile_order_by!]

    """filter the rows returned"""
    where: partner_user_profile_bool_exp
  ): partner_user_profile_aggregate!

  """
  fetch data from the table: "partner_user_profile" using primary key columns
  """
  partner_user_profile_by_pk(id: uuid!): partner_user_profile

  """
  fetch data from the table in a streaming manner: "partner_user_profile"
  """
  partner_user_profile_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [partner_user_profile_stream_cursor_input]!

    """filter the rows returned"""
    where: partner_user_profile_bool_exp
  ): [partner_user_profile!]!

  """
  fetch data from the table: "party_account"
  """
  party_account(
    """distinct select on columns"""
    distinct_on: [party_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [party_account_order_by!]

    """filter the rows returned"""
    where: party_account_bool_exp
  ): [party_account!]!

  """
  fetch aggregated fields from the table: "party_account"
  """
  party_account_aggregate(
    """distinct select on columns"""
    distinct_on: [party_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [party_account_order_by!]

    """filter the rows returned"""
    where: party_account_bool_exp
  ): party_account_aggregate!

  """fetch data from the table: "party_account" using primary key columns"""
  party_account_by_pk(id: Int!): party_account

  """
  fetch data from the table in a streaming manner: "party_account"
  """
  party_account_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [party_account_stream_cursor_input]!

    """filter the rows returned"""
    where: party_account_bool_exp
  ): [party_account!]!

  """
  fetch data from the table: "payments.adjustment"
  """
  payments_adjustment(
    """distinct select on columns"""
    distinct_on: [payments_adjustment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_adjustment_order_by!]

    """filter the rows returned"""
    where: payments_adjustment_bool_exp
  ): [payments_adjustment!]!

  """
  fetch aggregated fields from the table: "payments.adjustment"
  """
  payments_adjustment_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_adjustment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_adjustment_order_by!]

    """filter the rows returned"""
    where: payments_adjustment_bool_exp
  ): payments_adjustment_aggregate!

  """
  fetch data from the table: "payments.adjustment" using primary key columns
  """
  payments_adjustment_by_pk(id: uuid!): payments_adjustment

  """
  fetch data from the table in a streaming manner: "payments.adjustment"
  """
  payments_adjustment_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payments_adjustment_stream_cursor_input]!

    """filter the rows returned"""
    where: payments_adjustment_bool_exp
  ): [payments_adjustment!]!

  """
  fetch data from the table: "payments.metadata"
  """
  payments_metadata(
    """distinct select on columns"""
    distinct_on: [payments_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_metadata_order_by!]

    """filter the rows returned"""
    where: payments_metadata_bool_exp
  ): [payments_metadata!]!

  """
  fetch aggregated fields from the table: "payments.metadata"
  """
  payments_metadata_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_metadata_order_by!]

    """filter the rows returned"""
    where: payments_metadata_bool_exp
  ): payments_metadata_aggregate!

  """
  fetch data from the table: "payments.metadata" using primary key columns
  """
  payments_metadata_by_pk(key: String!, payment_id: String!): payments_metadata

  """
  fetch data from the table in a streaming manner: "payments.metadata"
  """
  payments_metadata_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payments_metadata_stream_cursor_input]!

    """filter the rows returned"""
    where: payments_metadata_bool_exp
  ): [payments_metadata!]!

  """
  fetch data from the table: "payments.payment"
  """
  payments_payment(
    """distinct select on columns"""
    distinct_on: [payments_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_payment_order_by!]

    """filter the rows returned"""
    where: payments_payment_bool_exp
  ): [payments_payment!]!

  """
  fetch aggregated fields from the table: "payments.payment"
  """
  payments_payment_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_payment_order_by!]

    """filter the rows returned"""
    where: payments_payment_bool_exp
  ): payments_payment_aggregate!

  """
  fetch data from the table: "payments.payment" using primary key columns
  """
  payments_payment_by_pk(id: String!): payments_payment

  """
  fetch data from the table in a streaming manner: "payments.payment"
  """
  payments_payment_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payments_payment_stream_cursor_input]!

    """filter the rows returned"""
    where: payments_payment_bool_exp
  ): [payments_payment!]!

  """
  fetch data from the table: "payments.transfers"
  """
  payments_transfers(
    """distinct select on columns"""
    distinct_on: [payments_transfers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_transfers_order_by!]

    """filter the rows returned"""
    where: payments_transfers_bool_exp
  ): [payments_transfers!]!

  """
  fetch aggregated fields from the table: "payments.transfers"
  """
  payments_transfers_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_transfers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_transfers_order_by!]

    """filter the rows returned"""
    where: payments_transfers_bool_exp
  ): payments_transfers_aggregate!

  """
  fetch data from the table: "payments.transfers" using primary key columns
  """
  payments_transfers_by_pk(id: uuid!): payments_transfers

  """
  fetch data from the table in a streaming manner: "payments.transfers"
  """
  payments_transfers_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payments_transfers_stream_cursor_input]!

    """filter the rows returned"""
    where: payments_transfers_bool_exp
  ): [payments_transfers!]!

  """
  fetch data from the table: "registry_payment"
  """
  registry_payment(
    """distinct select on columns"""
    distinct_on: [registry_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [registry_payment_order_by!]

    """filter the rows returned"""
    where: registry_payment_bool_exp
  ): [registry_payment!]!

  """
  fetch aggregated fields from the table: "registry_payment"
  """
  registry_payment_aggregate(
    """distinct select on columns"""
    distinct_on: [registry_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [registry_payment_order_by!]

    """filter the rows returned"""
    where: registry_payment_bool_exp
  ): registry_payment_aggregate!

  """
  fetch data from the table: "registry_payment" using primary key columns
  """
  registry_payment_by_pk(id: String!): registry_payment

  """
  fetch data from the table in a streaming manner: "registry_payment"
  """
  registry_payment_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [registry_payment_stream_cursor_input]!

    """filter the rows returned"""
    where: registry_payment_bool_exp
  ): [registry_payment!]!

  """
  fetch data from the table: "session_baskets"
  """
  session_baskets(
    """distinct select on columns"""
    distinct_on: [session_baskets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_baskets_order_by!]

    """filter the rows returned"""
    where: session_baskets_bool_exp
  ): [session_baskets!]!

  """
  fetch aggregated fields from the table: "session_baskets"
  """
  session_baskets_aggregate(
    """distinct select on columns"""
    distinct_on: [session_baskets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_baskets_order_by!]

    """filter the rows returned"""
    where: session_baskets_bool_exp
  ): session_baskets_aggregate!

  """fetch data from the table: "session_baskets" using primary key columns"""
  session_baskets_by_pk(id: uuid!): session_baskets

  """
  fetch data from the table in a streaming manner: "session_baskets"
  """
  session_baskets_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [session_baskets_stream_cursor_input]!

    """filter the rows returned"""
    where: session_baskets_bool_exp
  ): [session_baskets!]!

  """
  fetch data from the table: "transfers.transfer_initiation"
  """
  transfers_transfer_initiation(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_bool_exp
  ): [transfers_transfer_initiation!]!

  """
  fetch data from the table: "transfers.transfer_initiation_adjustments"
  """
  transfers_transfer_initiation_adjustments(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_adjustments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_adjustments_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_adjustments_bool_exp
  ): [transfers_transfer_initiation_adjustments!]!

  """
  fetch aggregated fields from the table: "transfers.transfer_initiation_adjustments"
  """
  transfers_transfer_initiation_adjustments_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_adjustments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_adjustments_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_adjustments_bool_exp
  ): transfers_transfer_initiation_adjustments_aggregate!

  """
  fetch data from the table: "transfers.transfer_initiation_adjustments" using primary key columns
  """
  transfers_transfer_initiation_adjustments_by_pk(id: uuid!): transfers_transfer_initiation_adjustments

  """
  fetch data from the table in a streaming manner: "transfers.transfer_initiation_adjustments"
  """
  transfers_transfer_initiation_adjustments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [transfers_transfer_initiation_adjustments_stream_cursor_input]!

    """filter the rows returned"""
    where: transfers_transfer_initiation_adjustments_bool_exp
  ): [transfers_transfer_initiation_adjustments!]!

  """
  fetch aggregated fields from the table: "transfers.transfer_initiation"
  """
  transfers_transfer_initiation_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_bool_exp
  ): transfers_transfer_initiation_aggregate!

  """
  fetch data from the table: "transfers.transfer_initiation" using primary key columns
  """
  transfers_transfer_initiation_by_pk(id: String!): transfers_transfer_initiation

  """
  fetch data from the table: "transfers.transfer_initiation_payments"
  """
  transfers_transfer_initiation_payments(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_payments_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_payments_bool_exp
  ): [transfers_transfer_initiation_payments!]!

  """
  fetch aggregated fields from the table: "transfers.transfer_initiation_payments"
  """
  transfers_transfer_initiation_payments_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_payments_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_payments_bool_exp
  ): transfers_transfer_initiation_payments_aggregate!

  """
  fetch data from the table: "transfers.transfer_initiation_payments" using primary key columns
  """
  transfers_transfer_initiation_payments_by_pk(payment_id: String!, transfer_initiation_id: String!): transfers_transfer_initiation_payments

  """
  fetch data from the table in a streaming manner: "transfers.transfer_initiation_payments"
  """
  transfers_transfer_initiation_payments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [transfers_transfer_initiation_payments_stream_cursor_input]!

    """filter the rows returned"""
    where: transfers_transfer_initiation_payments_bool_exp
  ): [transfers_transfer_initiation_payments!]!

  """
  fetch data from the table in a streaming manner: "transfers.transfer_initiation"
  """
  transfers_transfer_initiation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [transfers_transfer_initiation_stream_cursor_input]!

    """filter the rows returned"""
    where: transfers_transfer_initiation_bool_exp
  ): [transfers_transfer_initiation!]!

  """
  fetch data from the table: "transfers.transfer_reversal"
  """
  transfers_transfer_reversal(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_reversal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_reversal_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_reversal_bool_exp
  ): [transfers_transfer_reversal!]!

  """
  fetch aggregated fields from the table: "transfers.transfer_reversal"
  """
  transfers_transfer_reversal_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_reversal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_reversal_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_reversal_bool_exp
  ): transfers_transfer_reversal_aggregate!

  """
  fetch data from the table: "transfers.transfer_reversal" using primary key columns
  """
  transfers_transfer_reversal_by_pk(id: String!): transfers_transfer_reversal

  """
  fetch data from the table in a streaming manner: "transfers.transfer_reversal"
  """
  transfers_transfer_reversal_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [transfers_transfer_reversal_stream_cursor_input]!

    """filter the rows returned"""
    where: transfers_transfer_reversal_bool_exp
  ): [transfers_transfer_reversal!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar transfer_status

"""
Boolean expression to compare columns of type "transfer_status". All fields are combined with logical 'AND'.
"""
input transfer_status_comparison_exp {
  _eq: transfer_status
  _gt: transfer_status
  _gte: transfer_status
  _in: [transfer_status!]
  _is_null: Boolean
  _lt: transfer_status
  _lte: transfer_status
  _neq: transfer_status
  _nin: [transfer_status!]
}

"""
columns and relationships of "transfers.transfer_initiation"
"""
type transfers_transfer_initiation {
  """An object relationship"""
  account: accounts_account!

  """An object relationship"""
  accountBySourceAccountId: accounts_account
  amount: numeric!
  asset: String!
  attempts: Int!

  """An object relationship"""
  connector: connectors_connector!
  connector_id: String!
  created_at: timestamptz!
  description: String
  destination_account_id: String!
  id: String!
  initial_amount: numeric!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  provider: connector_provider!
  scheduled_at: timestamptz
  source_account_id: String

  """An array relationship"""
  transfer_initiation_adjustments(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_adjustments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_adjustments_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_adjustments_bool_exp
  ): [transfers_transfer_initiation_adjustments!]!

  """An aggregate relationship"""
  transfer_initiation_adjustments_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_adjustments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_adjustments_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_adjustments_bool_exp
  ): transfers_transfer_initiation_adjustments_aggregate!

  """An array relationship"""
  transfer_initiation_payments(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_payments_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_payments_bool_exp
  ): [transfers_transfer_initiation_payments!]!

  """An aggregate relationship"""
  transfer_initiation_payments_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_initiation_payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_initiation_payments_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_initiation_payments_bool_exp
  ): transfers_transfer_initiation_payments_aggregate!

  """An array relationship"""
  transfer_reversals(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_reversal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_reversal_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_reversal_bool_exp
  ): [transfers_transfer_reversal!]!

  """An aggregate relationship"""
  transfer_reversals_aggregate(
    """distinct select on columns"""
    distinct_on: [transfers_transfer_reversal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transfers_transfer_reversal_order_by!]

    """filter the rows returned"""
    where: transfers_transfer_reversal_bool_exp
  ): transfers_transfer_reversal_aggregate!
  type: Int!
}

"""
columns and relationships of "transfers.transfer_initiation_adjustments"
"""
type transfers_transfer_initiation_adjustments {
  created_at: timestamptz!
  error: String
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  status: Int!

  """An object relationship"""
  transfer_initiation: transfers_transfer_initiation!
  transfer_initiation_id: String!
}

"""
aggregated selection of "transfers.transfer_initiation_adjustments"
"""
type transfers_transfer_initiation_adjustments_aggregate {
  aggregate: transfers_transfer_initiation_adjustments_aggregate_fields
  nodes: [transfers_transfer_initiation_adjustments!]!
}

input transfers_transfer_initiation_adjustments_aggregate_bool_exp {
  count: transfers_transfer_initiation_adjustments_aggregate_bool_exp_count
}

input transfers_transfer_initiation_adjustments_aggregate_bool_exp_count {
  arguments: [transfers_transfer_initiation_adjustments_select_column!]
  distinct: Boolean
  filter: transfers_transfer_initiation_adjustments_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "transfers.transfer_initiation_adjustments"
"""
type transfers_transfer_initiation_adjustments_aggregate_fields {
  avg: transfers_transfer_initiation_adjustments_avg_fields
  count(columns: [transfers_transfer_initiation_adjustments_select_column!], distinct: Boolean): Int!
  max: transfers_transfer_initiation_adjustments_max_fields
  min: transfers_transfer_initiation_adjustments_min_fields
  stddev: transfers_transfer_initiation_adjustments_stddev_fields
  stddev_pop: transfers_transfer_initiation_adjustments_stddev_pop_fields
  stddev_samp: transfers_transfer_initiation_adjustments_stddev_samp_fields
  sum: transfers_transfer_initiation_adjustments_sum_fields
  var_pop: transfers_transfer_initiation_adjustments_var_pop_fields
  var_samp: transfers_transfer_initiation_adjustments_var_samp_fields
  variance: transfers_transfer_initiation_adjustments_variance_fields
}

"""
order by aggregate values of table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_aggregate_order_by {
  avg: transfers_transfer_initiation_adjustments_avg_order_by
  count: order_by
  max: transfers_transfer_initiation_adjustments_max_order_by
  min: transfers_transfer_initiation_adjustments_min_order_by
  stddev: transfers_transfer_initiation_adjustments_stddev_order_by
  stddev_pop: transfers_transfer_initiation_adjustments_stddev_pop_order_by
  stddev_samp: transfers_transfer_initiation_adjustments_stddev_samp_order_by
  sum: transfers_transfer_initiation_adjustments_sum_order_by
  var_pop: transfers_transfer_initiation_adjustments_var_pop_order_by
  var_samp: transfers_transfer_initiation_adjustments_var_samp_order_by
  variance: transfers_transfer_initiation_adjustments_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input transfers_transfer_initiation_adjustments_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_arr_rel_insert_input {
  data: [transfers_transfer_initiation_adjustments_insert_input!]!

  """upsert condition"""
  on_conflict: transfers_transfer_initiation_adjustments_on_conflict
}

"""aggregate avg on columns"""
type transfers_transfer_initiation_adjustments_avg_fields {
  status: Float
}

"""
order by avg() on columns of table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_avg_order_by {
  status: order_by
}

"""
Boolean expression to filter rows from the table "transfers.transfer_initiation_adjustments". All fields are combined with a logical 'AND'.
"""
input transfers_transfer_initiation_adjustments_bool_exp {
  _and: [transfers_transfer_initiation_adjustments_bool_exp!]
  _not: transfers_transfer_initiation_adjustments_bool_exp
  _or: [transfers_transfer_initiation_adjustments_bool_exp!]
  created_at: timestamptz_comparison_exp
  error: String_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  status: Int_comparison_exp
  transfer_initiation: transfers_transfer_initiation_bool_exp
  transfer_initiation_id: String_comparison_exp
}

"""
unique or primary key constraints on table "transfers.transfer_initiation_adjustments"
"""
enum transfers_transfer_initiation_adjustments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  transfer_initiation_adjustments_pk
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input transfers_transfer_initiation_adjustments_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input transfers_transfer_initiation_adjustments_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input transfers_transfer_initiation_adjustments_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_inc_input {
  status: Int
}

"""
input type for inserting data into table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_insert_input {
  created_at: timestamptz
  error: String
  id: uuid
  metadata: jsonb
  status: Int
  transfer_initiation: transfers_transfer_initiation_obj_rel_insert_input
  transfer_initiation_id: String
}

"""aggregate max on columns"""
type transfers_transfer_initiation_adjustments_max_fields {
  created_at: timestamptz
  error: String
  id: uuid
  status: Int
  transfer_initiation_id: String
}

"""
order by max() on columns of table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_max_order_by {
  created_at: order_by
  error: order_by
  id: order_by
  status: order_by
  transfer_initiation_id: order_by
}

"""aggregate min on columns"""
type transfers_transfer_initiation_adjustments_min_fields {
  created_at: timestamptz
  error: String
  id: uuid
  status: Int
  transfer_initiation_id: String
}

"""
order by min() on columns of table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_min_order_by {
  created_at: order_by
  error: order_by
  id: order_by
  status: order_by
  transfer_initiation_id: order_by
}

"""
response of any mutation on the table "transfers.transfer_initiation_adjustments"
"""
type transfers_transfer_initiation_adjustments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [transfers_transfer_initiation_adjustments!]!
}

"""
on_conflict condition type for table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_on_conflict {
  constraint: transfers_transfer_initiation_adjustments_constraint!
  update_columns: [transfers_transfer_initiation_adjustments_update_column!]! = []
  where: transfers_transfer_initiation_adjustments_bool_exp
}

"""
Ordering options when selecting data from "transfers.transfer_initiation_adjustments".
"""
input transfers_transfer_initiation_adjustments_order_by {
  created_at: order_by
  error: order_by
  id: order_by
  metadata: order_by
  status: order_by
  transfer_initiation: transfers_transfer_initiation_order_by
  transfer_initiation_id: order_by
}

"""
primary key columns input for table: transfers.transfer_initiation_adjustments
"""
input transfers_transfer_initiation_adjustments_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input transfers_transfer_initiation_adjustments_prepend_input {
  metadata: jsonb
}

"""
select columns of table "transfers.transfer_initiation_adjustments"
"""
enum transfers_transfer_initiation_adjustments_select_column {
  """column name"""
  created_at

  """column name"""
  error

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  status

  """column name"""
  transfer_initiation_id
}

"""
input type for updating data in table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_set_input {
  created_at: timestamptz
  error: String
  id: uuid
  metadata: jsonb
  status: Int
  transfer_initiation_id: String
}

"""aggregate stddev on columns"""
type transfers_transfer_initiation_adjustments_stddev_fields {
  status: Float
}

"""
order by stddev() on columns of table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_stddev_order_by {
  status: order_by
}

"""aggregate stddev_pop on columns"""
type transfers_transfer_initiation_adjustments_stddev_pop_fields {
  status: Float
}

"""
order by stddev_pop() on columns of table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_stddev_pop_order_by {
  status: order_by
}

"""aggregate stddev_samp on columns"""
type transfers_transfer_initiation_adjustments_stddev_samp_fields {
  status: Float
}

"""
order by stddev_samp() on columns of table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_stddev_samp_order_by {
  status: order_by
}

"""
Streaming cursor of the table "transfers_transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: transfers_transfer_initiation_adjustments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input transfers_transfer_initiation_adjustments_stream_cursor_value_input {
  created_at: timestamptz
  error: String
  id: uuid
  metadata: jsonb
  status: Int
  transfer_initiation_id: String
}

"""aggregate sum on columns"""
type transfers_transfer_initiation_adjustments_sum_fields {
  status: Int
}

"""
order by sum() on columns of table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_sum_order_by {
  status: order_by
}

"""
update columns of table "transfers.transfer_initiation_adjustments"
"""
enum transfers_transfer_initiation_adjustments_update_column {
  """column name"""
  created_at

  """column name"""
  error

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  status

  """column name"""
  transfer_initiation_id
}

input transfers_transfer_initiation_adjustments_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: transfers_transfer_initiation_adjustments_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: transfers_transfer_initiation_adjustments_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: transfers_transfer_initiation_adjustments_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: transfers_transfer_initiation_adjustments_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: transfers_transfer_initiation_adjustments_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: transfers_transfer_initiation_adjustments_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: transfers_transfer_initiation_adjustments_set_input

  """filter the rows which have to be updated"""
  where: transfers_transfer_initiation_adjustments_bool_exp!
}

"""aggregate var_pop on columns"""
type transfers_transfer_initiation_adjustments_var_pop_fields {
  status: Float
}

"""
order by var_pop() on columns of table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_var_pop_order_by {
  status: order_by
}

"""aggregate var_samp on columns"""
type transfers_transfer_initiation_adjustments_var_samp_fields {
  status: Float
}

"""
order by var_samp() on columns of table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_var_samp_order_by {
  status: order_by
}

"""aggregate variance on columns"""
type transfers_transfer_initiation_adjustments_variance_fields {
  status: Float
}

"""
order by variance() on columns of table "transfers.transfer_initiation_adjustments"
"""
input transfers_transfer_initiation_adjustments_variance_order_by {
  status: order_by
}

"""
aggregated selection of "transfers.transfer_initiation"
"""
type transfers_transfer_initiation_aggregate {
  aggregate: transfers_transfer_initiation_aggregate_fields
  nodes: [transfers_transfer_initiation!]!
}

input transfers_transfer_initiation_aggregate_bool_exp {
  count: transfers_transfer_initiation_aggregate_bool_exp_count
}

input transfers_transfer_initiation_aggregate_bool_exp_count {
  arguments: [transfers_transfer_initiation_select_column!]
  distinct: Boolean
  filter: transfers_transfer_initiation_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "transfers.transfer_initiation"
"""
type transfers_transfer_initiation_aggregate_fields {
  avg: transfers_transfer_initiation_avg_fields
  count(columns: [transfers_transfer_initiation_select_column!], distinct: Boolean): Int!
  max: transfers_transfer_initiation_max_fields
  min: transfers_transfer_initiation_min_fields
  stddev: transfers_transfer_initiation_stddev_fields
  stddev_pop: transfers_transfer_initiation_stddev_pop_fields
  stddev_samp: transfers_transfer_initiation_stddev_samp_fields
  sum: transfers_transfer_initiation_sum_fields
  var_pop: transfers_transfer_initiation_var_pop_fields
  var_samp: transfers_transfer_initiation_var_samp_fields
  variance: transfers_transfer_initiation_variance_fields
}

"""
order by aggregate values of table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_aggregate_order_by {
  avg: transfers_transfer_initiation_avg_order_by
  count: order_by
  max: transfers_transfer_initiation_max_order_by
  min: transfers_transfer_initiation_min_order_by
  stddev: transfers_transfer_initiation_stddev_order_by
  stddev_pop: transfers_transfer_initiation_stddev_pop_order_by
  stddev_samp: transfers_transfer_initiation_stddev_samp_order_by
  sum: transfers_transfer_initiation_sum_order_by
  var_pop: transfers_transfer_initiation_var_pop_order_by
  var_samp: transfers_transfer_initiation_var_samp_order_by
  variance: transfers_transfer_initiation_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input transfers_transfer_initiation_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_arr_rel_insert_input {
  data: [transfers_transfer_initiation_insert_input!]!

  """upsert condition"""
  on_conflict: transfers_transfer_initiation_on_conflict
}

"""aggregate avg on columns"""
type transfers_transfer_initiation_avg_fields {
  amount: Float
  attempts: Float
  initial_amount: Float
  type: Float
}

"""
order by avg() on columns of table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_avg_order_by {
  amount: order_by
  attempts: order_by
  initial_amount: order_by
  type: order_by
}

"""
Boolean expression to filter rows from the table "transfers.transfer_initiation". All fields are combined with a logical 'AND'.
"""
input transfers_transfer_initiation_bool_exp {
  _and: [transfers_transfer_initiation_bool_exp!]
  _not: transfers_transfer_initiation_bool_exp
  _or: [transfers_transfer_initiation_bool_exp!]
  account: accounts_account_bool_exp
  accountBySourceAccountId: accounts_account_bool_exp
  amount: numeric_comparison_exp
  asset: String_comparison_exp
  attempts: Int_comparison_exp
  connector: connectors_connector_bool_exp
  connector_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  destination_account_id: String_comparison_exp
  id: String_comparison_exp
  initial_amount: numeric_comparison_exp
  metadata: jsonb_comparison_exp
  provider: connector_provider_comparison_exp
  scheduled_at: timestamptz_comparison_exp
  source_account_id: String_comparison_exp
  transfer_initiation_adjustments: transfers_transfer_initiation_adjustments_bool_exp
  transfer_initiation_adjustments_aggregate: transfers_transfer_initiation_adjustments_aggregate_bool_exp
  transfer_initiation_payments: transfers_transfer_initiation_payments_bool_exp
  transfer_initiation_payments_aggregate: transfers_transfer_initiation_payments_aggregate_bool_exp
  transfer_reversals: transfers_transfer_reversal_bool_exp
  transfer_reversals_aggregate: transfers_transfer_reversal_aggregate_bool_exp
  type: Int_comparison_exp
}

"""
unique or primary key constraints on table "transfers.transfer_initiation"
"""
enum transfers_transfer_initiation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  transfer_initiation_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input transfers_transfer_initiation_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input transfers_transfer_initiation_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input transfers_transfer_initiation_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_inc_input {
  amount: numeric
  attempts: Int
  initial_amount: numeric
  type: Int
}

"""
input type for inserting data into table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_insert_input {
  account: accounts_account_obj_rel_insert_input
  accountBySourceAccountId: accounts_account_obj_rel_insert_input
  amount: numeric
  asset: String
  attempts: Int
  connector: connectors_connector_obj_rel_insert_input
  connector_id: String
  created_at: timestamptz
  description: String
  destination_account_id: String
  id: String
  initial_amount: numeric
  metadata: jsonb
  provider: connector_provider
  scheduled_at: timestamptz
  source_account_id: String
  transfer_initiation_adjustments: transfers_transfer_initiation_adjustments_arr_rel_insert_input
  transfer_initiation_payments: transfers_transfer_initiation_payments_arr_rel_insert_input
  transfer_reversals: transfers_transfer_reversal_arr_rel_insert_input
  type: Int
}

"""aggregate max on columns"""
type transfers_transfer_initiation_max_fields {
  amount: numeric
  asset: String
  attempts: Int
  connector_id: String
  created_at: timestamptz
  description: String
  destination_account_id: String
  id: String
  initial_amount: numeric
  provider: connector_provider
  scheduled_at: timestamptz
  source_account_id: String
  type: Int
}

"""
order by max() on columns of table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_max_order_by {
  amount: order_by
  asset: order_by
  attempts: order_by
  connector_id: order_by
  created_at: order_by
  description: order_by
  destination_account_id: order_by
  id: order_by
  initial_amount: order_by
  provider: order_by
  scheduled_at: order_by
  source_account_id: order_by
  type: order_by
}

"""aggregate min on columns"""
type transfers_transfer_initiation_min_fields {
  amount: numeric
  asset: String
  attempts: Int
  connector_id: String
  created_at: timestamptz
  description: String
  destination_account_id: String
  id: String
  initial_amount: numeric
  provider: connector_provider
  scheduled_at: timestamptz
  source_account_id: String
  type: Int
}

"""
order by min() on columns of table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_min_order_by {
  amount: order_by
  asset: order_by
  attempts: order_by
  connector_id: order_by
  created_at: order_by
  description: order_by
  destination_account_id: order_by
  id: order_by
  initial_amount: order_by
  provider: order_by
  scheduled_at: order_by
  source_account_id: order_by
  type: order_by
}

"""
response of any mutation on the table "transfers.transfer_initiation"
"""
type transfers_transfer_initiation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [transfers_transfer_initiation!]!
}

"""
input type for inserting object relation for remote table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_obj_rel_insert_input {
  data: transfers_transfer_initiation_insert_input!

  """upsert condition"""
  on_conflict: transfers_transfer_initiation_on_conflict
}

"""
on_conflict condition type for table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_on_conflict {
  constraint: transfers_transfer_initiation_constraint!
  update_columns: [transfers_transfer_initiation_update_column!]! = []
  where: transfers_transfer_initiation_bool_exp
}

"""
Ordering options when selecting data from "transfers.transfer_initiation".
"""
input transfers_transfer_initiation_order_by {
  account: accounts_account_order_by
  accountBySourceAccountId: accounts_account_order_by
  amount: order_by
  asset: order_by
  attempts: order_by
  connector: connectors_connector_order_by
  connector_id: order_by
  created_at: order_by
  description: order_by
  destination_account_id: order_by
  id: order_by
  initial_amount: order_by
  metadata: order_by
  provider: order_by
  scheduled_at: order_by
  source_account_id: order_by
  transfer_initiation_adjustments_aggregate: transfers_transfer_initiation_adjustments_aggregate_order_by
  transfer_initiation_payments_aggregate: transfers_transfer_initiation_payments_aggregate_order_by
  transfer_reversals_aggregate: transfers_transfer_reversal_aggregate_order_by
  type: order_by
}

"""
columns and relationships of "transfers.transfer_initiation_payments"
"""
type transfers_transfer_initiation_payments {
  created_at: timestamptz!
  error: String
  payment_id: String!
  status: Int!

  """An object relationship"""
  transfer_initiation: transfers_transfer_initiation!
  transfer_initiation_id: String!
}

"""
aggregated selection of "transfers.transfer_initiation_payments"
"""
type transfers_transfer_initiation_payments_aggregate {
  aggregate: transfers_transfer_initiation_payments_aggregate_fields
  nodes: [transfers_transfer_initiation_payments!]!
}

input transfers_transfer_initiation_payments_aggregate_bool_exp {
  count: transfers_transfer_initiation_payments_aggregate_bool_exp_count
}

input transfers_transfer_initiation_payments_aggregate_bool_exp_count {
  arguments: [transfers_transfer_initiation_payments_select_column!]
  distinct: Boolean
  filter: transfers_transfer_initiation_payments_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "transfers.transfer_initiation_payments"
"""
type transfers_transfer_initiation_payments_aggregate_fields {
  avg: transfers_transfer_initiation_payments_avg_fields
  count(columns: [transfers_transfer_initiation_payments_select_column!], distinct: Boolean): Int!
  max: transfers_transfer_initiation_payments_max_fields
  min: transfers_transfer_initiation_payments_min_fields
  stddev: transfers_transfer_initiation_payments_stddev_fields
  stddev_pop: transfers_transfer_initiation_payments_stddev_pop_fields
  stddev_samp: transfers_transfer_initiation_payments_stddev_samp_fields
  sum: transfers_transfer_initiation_payments_sum_fields
  var_pop: transfers_transfer_initiation_payments_var_pop_fields
  var_samp: transfers_transfer_initiation_payments_var_samp_fields
  variance: transfers_transfer_initiation_payments_variance_fields
}

"""
order by aggregate values of table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_aggregate_order_by {
  avg: transfers_transfer_initiation_payments_avg_order_by
  count: order_by
  max: transfers_transfer_initiation_payments_max_order_by
  min: transfers_transfer_initiation_payments_min_order_by
  stddev: transfers_transfer_initiation_payments_stddev_order_by
  stddev_pop: transfers_transfer_initiation_payments_stddev_pop_order_by
  stddev_samp: transfers_transfer_initiation_payments_stddev_samp_order_by
  sum: transfers_transfer_initiation_payments_sum_order_by
  var_pop: transfers_transfer_initiation_payments_var_pop_order_by
  var_samp: transfers_transfer_initiation_payments_var_samp_order_by
  variance: transfers_transfer_initiation_payments_variance_order_by
}

"""
input type for inserting array relation for remote table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_arr_rel_insert_input {
  data: [transfers_transfer_initiation_payments_insert_input!]!

  """upsert condition"""
  on_conflict: transfers_transfer_initiation_payments_on_conflict
}

"""aggregate avg on columns"""
type transfers_transfer_initiation_payments_avg_fields {
  status: Float
}

"""
order by avg() on columns of table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_avg_order_by {
  status: order_by
}

"""
Boolean expression to filter rows from the table "transfers.transfer_initiation_payments". All fields are combined with a logical 'AND'.
"""
input transfers_transfer_initiation_payments_bool_exp {
  _and: [transfers_transfer_initiation_payments_bool_exp!]
  _not: transfers_transfer_initiation_payments_bool_exp
  _or: [transfers_transfer_initiation_payments_bool_exp!]
  created_at: timestamptz_comparison_exp
  error: String_comparison_exp
  payment_id: String_comparison_exp
  status: Int_comparison_exp
  transfer_initiation: transfers_transfer_initiation_bool_exp
  transfer_initiation_id: String_comparison_exp
}

"""
unique or primary key constraints on table "transfers.transfer_initiation_payments"
"""
enum transfers_transfer_initiation_payments_constraint {
  """
  unique or primary key constraint on columns "transfer_initiation_id", "payment_id"
  """
  transfer_initiation_payments_pkey
}

"""
input type for incrementing numeric columns in table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_inc_input {
  status: Int
}

"""
input type for inserting data into table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_insert_input {
  created_at: timestamptz
  error: String
  payment_id: String
  status: Int
  transfer_initiation: transfers_transfer_initiation_obj_rel_insert_input
  transfer_initiation_id: String
}

"""aggregate max on columns"""
type transfers_transfer_initiation_payments_max_fields {
  created_at: timestamptz
  error: String
  payment_id: String
  status: Int
  transfer_initiation_id: String
}

"""
order by max() on columns of table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_max_order_by {
  created_at: order_by
  error: order_by
  payment_id: order_by
  status: order_by
  transfer_initiation_id: order_by
}

"""aggregate min on columns"""
type transfers_transfer_initiation_payments_min_fields {
  created_at: timestamptz
  error: String
  payment_id: String
  status: Int
  transfer_initiation_id: String
}

"""
order by min() on columns of table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_min_order_by {
  created_at: order_by
  error: order_by
  payment_id: order_by
  status: order_by
  transfer_initiation_id: order_by
}

"""
response of any mutation on the table "transfers.transfer_initiation_payments"
"""
type transfers_transfer_initiation_payments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [transfers_transfer_initiation_payments!]!
}

"""
on_conflict condition type for table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_on_conflict {
  constraint: transfers_transfer_initiation_payments_constraint!
  update_columns: [transfers_transfer_initiation_payments_update_column!]! = []
  where: transfers_transfer_initiation_payments_bool_exp
}

"""
Ordering options when selecting data from "transfers.transfer_initiation_payments".
"""
input transfers_transfer_initiation_payments_order_by {
  created_at: order_by
  error: order_by
  payment_id: order_by
  status: order_by
  transfer_initiation: transfers_transfer_initiation_order_by
  transfer_initiation_id: order_by
}

"""
primary key columns input for table: transfers.transfer_initiation_payments
"""
input transfers_transfer_initiation_payments_pk_columns_input {
  payment_id: String!
  transfer_initiation_id: String!
}

"""
select columns of table "transfers.transfer_initiation_payments"
"""
enum transfers_transfer_initiation_payments_select_column {
  """column name"""
  created_at

  """column name"""
  error

  """column name"""
  payment_id

  """column name"""
  status

  """column name"""
  transfer_initiation_id
}

"""
input type for updating data in table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_set_input {
  created_at: timestamptz
  error: String
  payment_id: String
  status: Int
  transfer_initiation_id: String
}

"""aggregate stddev on columns"""
type transfers_transfer_initiation_payments_stddev_fields {
  status: Float
}

"""
order by stddev() on columns of table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_stddev_order_by {
  status: order_by
}

"""aggregate stddev_pop on columns"""
type transfers_transfer_initiation_payments_stddev_pop_fields {
  status: Float
}

"""
order by stddev_pop() on columns of table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_stddev_pop_order_by {
  status: order_by
}

"""aggregate stddev_samp on columns"""
type transfers_transfer_initiation_payments_stddev_samp_fields {
  status: Float
}

"""
order by stddev_samp() on columns of table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_stddev_samp_order_by {
  status: order_by
}

"""
Streaming cursor of the table "transfers_transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: transfers_transfer_initiation_payments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input transfers_transfer_initiation_payments_stream_cursor_value_input {
  created_at: timestamptz
  error: String
  payment_id: String
  status: Int
  transfer_initiation_id: String
}

"""aggregate sum on columns"""
type transfers_transfer_initiation_payments_sum_fields {
  status: Int
}

"""
order by sum() on columns of table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_sum_order_by {
  status: order_by
}

"""
update columns of table "transfers.transfer_initiation_payments"
"""
enum transfers_transfer_initiation_payments_update_column {
  """column name"""
  created_at

  """column name"""
  error

  """column name"""
  payment_id

  """column name"""
  status

  """column name"""
  transfer_initiation_id
}

input transfers_transfer_initiation_payments_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: transfers_transfer_initiation_payments_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: transfers_transfer_initiation_payments_set_input

  """filter the rows which have to be updated"""
  where: transfers_transfer_initiation_payments_bool_exp!
}

"""aggregate var_pop on columns"""
type transfers_transfer_initiation_payments_var_pop_fields {
  status: Float
}

"""
order by var_pop() on columns of table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_var_pop_order_by {
  status: order_by
}

"""aggregate var_samp on columns"""
type transfers_transfer_initiation_payments_var_samp_fields {
  status: Float
}

"""
order by var_samp() on columns of table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_var_samp_order_by {
  status: order_by
}

"""aggregate variance on columns"""
type transfers_transfer_initiation_payments_variance_fields {
  status: Float
}

"""
order by variance() on columns of table "transfers.transfer_initiation_payments"
"""
input transfers_transfer_initiation_payments_variance_order_by {
  status: order_by
}

"""primary key columns input for table: transfers.transfer_initiation"""
input transfers_transfer_initiation_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input transfers_transfer_initiation_prepend_input {
  metadata: jsonb
}

"""
select columns of table "transfers.transfer_initiation"
"""
enum transfers_transfer_initiation_select_column {
  """column name"""
  amount

  """column name"""
  asset

  """column name"""
  attempts

  """column name"""
  connector_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  destination_account_id

  """column name"""
  id

  """column name"""
  initial_amount

  """column name"""
  metadata

  """column name"""
  provider

  """column name"""
  scheduled_at

  """column name"""
  source_account_id

  """column name"""
  type
}

"""
input type for updating data in table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_set_input {
  amount: numeric
  asset: String
  attempts: Int
  connector_id: String
  created_at: timestamptz
  description: String
  destination_account_id: String
  id: String
  initial_amount: numeric
  metadata: jsonb
  provider: connector_provider
  scheduled_at: timestamptz
  source_account_id: String
  type: Int
}

"""aggregate stddev on columns"""
type transfers_transfer_initiation_stddev_fields {
  amount: Float
  attempts: Float
  initial_amount: Float
  type: Float
}

"""
order by stddev() on columns of table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_stddev_order_by {
  amount: order_by
  attempts: order_by
  initial_amount: order_by
  type: order_by
}

"""aggregate stddev_pop on columns"""
type transfers_transfer_initiation_stddev_pop_fields {
  amount: Float
  attempts: Float
  initial_amount: Float
  type: Float
}

"""
order by stddev_pop() on columns of table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_stddev_pop_order_by {
  amount: order_by
  attempts: order_by
  initial_amount: order_by
  type: order_by
}

"""aggregate stddev_samp on columns"""
type transfers_transfer_initiation_stddev_samp_fields {
  amount: Float
  attempts: Float
  initial_amount: Float
  type: Float
}

"""
order by stddev_samp() on columns of table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_stddev_samp_order_by {
  amount: order_by
  attempts: order_by
  initial_amount: order_by
  type: order_by
}

"""
Streaming cursor of the table "transfers_transfer_initiation"
"""
input transfers_transfer_initiation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: transfers_transfer_initiation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input transfers_transfer_initiation_stream_cursor_value_input {
  amount: numeric
  asset: String
  attempts: Int
  connector_id: String
  created_at: timestamptz
  description: String
  destination_account_id: String
  id: String
  initial_amount: numeric
  metadata: jsonb
  provider: connector_provider
  scheduled_at: timestamptz
  source_account_id: String
  type: Int
}

"""aggregate sum on columns"""
type transfers_transfer_initiation_sum_fields {
  amount: numeric
  attempts: Int
  initial_amount: numeric
  type: Int
}

"""
order by sum() on columns of table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_sum_order_by {
  amount: order_by
  attempts: order_by
  initial_amount: order_by
  type: order_by
}

"""
update columns of table "transfers.transfer_initiation"
"""
enum transfers_transfer_initiation_update_column {
  """column name"""
  amount

  """column name"""
  asset

  """column name"""
  attempts

  """column name"""
  connector_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  destination_account_id

  """column name"""
  id

  """column name"""
  initial_amount

  """column name"""
  metadata

  """column name"""
  provider

  """column name"""
  scheduled_at

  """column name"""
  source_account_id

  """column name"""
  type
}

input transfers_transfer_initiation_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: transfers_transfer_initiation_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: transfers_transfer_initiation_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: transfers_transfer_initiation_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: transfers_transfer_initiation_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: transfers_transfer_initiation_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: transfers_transfer_initiation_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: transfers_transfer_initiation_set_input

  """filter the rows which have to be updated"""
  where: transfers_transfer_initiation_bool_exp!
}

"""aggregate var_pop on columns"""
type transfers_transfer_initiation_var_pop_fields {
  amount: Float
  attempts: Float
  initial_amount: Float
  type: Float
}

"""
order by var_pop() on columns of table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_var_pop_order_by {
  amount: order_by
  attempts: order_by
  initial_amount: order_by
  type: order_by
}

"""aggregate var_samp on columns"""
type transfers_transfer_initiation_var_samp_fields {
  amount: Float
  attempts: Float
  initial_amount: Float
  type: Float
}

"""
order by var_samp() on columns of table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_var_samp_order_by {
  amount: order_by
  attempts: order_by
  initial_amount: order_by
  type: order_by
}

"""aggregate variance on columns"""
type transfers_transfer_initiation_variance_fields {
  amount: Float
  attempts: Float
  initial_amount: Float
  type: Float
}

"""
order by variance() on columns of table "transfers.transfer_initiation"
"""
input transfers_transfer_initiation_variance_order_by {
  amount: order_by
  attempts: order_by
  initial_amount: order_by
  type: order_by
}

"""
columns and relationships of "transfers.transfer_reversal"
"""
type transfers_transfer_reversal {
  amount: numeric!
  asset: String!

  """An object relationship"""
  connector: connectors_connector!
  connector_id: String!
  created_at: timestamptz!
  description: String!
  error: String
  id: String!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  reference: String
  status: Int!

  """An object relationship"""
  transfer_initiation: transfers_transfer_initiation!
  transfer_initiation_id: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "transfers.transfer_reversal"
"""
type transfers_transfer_reversal_aggregate {
  aggregate: transfers_transfer_reversal_aggregate_fields
  nodes: [transfers_transfer_reversal!]!
}

input transfers_transfer_reversal_aggregate_bool_exp {
  count: transfers_transfer_reversal_aggregate_bool_exp_count
}

input transfers_transfer_reversal_aggregate_bool_exp_count {
  arguments: [transfers_transfer_reversal_select_column!]
  distinct: Boolean
  filter: transfers_transfer_reversal_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "transfers.transfer_reversal"
"""
type transfers_transfer_reversal_aggregate_fields {
  avg: transfers_transfer_reversal_avg_fields
  count(columns: [transfers_transfer_reversal_select_column!], distinct: Boolean): Int!
  max: transfers_transfer_reversal_max_fields
  min: transfers_transfer_reversal_min_fields
  stddev: transfers_transfer_reversal_stddev_fields
  stddev_pop: transfers_transfer_reversal_stddev_pop_fields
  stddev_samp: transfers_transfer_reversal_stddev_samp_fields
  sum: transfers_transfer_reversal_sum_fields
  var_pop: transfers_transfer_reversal_var_pop_fields
  var_samp: transfers_transfer_reversal_var_samp_fields
  variance: transfers_transfer_reversal_variance_fields
}

"""
order by aggregate values of table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_aggregate_order_by {
  avg: transfers_transfer_reversal_avg_order_by
  count: order_by
  max: transfers_transfer_reversal_max_order_by
  min: transfers_transfer_reversal_min_order_by
  stddev: transfers_transfer_reversal_stddev_order_by
  stddev_pop: transfers_transfer_reversal_stddev_pop_order_by
  stddev_samp: transfers_transfer_reversal_stddev_samp_order_by
  sum: transfers_transfer_reversal_sum_order_by
  var_pop: transfers_transfer_reversal_var_pop_order_by
  var_samp: transfers_transfer_reversal_var_samp_order_by
  variance: transfers_transfer_reversal_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input transfers_transfer_reversal_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_arr_rel_insert_input {
  data: [transfers_transfer_reversal_insert_input!]!

  """upsert condition"""
  on_conflict: transfers_transfer_reversal_on_conflict
}

"""aggregate avg on columns"""
type transfers_transfer_reversal_avg_fields {
  amount: Float
  status: Float
}

"""
order by avg() on columns of table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_avg_order_by {
  amount: order_by
  status: order_by
}

"""
Boolean expression to filter rows from the table "transfers.transfer_reversal". All fields are combined with a logical 'AND'.
"""
input transfers_transfer_reversal_bool_exp {
  _and: [transfers_transfer_reversal_bool_exp!]
  _not: transfers_transfer_reversal_bool_exp
  _or: [transfers_transfer_reversal_bool_exp!]
  amount: numeric_comparison_exp
  asset: String_comparison_exp
  connector: connectors_connector_bool_exp
  connector_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  error: String_comparison_exp
  id: String_comparison_exp
  metadata: jsonb_comparison_exp
  reference: String_comparison_exp
  status: Int_comparison_exp
  transfer_initiation: transfers_transfer_initiation_bool_exp
  transfer_initiation_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "transfers.transfer_reversal"
"""
enum transfers_transfer_reversal_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  transfer_reversal_pkey

  """
  unique or primary key constraint on columns "transfer_initiation_id"
  """
  transfer_reversal_processing_unique_constraint
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input transfers_transfer_reversal_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input transfers_transfer_reversal_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input transfers_transfer_reversal_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_inc_input {
  amount: numeric
  status: Int
}

"""
input type for inserting data into table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_insert_input {
  amount: numeric
  asset: String
  connector: connectors_connector_obj_rel_insert_input
  connector_id: String
  created_at: timestamptz
  description: String
  error: String
  id: String
  metadata: jsonb
  reference: String
  status: Int
  transfer_initiation: transfers_transfer_initiation_obj_rel_insert_input
  transfer_initiation_id: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type transfers_transfer_reversal_max_fields {
  amount: numeric
  asset: String
  connector_id: String
  created_at: timestamptz
  description: String
  error: String
  id: String
  reference: String
  status: Int
  transfer_initiation_id: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_max_order_by {
  amount: order_by
  asset: order_by
  connector_id: order_by
  created_at: order_by
  description: order_by
  error: order_by
  id: order_by
  reference: order_by
  status: order_by
  transfer_initiation_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type transfers_transfer_reversal_min_fields {
  amount: numeric
  asset: String
  connector_id: String
  created_at: timestamptz
  description: String
  error: String
  id: String
  reference: String
  status: Int
  transfer_initiation_id: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_min_order_by {
  amount: order_by
  asset: order_by
  connector_id: order_by
  created_at: order_by
  description: order_by
  error: order_by
  id: order_by
  reference: order_by
  status: order_by
  transfer_initiation_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "transfers.transfer_reversal"
"""
type transfers_transfer_reversal_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [transfers_transfer_reversal!]!
}

"""
on_conflict condition type for table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_on_conflict {
  constraint: transfers_transfer_reversal_constraint!
  update_columns: [transfers_transfer_reversal_update_column!]! = []
  where: transfers_transfer_reversal_bool_exp
}

"""
Ordering options when selecting data from "transfers.transfer_reversal".
"""
input transfers_transfer_reversal_order_by {
  amount: order_by
  asset: order_by
  connector: connectors_connector_order_by
  connector_id: order_by
  created_at: order_by
  description: order_by
  error: order_by
  id: order_by
  metadata: order_by
  reference: order_by
  status: order_by
  transfer_initiation: transfers_transfer_initiation_order_by
  transfer_initiation_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: transfers.transfer_reversal"""
input transfers_transfer_reversal_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input transfers_transfer_reversal_prepend_input {
  metadata: jsonb
}

"""
select columns of table "transfers.transfer_reversal"
"""
enum transfers_transfer_reversal_select_column {
  """column name"""
  amount

  """column name"""
  asset

  """column name"""
  connector_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  error

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  reference

  """column name"""
  status

  """column name"""
  transfer_initiation_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_set_input {
  amount: numeric
  asset: String
  connector_id: String
  created_at: timestamptz
  description: String
  error: String
  id: String
  metadata: jsonb
  reference: String
  status: Int
  transfer_initiation_id: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type transfers_transfer_reversal_stddev_fields {
  amount: Float
  status: Float
}

"""
order by stddev() on columns of table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_stddev_order_by {
  amount: order_by
  status: order_by
}

"""aggregate stddev_pop on columns"""
type transfers_transfer_reversal_stddev_pop_fields {
  amount: Float
  status: Float
}

"""
order by stddev_pop() on columns of table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_stddev_pop_order_by {
  amount: order_by
  status: order_by
}

"""aggregate stddev_samp on columns"""
type transfers_transfer_reversal_stddev_samp_fields {
  amount: Float
  status: Float
}

"""
order by stddev_samp() on columns of table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_stddev_samp_order_by {
  amount: order_by
  status: order_by
}

"""
Streaming cursor of the table "transfers_transfer_reversal"
"""
input transfers_transfer_reversal_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: transfers_transfer_reversal_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input transfers_transfer_reversal_stream_cursor_value_input {
  amount: numeric
  asset: String
  connector_id: String
  created_at: timestamptz
  description: String
  error: String
  id: String
  metadata: jsonb
  reference: String
  status: Int
  transfer_initiation_id: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type transfers_transfer_reversal_sum_fields {
  amount: numeric
  status: Int
}

"""
order by sum() on columns of table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_sum_order_by {
  amount: order_by
  status: order_by
}

"""
update columns of table "transfers.transfer_reversal"
"""
enum transfers_transfer_reversal_update_column {
  """column name"""
  amount

  """column name"""
  asset

  """column name"""
  connector_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  error

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  reference

  """column name"""
  status

  """column name"""
  transfer_initiation_id

  """column name"""
  updated_at
}

input transfers_transfer_reversal_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: transfers_transfer_reversal_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: transfers_transfer_reversal_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: transfers_transfer_reversal_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: transfers_transfer_reversal_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: transfers_transfer_reversal_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: transfers_transfer_reversal_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: transfers_transfer_reversal_set_input

  """filter the rows which have to be updated"""
  where: transfers_transfer_reversal_bool_exp!
}

"""aggregate var_pop on columns"""
type transfers_transfer_reversal_var_pop_fields {
  amount: Float
  status: Float
}

"""
order by var_pop() on columns of table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_var_pop_order_by {
  amount: order_by
  status: order_by
}

"""aggregate var_samp on columns"""
type transfers_transfer_reversal_var_samp_fields {
  amount: Float
  status: Float
}

"""
order by var_samp() on columns of table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_var_samp_order_by {
  amount: order_by
  status: order_by
}

"""aggregate variance on columns"""
type transfers_transfer_reversal_variance_fields {
  amount: Float
  status: Float
}

"""
order by variance() on columns of table "transfers.transfer_reversal"
"""
input transfers_transfer_reversal_variance_order_by {
  amount: order_by
  status: order_by
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}