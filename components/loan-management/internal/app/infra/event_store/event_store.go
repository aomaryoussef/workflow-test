package event_store

import (
	"context"
	"errors"
	"github.com/btechlabs/lms/pkg/cqrs"
)

var (
	ErrFailedToSaveEvent = errors.New("failed to insert eventsourcing")
)

const (
	tracerName = "event_store"
)

// EventStore defines the interface for an eventsourcing store.
// The eventsourcing store is responsible for storing all events that are generated by the application.
type EventStore[TX any] interface {
	SaveEvents(ctx context.Context, events []cqrs.Event, getTx func() TX) error
	LoadEvents(ctx context.Context, query *EventStoreQuery, getTx func() TX) ([]cqrs.Event, error)
}

type EventStoreQueryBuilderOpts func(*EventStoreQuery)
type EventStoreQuery struct {
	aggregateId          string
	aggregateType        string
	fromEventIdInclusive string
	toEventIdInclusive   string
	fromEventIdExclusive string
	toEventIdExclusive   string
}

func NewEventStoreQuery(opts ...EventStoreQueryBuilderOpts) *EventStoreQuery {
	q := &EventStoreQuery{}
	for _, opt := range opts {
		opt(q)
	}
	return q
}

func WithAggregateType(aggregateType string) EventStoreQueryBuilderOpts {
	return func(q *EventStoreQuery) {
		q.aggregateType = aggregateType
	}
}

func WithAggregateId(aggregateId string) EventStoreQueryBuilderOpts {
	return func(q *EventStoreQuery) {
		q.aggregateId = aggregateId
	}
}

func WithFromEventIdInclusive(fromEventIdInclusive string) EventStoreQueryBuilderOpts {
	return func(q *EventStoreQuery) {
		q.fromEventIdInclusive = fromEventIdInclusive
	}
}

func WithToEventIdInclusive(toEventIdInclusive string) EventStoreQueryBuilderOpts {
	return func(q *EventStoreQuery) {
		q.toEventIdInclusive = toEventIdInclusive
	}
}

func WithFromEventIdExclusive(fromEventIdExclusive string) EventStoreQueryBuilderOpts {
	return func(q *EventStoreQuery) {
		q.fromEventIdExclusive = fromEventIdExclusive
	}
}

func WithToEventIdExclusive(toEventIdExclusive string) EventStoreQueryBuilderOpts {
	return func(q *EventStoreQuery) {
		q.toEventIdExclusive = toEventIdExclusive
	}
}
